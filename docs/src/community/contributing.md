# Contributing

We welcome community contributions to this project.

Please talk with us on Discord beforehand if you'd like to contribute a larger piece of work. This is particularly important if your contribution involves adding new functionality to the host; our goal is to implement as much functionality on the guest as possible, so that the host can remain simple and enable a wide variety of use cases without being too opinionated.

## Campfire

Campfire is our internal tool for working with the repository. It has several commands that can be used to help with development, which you can find by running `cargo campfire --help`.

It is also aliased to `cargo cf` for convenience.

Running an example can be done like this:

```sh
cargo cf run decals
```

By default, Campfire will build Ambient with the `debug` profile. To build with the `release` profile and to build the assets with `--relase`, use the `--release` flag before the example and after:

```sh
cargo cf run --release decals -- --release
```

## API docs

To see the latest version of the API docs, run the following command in the `Ambient` repository:

```sh
cargo campfire doc api --open
```

## Adding to the API

Our bindings are defined in [WIT](https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md), which is a language-independent interface definition language for defining WebAssembly interfaces.
They are found in the [`crates/wasm/wit`](https://github.com/AmbientRun/Ambient/tree/main/crates/wasm/wit) folder.
At present, there is only one WIT world, `bindings`, in the `main.wit` folder, and it is used for both the client and server bindings.

These bindings are wired up in the host using [`wasmtime`'s Component Model support](https://docs.wasmtime.dev/api/wasmtime/component/index.html).
The WIT interfaces generate traits, which are then implemented within [crates/wasm/src/client/mod.rs](https://github.com/AmbientRun/Ambient/tree/main/crates/wasm/src/client/mod.rs) and [crates/wasm/src/server/mod.rs](https://github.com/AmbientRun/Ambient/tree/main/crates/wasm/src/server/mod.rs). As all interfaces need to be implemented - even when not relevant to the side of the network boundary you're on - unused implementations go in the `unused.rs` module in the same folder.

Types that are shared between interfaces should go in `types.wit`; otherwise, they should go in the relevant interface file. Where possible, try to describe as much within the WIT files; the more that is specified in the WIT files, the less code needs to be written for each guest language.

If you add a new interface, you will need to expose it in `main.wit`, update `crates/wasm/src/shared/bindings.rs` to include it in `BindingsBound`, and add implementations for the new trait in `crates/wasm/src/client/mod.rs` and `crates/wasm/src/server/mod.rs`.

On the host, add implementations of `IntoBindgen` and `FromBindgen` for your WIT type. This is typically done in a `conversion.rs`. This allows you to use the type in the host code with the usual affordances, while still being able to pass it to the guest.

### Guest considerations

At present, we only support Rust as a guest language, but we want to improve this in future. The following advice applies only to Rust.

---

The WIT bindings are automatically generated by the host's `ambient_wasm` build script. This build script runs [`wit-bindgen`](https://github.com/bytecodealliance/wit-bindgen) as a library and updates `guest/rust/api_core/src/internal/bindings.rs` with the generated code. You may need to build the host in order to update the guest API code after making changes to the WIT files, but running `cargo check` (including through your IDE on save) should be sufficient to trigger this process.

When merging code that changes the bindings, there may be a conflict in the generated `bindings.rs` file. In this case, delete the file and run `cargo check -p ambient_wasm` (or a similar command that will run `ambient_wasm`'s build script) to force regeneration of the file.

Where relevant/possible, use native types and convert to/from the WIT types with `IntoBindgen`/`FromBindgen`. This allows both API developers and users to use the type they would expect (e.g. `glam::Vec3` instead of the WIT-generated `Vec3`), and to extend it with additional methods where required.

This means that if you define a

```wit
record ray {
    origin: vec3,
    direction: vec3,
}
```

you should also consider defining

```rust
/// Some documentation
struct Ray {
    // Per-field
    origin: Vec3,
    // Documentation
    direction: Vec3,
}
impl IntoBindgen for Ray {
    type Item = wit::types::Ray;
    fn into_bindgen(self) -> Self::Item {
        wit::types::Ray {
            origin: self.origin.into_bindgen(),
            direction: self.direction.into_bindgen(),
        }
    }
}
impl FromBindgen for wit::types::Ray {
    type Item = Ray;
    fn from_bindgen(self) -> Self::Item {
        Ray {
            origin: self.origin.from_bindgen(),
            direction: self.direction.from_bindgen(),
        }
    }
}
impl Ray {
    /* helper methods */
}
```

so that you can provide Rust-specific features. Where possible, try to avoid exposing the WIT types to the user, and try to keep as much functionality in WIT to ensure other guest languages can benefit from it.

## Adding a new supported component type

Components and their values are the core unit of data exchange in Ambient. We try to keep to a core set of types as adding more types results in some amount of bloat (especially with the amount of code generated); however, adding a new type is often the best way to represent a specific kind of data.

To do so, you will need to update the following files:

### Core definitions

- `crates/wasm/wit/component.wit`: Add the new type to the three `value` enums.
- `shared_crates/shared_types/src/lib.rs`: Add the new type to the `primitive_component_definitions` definition.

### Code generation

- `shared_crates/project_macro_common/src/component.rs`: Specify how to generate the type definition for `convert_primitive_type_to_rust_type`.
- `shared_crates/project_macro_common/src/concept.rs`: Specify how to generate Rust code for a value of the type from TOML in `toml_value_to_tokens_primitive`.

### Runtime support

- `shared_crates/project_rt/src/message_serde.rs`: Specify how to serialize and deserialize the type to a binary stream.

### Utilities

- `crates/wasm/src/shared/conversion.rs`: Add `IntoBindgen`/`FromBindgen` implementations if appropriate.
- `guest/rust/api_core/src/internal/conversion.rs`: Add `IntoBindgen`/`FromBindgen` implementations if appropriate.

### Documentation

- `CHANGELOG.md`: Document the addition of the new supported type.
- `docs/src/reference/ambient.sample.toml`: Document the new type in the sample TOML file.
- `docs/src/reference/project.md`: Document the new type in the components section.

## Golden image tests

The golden image tests run on the CI and produce a `screenshot.png`, which is compared to the one in the repository.
To update the golden images, run `node scripts/golden_image_tests.js`.

To debug why the CI fails, download the `screenshots.zip` file from the build artifacts, and look in the logs of the CI.
The `screenshots.zip` will show what image the CI produced.

## Releasing

1. Run `cargo campfire doc runtime` to update the documentation from the codebase.
2. Run `cargo campfire release update-version new_version_here` to update the Ambient version across the crates and documentation.
3. If a new system dependency was added, ensure it is added to `docs/src/installing.md` and `Dockerfile`.
4. Run `cargo campfire example check-all` and ensure all guest projects build without errors.
5. Run `cargo campfire example run-all` and visually verify that they work as expected.
6. Use `cargo campfire release check` to check that the release is ready.
7. Update the `CHANGELOG.md` at the root of the repository. Copy the unreleased block, set the version and date on the copy, and then empty out the unreleased block for the next release.
8. Make a commit with the above changes, and create a tag `v0.X.Y`.
9. Push to origin.
