// Generated by `wit-bindgen` 0.9.0. DO NOT EDIT!

/// Declares the export of the component's world for the
/// given type.

macro_rules! export_bindings(($t:ident) => {
  const _: () = {
    
    const _: () = {
      #[doc(hidden)]
      #[export_name = "ambient:bindings/guest#init"]
      #[allow(non_snake_case)]
      unsafe extern "C" fn __export_init() {
        exports::ambient::bindings::guest::call_init::<$t>()
      }
      
    };
    
    const _: () = {
      #[doc(hidden)]
      #[export_name = "ambient:bindings/guest#exec"]
      #[allow(non_snake_case)]
      unsafe extern "C" fn __export_exec(arg0: i32,arg1: i64,arg2: i64,arg3: i32,arg4: i32,arg5: i32,arg6: i32,) {
        exports::ambient::bindings::guest::call_exec::<$t>(arg0,arg1,arg2,arg3,arg4,arg5,arg6,)
      }
      
    };
    
  };
  
  #[used]
  #[doc(hidden)]
  #[cfg(target_arch = "wasm32")]
  static __FORCE_SECTION_REF: fn() = __link_section;
});
pub mod ambient {
  pub mod bindings {
    
    #[allow(clippy::all)]
    pub mod types {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct EntityId {
        pub id0: u64,
        pub id1: u64,
      }
      impl ::core::fmt::Debug for EntityId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("EntityId").field("id0", &self.id0).field("id1", &self.id1).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Vec2 {
        pub x: f32,
        pub y: f32,
      }
      impl ::core::fmt::Debug for Vec2 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Vec2").field("x", &self.x).field("y", &self.y).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Vec3 {
        pub x: f32,
        pub y: f32,
        pub z: f32,
      }
      impl ::core::fmt::Debug for Vec3 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Vec3").field("x", &self.x).field("y", &self.y).field("z", &self.z).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Vec4 {
        pub x: f32,
        pub y: f32,
        pub z: f32,
        pub w: f32,
      }
      impl ::core::fmt::Debug for Vec4 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Vec4").field("x", &self.x).field("y", &self.y).field("z", &self.z).field("w", &self.w).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Uvec2 {
        pub x: u32,
        pub y: u32,
      }
      impl ::core::fmt::Debug for Uvec2 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Uvec2").field("x", &self.x).field("y", &self.y).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Uvec3 {
        pub x: u32,
        pub y: u32,
        pub z: u32,
      }
      impl ::core::fmt::Debug for Uvec3 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Uvec3").field("x", &self.x).field("y", &self.y).field("z", &self.z).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Uvec4 {
        pub x: u32,
        pub y: u32,
        pub z: u32,
        pub w: u32,
      }
      impl ::core::fmt::Debug for Uvec4 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Uvec4").field("x", &self.x).field("y", &self.y).field("z", &self.z).field("w", &self.w).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Ivec2 {
        pub x: i32,
        pub y: i32,
      }
      impl ::core::fmt::Debug for Ivec2 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Ivec2").field("x", &self.x).field("y", &self.y).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Ivec3 {
        pub x: i32,
        pub y: i32,
        pub z: i32,
      }
      impl ::core::fmt::Debug for Ivec3 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Ivec3").field("x", &self.x).field("y", &self.y).field("z", &self.z).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Ivec4 {
        pub x: i32,
        pub y: i32,
        pub z: i32,
        pub w: i32,
      }
      impl ::core::fmt::Debug for Ivec4 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Ivec4").field("x", &self.x).field("y", &self.y).field("z", &self.z).field("w", &self.w).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Quat {
        pub x: f32,
        pub y: f32,
        pub z: f32,
        pub w: f32,
      }
      impl ::core::fmt::Debug for Quat {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Quat").field("x", &self.x).field("y", &self.y).field("z", &self.z).field("w", &self.w).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Mat4 {
        pub x: Vec4,
        pub y: Vec4,
        pub z: Vec4,
        pub w: Vec4,
      }
      impl ::core::fmt::Debug for Mat4 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Mat4").field("x", &self.x).field("y", &self.y).field("z", &self.z).field("w", &self.w).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Duration {
        pub seconds: u64,
        pub nanoseconds: u32,
      }
      impl ::core::fmt::Debug for Duration {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Duration").field("seconds", &self.seconds).field("nanoseconds", &self.nanoseconds).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Ray {
        pub origin: Vec3,
        pub dir: Vec3,
      }
      impl ::core::fmt::Debug for Ray {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Ray").field("origin", &self.origin).field("dir", &self.dir).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Empty {
        pub dummy: u8,
      }
      impl ::core::fmt::Debug for Empty {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Empty").field("dummy", &self.dummy).finish()
        }
      }
      pub type Ulid = (u64,u64,);
      
    }
    
    
    #[allow(clippy::all)]
    pub mod asset {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      
      #[derive(Clone)]
      pub enum UrlError{
        InvalidUrl(wit_bindgen::rt::string::String),
      }
      impl ::core::fmt::Debug for UrlError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UrlError::InvalidUrl(e) => {
              f.debug_tuple("UrlError::InvalidUrl").field(e).finish()
            }
          }
        }
      }
      impl ::core::fmt::Display for UrlError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)}
        }
        
        impl std::error::Error for UrlError {}
        #[allow(clippy::all)]
        pub fn url(path: &str,) -> Result<wit_bindgen::rt::string::String,UrlError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let vec0 = path;
            let ptr0 = vec0.as_ptr() as i32;
            let len0 = vec0.len() as i32;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[link(wasm_import_module = "ambient:bindings/asset")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "url")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/asset_url")]
              fn wit_import(
              _: i32, _: i32, _: i32, );
            }
            wit_import(ptr0, len0, ptr1);
            match i32::from(*((ptr1 + 0) as *const u8)) {
              0 => Ok({
                let len2 = *((ptr1 + 8) as *const i32) as usize;
                
                {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 4) as *const i32) as *mut _, len2, len2))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 4) as *const i32) as *mut _, len2, len2)).unwrap()}}
              }),
              1 => Err({{match i32::from(*((ptr1 + 4) as *const u8)) {
                #[cfg(debug_assertions)]0 => UrlError::InvalidUrl({
                  let len3 = *((ptr1 + 12) as *const i32) as usize;
                  
                  {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 8) as *const i32) as *mut _, len3, len3))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 8) as *const i32) as *mut _, len3, len3)).unwrap()}}
                }),
                #[cfg(not(debug_assertions))]_ => UrlError::InvalidUrl({
                  let len3 = *((ptr1 + 12) as *const i32) as usize;
                  
                  {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 8) as *const i32) as *mut _, len3, len3))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 8) as *const i32) as *mut _, len3, len3)).unwrap()}}
                }),
                #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
              }}}),
              #[cfg(not(debug_assertions))]
              _ => ::core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }
          }
        }
        
      }
      
      
      #[allow(clippy::all)]
      pub mod client_mesh {
        #[used]
        #[doc(hidden)]
        #[cfg(target_arch = "wasm32")]
        static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
        
        pub type Vec2 = super::super::super::ambient::bindings::types::Vec2;
        pub type Vec3 = super::super::super::ambient::bindings::types::Vec3;
        pub type Ulid = super::super::super::ambient::bindings::types::Ulid;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct Vertex {
          pub position: Vec3,
          pub normal: Vec3,
          pub tangent: Vec3,
          pub texcoord0: Vec2,
        }
        impl ::core::fmt::Debug for Vertex {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Vertex").field("position", &self.position).field("normal", &self.normal).field("tangent", &self.tangent).field("texcoord0", &self.texcoord0).finish()
          }
        }
        #[derive(Clone)]
        pub struct Descriptor {
          pub vertices: wit_bindgen::rt::vec::Vec::<Vertex>,
          pub indices: wit_bindgen::rt::vec::Vec::<u32>,
        }
        impl ::core::fmt::Debug for Descriptor {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Descriptor").field("vertices", &self.vertices).field("indices", &self.indices).finish()
          }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct Handle {
          pub ulid: Ulid,
        }
        impl ::core::fmt::Debug for Handle {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Handle").field("ulid", &self.ulid).finish()
          }
        }
        #[allow(clippy::all)]
        pub fn create(desc: &Descriptor,) -> Handle{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let Descriptor{ vertices:vertices0, indices:indices0, } = desc;
            let vec1 = vertices0;
            let ptr1 = vec1.as_ptr() as i32;
            let len1 = vec1.len() as i32;
            let vec2 = indices0;
            let ptr2 = vec2.as_ptr() as i32;
            let len2 = vec2.len() as i32;
            let ptr3 = ret_area.as_mut_ptr() as i32;
            #[link(wasm_import_module = "ambient:bindings/client-mesh")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "create")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-mesh_create")]
              fn wit_import(
              _: i32, _: i32, _: i32, _: i32, _: i32, );
            }
            wit_import(ptr1, len1, ptr2, len2, ptr3);
            Handle{ulid:(*((ptr3 + 0) as *const i64) as u64, *((ptr3 + 8) as *const i64) as u64), }
          }
        }
        #[allow(clippy::all)]
        pub fn destroy(handle: Handle,){
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            let Handle{ ulid:ulid0, } = handle;
            let (t1_0, t1_1, ) = ulid0;
            
            #[link(wasm_import_module = "ambient:bindings/client-mesh")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "destroy")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-mesh_destroy")]
              fn wit_import(
              _: i64, _: i64, );
            }
            wit_import(wit_bindgen::rt::as_i64(t1_0), wit_bindgen::rt::as_i64(t1_1));
          }
        }
        
      }
      
      
      #[allow(clippy::all)]
      pub mod client_texture {
        #[used]
        #[doc(hidden)]
        #[cfg(target_arch = "wasm32")]
        static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
        
        pub type Ulid = super::super::super::ambient::bindings::types::Ulid;
        #[derive(Clone, Copy)]
        pub enum Format{
          R8Unorm,
          R8Snorm,
          R8Uint,
          R8Sint,
          R16Uint,
          R16Sint,
          R16Unorm,
          R16Snorm,
          R16Float,
          Rg8Unorm,
          Rg8Snorm,
          Rg8Uint,
          Rg8Sint,
          R32Uint,
          R32Sint,
          R32Float,
          Rg16Uint,
          Rg16Sint,
          Rg16Unorm,
          Rg16Snorm,
          Rg16Float,
          Rgba8Unorm,
          Rgba8UnormSrgb,
          Rgba8Snorm,
          Rgba8Uint,
          Rgba8Sint,
          Bgra8Unorm,
          Bgra8UnormSrgb,
          Rgb9e5Ufloat,
          Rgb10a2Unorm,
          Rg11b10Float,
          Rg32Uint,
          Rg32Sint,
          Rg32Float,
          Rgba16Uint,
          Rgba16Sint,
          Rgba16Unorm,
          Rgba16Snorm,
          Rgba16Float,
          Rgba32Uint,
          Rgba32Sint,
          Rgba32Float,
        }
        impl ::core::fmt::Debug for Format {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              Format::R8Unorm => {
                f.debug_tuple("Format::R8Unorm").finish()
              }
              Format::R8Snorm => {
                f.debug_tuple("Format::R8Snorm").finish()
              }
              Format::R8Uint => {
                f.debug_tuple("Format::R8Uint").finish()
              }
              Format::R8Sint => {
                f.debug_tuple("Format::R8Sint").finish()
              }
              Format::R16Uint => {
                f.debug_tuple("Format::R16Uint").finish()
              }
              Format::R16Sint => {
                f.debug_tuple("Format::R16Sint").finish()
              }
              Format::R16Unorm => {
                f.debug_tuple("Format::R16Unorm").finish()
              }
              Format::R16Snorm => {
                f.debug_tuple("Format::R16Snorm").finish()
              }
              Format::R16Float => {
                f.debug_tuple("Format::R16Float").finish()
              }
              Format::Rg8Unorm => {
                f.debug_tuple("Format::Rg8Unorm").finish()
              }
              Format::Rg8Snorm => {
                f.debug_tuple("Format::Rg8Snorm").finish()
              }
              Format::Rg8Uint => {
                f.debug_tuple("Format::Rg8Uint").finish()
              }
              Format::Rg8Sint => {
                f.debug_tuple("Format::Rg8Sint").finish()
              }
              Format::R32Uint => {
                f.debug_tuple("Format::R32Uint").finish()
              }
              Format::R32Sint => {
                f.debug_tuple("Format::R32Sint").finish()
              }
              Format::R32Float => {
                f.debug_tuple("Format::R32Float").finish()
              }
              Format::Rg16Uint => {
                f.debug_tuple("Format::Rg16Uint").finish()
              }
              Format::Rg16Sint => {
                f.debug_tuple("Format::Rg16Sint").finish()
              }
              Format::Rg16Unorm => {
                f.debug_tuple("Format::Rg16Unorm").finish()
              }
              Format::Rg16Snorm => {
                f.debug_tuple("Format::Rg16Snorm").finish()
              }
              Format::Rg16Float => {
                f.debug_tuple("Format::Rg16Float").finish()
              }
              Format::Rgba8Unorm => {
                f.debug_tuple("Format::Rgba8Unorm").finish()
              }
              Format::Rgba8UnormSrgb => {
                f.debug_tuple("Format::Rgba8UnormSrgb").finish()
              }
              Format::Rgba8Snorm => {
                f.debug_tuple("Format::Rgba8Snorm").finish()
              }
              Format::Rgba8Uint => {
                f.debug_tuple("Format::Rgba8Uint").finish()
              }
              Format::Rgba8Sint => {
                f.debug_tuple("Format::Rgba8Sint").finish()
              }
              Format::Bgra8Unorm => {
                f.debug_tuple("Format::Bgra8Unorm").finish()
              }
              Format::Bgra8UnormSrgb => {
                f.debug_tuple("Format::Bgra8UnormSrgb").finish()
              }
              Format::Rgb9e5Ufloat => {
                f.debug_tuple("Format::Rgb9e5Ufloat").finish()
              }
              Format::Rgb10a2Unorm => {
                f.debug_tuple("Format::Rgb10a2Unorm").finish()
              }
              Format::Rg11b10Float => {
                f.debug_tuple("Format::Rg11b10Float").finish()
              }
              Format::Rg32Uint => {
                f.debug_tuple("Format::Rg32Uint").finish()
              }
              Format::Rg32Sint => {
                f.debug_tuple("Format::Rg32Sint").finish()
              }
              Format::Rg32Float => {
                f.debug_tuple("Format::Rg32Float").finish()
              }
              Format::Rgba16Uint => {
                f.debug_tuple("Format::Rgba16Uint").finish()
              }
              Format::Rgba16Sint => {
                f.debug_tuple("Format::Rgba16Sint").finish()
              }
              Format::Rgba16Unorm => {
                f.debug_tuple("Format::Rgba16Unorm").finish()
              }
              Format::Rgba16Snorm => {
                f.debug_tuple("Format::Rgba16Snorm").finish()
              }
              Format::Rgba16Float => {
                f.debug_tuple("Format::Rgba16Float").finish()
              }
              Format::Rgba32Uint => {
                f.debug_tuple("Format::Rgba32Uint").finish()
              }
              Format::Rgba32Sint => {
                f.debug_tuple("Format::Rgba32Sint").finish()
              }
              Format::Rgba32Float => {
                f.debug_tuple("Format::Rgba32Float").finish()
              }
            }
          }
        }
        #[derive(Clone)]
        pub struct Descriptor2d {
          pub width: u32,
          pub height: u32,
          pub format: Format,
          pub data: wit_bindgen::rt::vec::Vec::<u8>,
        }
        impl ::core::fmt::Debug for Descriptor2d {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Descriptor2d").field("width", &self.width).field("height", &self.height).field("format", &self.format).field("data", &self.data).finish()
          }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct Handle {
          pub ulid: Ulid,
        }
        impl ::core::fmt::Debug for Handle {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Handle").field("ulid", &self.ulid).finish()
          }
        }
        #[allow(clippy::all)]
        pub fn create2d(desc: &Descriptor2d,) -> Handle{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let Descriptor2d{ width:width0, height:height0, format:format0, data:data0, } = desc;
            let result1 = match format0 {
              Format::R8Unorm=> {
                0i32
              }
              Format::R8Snorm=> {
                1i32
              }
              Format::R8Uint=> {
                2i32
              }
              Format::R8Sint=> {
                3i32
              }
              Format::R16Uint=> {
                4i32
              }
              Format::R16Sint=> {
                5i32
              }
              Format::R16Unorm=> {
                6i32
              }
              Format::R16Snorm=> {
                7i32
              }
              Format::R16Float=> {
                8i32
              }
              Format::Rg8Unorm=> {
                9i32
              }
              Format::Rg8Snorm=> {
                10i32
              }
              Format::Rg8Uint=> {
                11i32
              }
              Format::Rg8Sint=> {
                12i32
              }
              Format::R32Uint=> {
                13i32
              }
              Format::R32Sint=> {
                14i32
              }
              Format::R32Float=> {
                15i32
              }
              Format::Rg16Uint=> {
                16i32
              }
              Format::Rg16Sint=> {
                17i32
              }
              Format::Rg16Unorm=> {
                18i32
              }
              Format::Rg16Snorm=> {
                19i32
              }
              Format::Rg16Float=> {
                20i32
              }
              Format::Rgba8Unorm=> {
                21i32
              }
              Format::Rgba8UnormSrgb=> {
                22i32
              }
              Format::Rgba8Snorm=> {
                23i32
              }
              Format::Rgba8Uint=> {
                24i32
              }
              Format::Rgba8Sint=> {
                25i32
              }
              Format::Bgra8Unorm=> {
                26i32
              }
              Format::Bgra8UnormSrgb=> {
                27i32
              }
              Format::Rgb9e5Ufloat=> {
                28i32
              }
              Format::Rgb10a2Unorm=> {
                29i32
              }
              Format::Rg11b10Float=> {
                30i32
              }
              Format::Rg32Uint=> {
                31i32
              }
              Format::Rg32Sint=> {
                32i32
              }
              Format::Rg32Float=> {
                33i32
              }
              Format::Rgba16Uint=> {
                34i32
              }
              Format::Rgba16Sint=> {
                35i32
              }
              Format::Rgba16Unorm=> {
                36i32
              }
              Format::Rgba16Snorm=> {
                37i32
              }
              Format::Rgba16Float=> {
                38i32
              }
              Format::Rgba32Uint=> {
                39i32
              }
              Format::Rgba32Sint=> {
                40i32
              }
              Format::Rgba32Float=> {
                41i32
              }
            };
            let vec2 = data0;
            let ptr2 = vec2.as_ptr() as i32;
            let len2 = vec2.len() as i32;
            let ptr3 = ret_area.as_mut_ptr() as i32;
            #[link(wasm_import_module = "ambient:bindings/client-texture")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "create2d")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-texture_create2d")]
              fn wit_import(
              _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
            }
            wit_import(wit_bindgen::rt::as_i32(width0), wit_bindgen::rt::as_i32(height0), result1, ptr2, len2, ptr3);
            Handle{ulid:(*((ptr3 + 0) as *const i64) as u64, *((ptr3 + 8) as *const i64) as u64), }
          }
        }
        #[allow(clippy::all)]
        pub fn destroy(handle: Handle,){
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            let Handle{ ulid:ulid0, } = handle;
            let (t1_0, t1_1, ) = ulid0;
            
            #[link(wasm_import_module = "ambient:bindings/client-texture")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "destroy")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-texture_destroy")]
              fn wit_import(
              _: i64, _: i64, );
            }
            wit_import(wit_bindgen::rt::as_i64(t1_0), wit_bindgen::rt::as_i64(t1_1));
          }
        }
        
      }
      
      
      #[allow(clippy::all)]
      pub mod client_sampler {
        #[used]
        #[doc(hidden)]
        #[cfg(target_arch = "wasm32")]
        static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
        
        pub type Ulid = super::super::super::ambient::bindings::types::Ulid;
        #[derive(Clone, Copy)]
        pub enum AddressMode{
          ClampToEdge,
          Repeat,
          MirrorRepeat,
        }
        impl ::core::fmt::Debug for AddressMode {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              AddressMode::ClampToEdge => {
                f.debug_tuple("AddressMode::ClampToEdge").finish()
              }
              AddressMode::Repeat => {
                f.debug_tuple("AddressMode::Repeat").finish()
              }
              AddressMode::MirrorRepeat => {
                f.debug_tuple("AddressMode::MirrorRepeat").finish()
              }
            }
          }
        }
        #[derive(Clone, Copy)]
        pub enum FilterMode{
          Nearest,
          Linear,
        }
        impl ::core::fmt::Debug for FilterMode {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              FilterMode::Nearest => {
                f.debug_tuple("FilterMode::Nearest").finish()
              }
              FilterMode::Linear => {
                f.debug_tuple("FilterMode::Linear").finish()
              }
            }
          }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct Descriptor {
          pub address_mode_u: AddressMode,
          pub address_mode_v: AddressMode,
          pub address_mode_w: AddressMode,
          pub mag_filter: FilterMode,
          pub min_filter: FilterMode,
          pub mipmap_filter: FilterMode,
        }
        impl ::core::fmt::Debug for Descriptor {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Descriptor").field("address-mode-u", &self.address_mode_u).field("address-mode-v", &self.address_mode_v).field("address-mode-w", &self.address_mode_w).field("mag-filter", &self.mag_filter).field("min-filter", &self.min_filter).field("mipmap-filter", &self.mipmap_filter).finish()
          }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct Handle {
          pub ulid: Ulid,
        }
        impl ::core::fmt::Debug for Handle {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Handle").field("ulid", &self.ulid).finish()
          }
        }
        #[allow(clippy::all)]
        pub fn create(desc: Descriptor,) -> Handle{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let Descriptor{ address_mode_u:address_mode_u0, address_mode_v:address_mode_v0, address_mode_w:address_mode_w0, mag_filter:mag_filter0, min_filter:min_filter0, mipmap_filter:mipmap_filter0, } = desc;
            let result1 = match address_mode_u0 {
              AddressMode::ClampToEdge=> {
                0i32
              }
              AddressMode::Repeat=> {
                1i32
              }
              AddressMode::MirrorRepeat=> {
                2i32
              }
            };
            let result2 = match address_mode_v0 {
              AddressMode::ClampToEdge=> {
                0i32
              }
              AddressMode::Repeat=> {
                1i32
              }
              AddressMode::MirrorRepeat=> {
                2i32
              }
            };
            let result3 = match address_mode_w0 {
              AddressMode::ClampToEdge=> {
                0i32
              }
              AddressMode::Repeat=> {
                1i32
              }
              AddressMode::MirrorRepeat=> {
                2i32
              }
            };
            let result4 = match mag_filter0 {
              FilterMode::Nearest=> {
                0i32
              }
              FilterMode::Linear=> {
                1i32
              }
            };
            let result5 = match min_filter0 {
              FilterMode::Nearest=> {
                0i32
              }
              FilterMode::Linear=> {
                1i32
              }
            };
            let result6 = match mipmap_filter0 {
              FilterMode::Nearest=> {
                0i32
              }
              FilterMode::Linear=> {
                1i32
              }
            };
            let ptr7 = ret_area.as_mut_ptr() as i32;
            #[link(wasm_import_module = "ambient:bindings/client-sampler")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "create")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-sampler_create")]
              fn wit_import(
              _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
            }
            wit_import(result1, result2, result3, result4, result5, result6, ptr7);
            Handle{ulid:(*((ptr7 + 0) as *const i64) as u64, *((ptr7 + 8) as *const i64) as u64), }
          }
        }
        #[allow(clippy::all)]
        pub fn destroy(handle: Handle,){
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            let Handle{ ulid:ulid0, } = handle;
            let (t1_0, t1_1, ) = ulid0;
            
            #[link(wasm_import_module = "ambient:bindings/client-sampler")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "destroy")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-sampler_destroy")]
              fn wit_import(
              _: i64, _: i64, );
            }
            wit_import(wit_bindgen::rt::as_i64(t1_0), wit_bindgen::rt::as_i64(t1_1));
          }
        }
        
      }
      
      
      #[allow(clippy::all)]
      pub mod client_material {
        #[used]
        #[doc(hidden)]
        #[cfg(target_arch = "wasm32")]
        static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
        
        pub type Ulid = super::super::super::ambient::bindings::types::Ulid;
        pub type TextureHandle = super::super::super::ambient::bindings::client_texture::Handle;
        pub type SamplerHandle = super::super::super::ambient::bindings::client_sampler::Handle;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct Descriptor {
          pub base_color_map: TextureHandle,
          pub normal_map: TextureHandle,
          pub metallic_roughness_map: TextureHandle,
          pub sampler: SamplerHandle,
          pub transparent: bool,
        }
        impl ::core::fmt::Debug for Descriptor {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Descriptor").field("base-color-map", &self.base_color_map).field("normal-map", &self.normal_map).field("metallic-roughness-map", &self.metallic_roughness_map).field("sampler", &self.sampler).field("transparent", &self.transparent).finish()
          }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct Handle {
          pub ulid: Ulid,
        }
        impl ::core::fmt::Debug for Handle {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Handle").field("ulid", &self.ulid).finish()
          }
        }
        #[allow(clippy::all)]
        pub fn create(desc: Descriptor,) -> Handle{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let Descriptor{ base_color_map:base_color_map0, normal_map:normal_map0, metallic_roughness_map:metallic_roughness_map0, sampler:sampler0, transparent:transparent0, } = desc;
            let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid1, } = base_color_map0;
            let (t2_0, t2_1, ) = ulid1;
            let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid3, } = normal_map0;
            let (t4_0, t4_1, ) = ulid3;
            let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid5, } = metallic_roughness_map0;
            let (t6_0, t6_1, ) = ulid5;
            let super::super::super::ambient::bindings::client_sampler::Handle{ ulid:ulid7, } = sampler0;
            let (t8_0, t8_1, ) = ulid7;
            let ptr9 = ret_area.as_mut_ptr() as i32;
            #[link(wasm_import_module = "ambient:bindings/client-material")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "create")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-material_create")]
              fn wit_import(
              _: i64, _: i64, _: i64, _: i64, _: i64, _: i64, _: i64, _: i64, _: i32, _: i32, );
            }
            wit_import(wit_bindgen::rt::as_i64(t2_0), wit_bindgen::rt::as_i64(t2_1), wit_bindgen::rt::as_i64(t4_0), wit_bindgen::rt::as_i64(t4_1), wit_bindgen::rt::as_i64(t6_0), wit_bindgen::rt::as_i64(t6_1), wit_bindgen::rt::as_i64(t8_0), wit_bindgen::rt::as_i64(t8_1), match transparent0 { true => 1, false => 0 }, ptr9);
            Handle{ulid:(*((ptr9 + 0) as *const i64) as u64, *((ptr9 + 8) as *const i64) as u64), }
          }
        }
        #[allow(clippy::all)]
        pub fn destroy(handle: Handle,){
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            let Handle{ ulid:ulid0, } = handle;
            let (t1_0, t1_1, ) = ulid0;
            
            #[link(wasm_import_module = "ambient:bindings/client-material")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "destroy")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-material_destroy")]
              fn wit_import(
              _: i64, _: i64, );
            }
            wit_import(wit_bindgen::rt::as_i64(t1_0), wit_bindgen::rt::as_i64(t1_1));
          }
        }
        
      }
      
      
      #[allow(clippy::all)]
      pub mod component {
        #[used]
        #[doc(hidden)]
        #[cfg(target_arch = "wasm32")]
        static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
        
        pub type EntityId = super::super::super::ambient::bindings::types::EntityId;
        pub type Mat4 = super::super::super::ambient::bindings::types::Mat4;
        pub type Quat = super::super::super::ambient::bindings::types::Quat;
        pub type Vec2 = super::super::super::ambient::bindings::types::Vec2;
        pub type Vec3 = super::super::super::ambient::bindings::types::Vec3;
        pub type Vec4 = super::super::super::ambient::bindings::types::Vec4;
        pub type Uvec2 = super::super::super::ambient::bindings::types::Uvec2;
        pub type Uvec3 = super::super::super::ambient::bindings::types::Uvec3;
        pub type Uvec4 = super::super::super::ambient::bindings::types::Uvec4;
        pub type Ivec2 = super::super::super::ambient::bindings::types::Ivec2;
        pub type Ivec3 = super::super::super::ambient::bindings::types::Ivec3;
        pub type Ivec4 = super::super::super::ambient::bindings::types::Ivec4;
        pub type Duration = super::super::super::ambient::bindings::types::Duration;
        pub type Empty = super::super::super::ambient::bindings::types::Empty;
        pub type ProceduralMeshHandle = super::super::super::ambient::bindings::client_mesh::Handle;
        pub type ProceduralTextureHandle = super::super::super::ambient::bindings::client_texture::Handle;
        pub type ProceduralSamplerHandle = super::super::super::ambient::bindings::client_sampler::Handle;
        pub type ProceduralMaterialHandle = super::super::super::ambient::bindings::client_material::Handle;
        #[derive(Clone)]
        pub enum VecValue{
          TypeEmpty(wit_bindgen::rt::vec::Vec::<Empty>),
          TypeBool(wit_bindgen::rt::vec::Vec::<bool>),
          TypeEntityId(wit_bindgen::rt::vec::Vec::<EntityId>),
          TypeF32(wit_bindgen::rt::vec::Vec::<f32>),
          TypeF64(wit_bindgen::rt::vec::Vec::<f64>),
          TypeMat4(wit_bindgen::rt::vec::Vec::<Mat4>),
          TypeQuat(wit_bindgen::rt::vec::Vec::<Quat>),
          TypeString(wit_bindgen::rt::vec::Vec::<wit_bindgen::rt::string::String>),
          TypeU8(wit_bindgen::rt::vec::Vec::<u8>),
          TypeU16(wit_bindgen::rt::vec::Vec::<u16>),
          TypeU32(wit_bindgen::rt::vec::Vec::<u32>),
          TypeU64(wit_bindgen::rt::vec::Vec::<u64>),
          TypeI8(wit_bindgen::rt::vec::Vec::<i8>),
          TypeI16(wit_bindgen::rt::vec::Vec::<i16>),
          TypeI32(wit_bindgen::rt::vec::Vec::<i32>),
          TypeI64(wit_bindgen::rt::vec::Vec::<i64>),
          TypeVec2(wit_bindgen::rt::vec::Vec::<Vec2>),
          TypeVec3(wit_bindgen::rt::vec::Vec::<Vec3>),
          TypeVec4(wit_bindgen::rt::vec::Vec::<Vec4>),
          TypeUvec2(wit_bindgen::rt::vec::Vec::<Uvec2>),
          TypeUvec3(wit_bindgen::rt::vec::Vec::<Uvec3>),
          TypeUvec4(wit_bindgen::rt::vec::Vec::<Uvec4>),
          TypeIvec2(wit_bindgen::rt::vec::Vec::<Ivec2>),
          TypeIvec3(wit_bindgen::rt::vec::Vec::<Ivec3>),
          TypeIvec4(wit_bindgen::rt::vec::Vec::<Ivec4>),
          TypeDuration(wit_bindgen::rt::vec::Vec::<Duration>),
          TypeProceduralMeshHandle(wit_bindgen::rt::vec::Vec::<ProceduralMeshHandle>),
          TypeProceduralTextureHandle(wit_bindgen::rt::vec::Vec::<ProceduralTextureHandle>),
          TypeProceduralSamplerHandle(wit_bindgen::rt::vec::Vec::<ProceduralSamplerHandle>),
          TypeProceduralMaterialHandle(wit_bindgen::rt::vec::Vec::<ProceduralMaterialHandle>),
        }
        impl ::core::fmt::Debug for VecValue {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              VecValue::TypeEmpty(e) => {
                f.debug_tuple("VecValue::TypeEmpty").field(e).finish()
              }
              VecValue::TypeBool(e) => {
                f.debug_tuple("VecValue::TypeBool").field(e).finish()
              }
              VecValue::TypeEntityId(e) => {
                f.debug_tuple("VecValue::TypeEntityId").field(e).finish()
              }
              VecValue::TypeF32(e) => {
                f.debug_tuple("VecValue::TypeF32").field(e).finish()
              }
              VecValue::TypeF64(e) => {
                f.debug_tuple("VecValue::TypeF64").field(e).finish()
              }
              VecValue::TypeMat4(e) => {
                f.debug_tuple("VecValue::TypeMat4").field(e).finish()
              }
              VecValue::TypeQuat(e) => {
                f.debug_tuple("VecValue::TypeQuat").field(e).finish()
              }
              VecValue::TypeString(e) => {
                f.debug_tuple("VecValue::TypeString").field(e).finish()
              }
              VecValue::TypeU8(e) => {
                f.debug_tuple("VecValue::TypeU8").field(e).finish()
              }
              VecValue::TypeU16(e) => {
                f.debug_tuple("VecValue::TypeU16").field(e).finish()
              }
              VecValue::TypeU32(e) => {
                f.debug_tuple("VecValue::TypeU32").field(e).finish()
              }
              VecValue::TypeU64(e) => {
                f.debug_tuple("VecValue::TypeU64").field(e).finish()
              }
              VecValue::TypeI8(e) => {
                f.debug_tuple("VecValue::TypeI8").field(e).finish()
              }
              VecValue::TypeI16(e) => {
                f.debug_tuple("VecValue::TypeI16").field(e).finish()
              }
              VecValue::TypeI32(e) => {
                f.debug_tuple("VecValue::TypeI32").field(e).finish()
              }
              VecValue::TypeI64(e) => {
                f.debug_tuple("VecValue::TypeI64").field(e).finish()
              }
              VecValue::TypeVec2(e) => {
                f.debug_tuple("VecValue::TypeVec2").field(e).finish()
              }
              VecValue::TypeVec3(e) => {
                f.debug_tuple("VecValue::TypeVec3").field(e).finish()
              }
              VecValue::TypeVec4(e) => {
                f.debug_tuple("VecValue::TypeVec4").field(e).finish()
              }
              VecValue::TypeUvec2(e) => {
                f.debug_tuple("VecValue::TypeUvec2").field(e).finish()
              }
              VecValue::TypeUvec3(e) => {
                f.debug_tuple("VecValue::TypeUvec3").field(e).finish()
              }
              VecValue::TypeUvec4(e) => {
                f.debug_tuple("VecValue::TypeUvec4").field(e).finish()
              }
              VecValue::TypeIvec2(e) => {
                f.debug_tuple("VecValue::TypeIvec2").field(e).finish()
              }
              VecValue::TypeIvec3(e) => {
                f.debug_tuple("VecValue::TypeIvec3").field(e).finish()
              }
              VecValue::TypeIvec4(e) => {
                f.debug_tuple("VecValue::TypeIvec4").field(e).finish()
              }
              VecValue::TypeDuration(e) => {
                f.debug_tuple("VecValue::TypeDuration").field(e).finish()
              }
              VecValue::TypeProceduralMeshHandle(e) => {
                f.debug_tuple("VecValue::TypeProceduralMeshHandle").field(e).finish()
              }
              VecValue::TypeProceduralTextureHandle(e) => {
                f.debug_tuple("VecValue::TypeProceduralTextureHandle").field(e).finish()
              }
              VecValue::TypeProceduralSamplerHandle(e) => {
                f.debug_tuple("VecValue::TypeProceduralSamplerHandle").field(e).finish()
              }
              VecValue::TypeProceduralMaterialHandle(e) => {
                f.debug_tuple("VecValue::TypeProceduralMaterialHandle").field(e).finish()
              }
            }
          }
        }
        #[derive(Clone)]
        pub enum OptionValue{
          TypeEmpty(Option<Empty>),
          TypeBool(Option<bool>),
          TypeEntityId(Option<EntityId>),
          TypeF32(Option<f32>),
          TypeF64(Option<f64>),
          TypeMat4(Option<Mat4>),
          TypeQuat(Option<Quat>),
          TypeString(Option<wit_bindgen::rt::string::String>),
          TypeU8(Option<u8>),
          TypeU16(Option<u16>),
          TypeU32(Option<u32>),
          TypeU64(Option<u64>),
          TypeI8(Option<i8>),
          TypeI16(Option<i16>),
          TypeI32(Option<i32>),
          TypeI64(Option<i64>),
          TypeVec2(Option<Vec2>),
          TypeVec3(Option<Vec3>),
          TypeVec4(Option<Vec4>),
          TypeUvec2(Option<Uvec2>),
          TypeUvec3(Option<Uvec3>),
          TypeUvec4(Option<Uvec4>),
          TypeIvec2(Option<Ivec2>),
          TypeIvec3(Option<Ivec3>),
          TypeIvec4(Option<Ivec4>),
          TypeDuration(Option<Duration>),
          TypeProceduralMeshHandle(Option<ProceduralMeshHandle>),
          TypeProceduralTextureHandle(Option<ProceduralTextureHandle>),
          TypeProceduralSamplerHandle(Option<ProceduralSamplerHandle>),
          TypeProceduralMaterialHandle(Option<ProceduralMaterialHandle>),
        }
        impl ::core::fmt::Debug for OptionValue {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              OptionValue::TypeEmpty(e) => {
                f.debug_tuple("OptionValue::TypeEmpty").field(e).finish()
              }
              OptionValue::TypeBool(e) => {
                f.debug_tuple("OptionValue::TypeBool").field(e).finish()
              }
              OptionValue::TypeEntityId(e) => {
                f.debug_tuple("OptionValue::TypeEntityId").field(e).finish()
              }
              OptionValue::TypeF32(e) => {
                f.debug_tuple("OptionValue::TypeF32").field(e).finish()
              }
              OptionValue::TypeF64(e) => {
                f.debug_tuple("OptionValue::TypeF64").field(e).finish()
              }
              OptionValue::TypeMat4(e) => {
                f.debug_tuple("OptionValue::TypeMat4").field(e).finish()
              }
              OptionValue::TypeQuat(e) => {
                f.debug_tuple("OptionValue::TypeQuat").field(e).finish()
              }
              OptionValue::TypeString(e) => {
                f.debug_tuple("OptionValue::TypeString").field(e).finish()
              }
              OptionValue::TypeU8(e) => {
                f.debug_tuple("OptionValue::TypeU8").field(e).finish()
              }
              OptionValue::TypeU16(e) => {
                f.debug_tuple("OptionValue::TypeU16").field(e).finish()
              }
              OptionValue::TypeU32(e) => {
                f.debug_tuple("OptionValue::TypeU32").field(e).finish()
              }
              OptionValue::TypeU64(e) => {
                f.debug_tuple("OptionValue::TypeU64").field(e).finish()
              }
              OptionValue::TypeI8(e) => {
                f.debug_tuple("OptionValue::TypeI8").field(e).finish()
              }
              OptionValue::TypeI16(e) => {
                f.debug_tuple("OptionValue::TypeI16").field(e).finish()
              }
              OptionValue::TypeI32(e) => {
                f.debug_tuple("OptionValue::TypeI32").field(e).finish()
              }
              OptionValue::TypeI64(e) => {
                f.debug_tuple("OptionValue::TypeI64").field(e).finish()
              }
              OptionValue::TypeVec2(e) => {
                f.debug_tuple("OptionValue::TypeVec2").field(e).finish()
              }
              OptionValue::TypeVec3(e) => {
                f.debug_tuple("OptionValue::TypeVec3").field(e).finish()
              }
              OptionValue::TypeVec4(e) => {
                f.debug_tuple("OptionValue::TypeVec4").field(e).finish()
              }
              OptionValue::TypeUvec2(e) => {
                f.debug_tuple("OptionValue::TypeUvec2").field(e).finish()
              }
              OptionValue::TypeUvec3(e) => {
                f.debug_tuple("OptionValue::TypeUvec3").field(e).finish()
              }
              OptionValue::TypeUvec4(e) => {
                f.debug_tuple("OptionValue::TypeUvec4").field(e).finish()
              }
              OptionValue::TypeIvec2(e) => {
                f.debug_tuple("OptionValue::TypeIvec2").field(e).finish()
              }
              OptionValue::TypeIvec3(e) => {
                f.debug_tuple("OptionValue::TypeIvec3").field(e).finish()
              }
              OptionValue::TypeIvec4(e) => {
                f.debug_tuple("OptionValue::TypeIvec4").field(e).finish()
              }
              OptionValue::TypeDuration(e) => {
                f.debug_tuple("OptionValue::TypeDuration").field(e).finish()
              }
              OptionValue::TypeProceduralMeshHandle(e) => {
                f.debug_tuple("OptionValue::TypeProceduralMeshHandle").field(e).finish()
              }
              OptionValue::TypeProceduralTextureHandle(e) => {
                f.debug_tuple("OptionValue::TypeProceduralTextureHandle").field(e).finish()
              }
              OptionValue::TypeProceduralSamplerHandle(e) => {
                f.debug_tuple("OptionValue::TypeProceduralSamplerHandle").field(e).finish()
              }
              OptionValue::TypeProceduralMaterialHandle(e) => {
                f.debug_tuple("OptionValue::TypeProceduralMaterialHandle").field(e).finish()
              }
            }
          }
        }
        #[derive(Clone)]
        pub enum Value{
          TypeEmpty(Empty),
          TypeBool(bool),
          TypeEntityId(EntityId),
          TypeF32(f32),
          TypeF64(f64),
          TypeMat4(Mat4),
          TypeQuat(Quat),
          TypeString(wit_bindgen::rt::string::String),
          TypeU8(u8),
          TypeU16(u16),
          TypeU32(u32),
          TypeU64(u64),
          TypeI8(i8),
          TypeI16(i16),
          TypeI32(i32),
          TypeI64(i64),
          TypeVec2(Vec2),
          TypeVec3(Vec3),
          TypeVec4(Vec4),
          TypeUvec2(Uvec2),
          TypeUvec3(Uvec3),
          TypeUvec4(Uvec4),
          TypeIvec2(Ivec2),
          TypeIvec3(Ivec3),
          TypeIvec4(Ivec4),
          TypeDuration(Duration),
          TypeProceduralMeshHandle(ProceduralMeshHandle),
          TypeProceduralTextureHandle(ProceduralTextureHandle),
          TypeProceduralSamplerHandle(ProceduralSamplerHandle),
          TypeProceduralMaterialHandle(ProceduralMaterialHandle),
          TypeVec(VecValue),
          TypeOption(OptionValue),
        }
        impl ::core::fmt::Debug for Value {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              Value::TypeEmpty(e) => {
                f.debug_tuple("Value::TypeEmpty").field(e).finish()
              }
              Value::TypeBool(e) => {
                f.debug_tuple("Value::TypeBool").field(e).finish()
              }
              Value::TypeEntityId(e) => {
                f.debug_tuple("Value::TypeEntityId").field(e).finish()
              }
              Value::TypeF32(e) => {
                f.debug_tuple("Value::TypeF32").field(e).finish()
              }
              Value::TypeF64(e) => {
                f.debug_tuple("Value::TypeF64").field(e).finish()
              }
              Value::TypeMat4(e) => {
                f.debug_tuple("Value::TypeMat4").field(e).finish()
              }
              Value::TypeQuat(e) => {
                f.debug_tuple("Value::TypeQuat").field(e).finish()
              }
              Value::TypeString(e) => {
                f.debug_tuple("Value::TypeString").field(e).finish()
              }
              Value::TypeU8(e) => {
                f.debug_tuple("Value::TypeU8").field(e).finish()
              }
              Value::TypeU16(e) => {
                f.debug_tuple("Value::TypeU16").field(e).finish()
              }
              Value::TypeU32(e) => {
                f.debug_tuple("Value::TypeU32").field(e).finish()
              }
              Value::TypeU64(e) => {
                f.debug_tuple("Value::TypeU64").field(e).finish()
              }
              Value::TypeI8(e) => {
                f.debug_tuple("Value::TypeI8").field(e).finish()
              }
              Value::TypeI16(e) => {
                f.debug_tuple("Value::TypeI16").field(e).finish()
              }
              Value::TypeI32(e) => {
                f.debug_tuple("Value::TypeI32").field(e).finish()
              }
              Value::TypeI64(e) => {
                f.debug_tuple("Value::TypeI64").field(e).finish()
              }
              Value::TypeVec2(e) => {
                f.debug_tuple("Value::TypeVec2").field(e).finish()
              }
              Value::TypeVec3(e) => {
                f.debug_tuple("Value::TypeVec3").field(e).finish()
              }
              Value::TypeVec4(e) => {
                f.debug_tuple("Value::TypeVec4").field(e).finish()
              }
              Value::TypeUvec2(e) => {
                f.debug_tuple("Value::TypeUvec2").field(e).finish()
              }
              Value::TypeUvec3(e) => {
                f.debug_tuple("Value::TypeUvec3").field(e).finish()
              }
              Value::TypeUvec4(e) => {
                f.debug_tuple("Value::TypeUvec4").field(e).finish()
              }
              Value::TypeIvec2(e) => {
                f.debug_tuple("Value::TypeIvec2").field(e).finish()
              }
              Value::TypeIvec3(e) => {
                f.debug_tuple("Value::TypeIvec3").field(e).finish()
              }
              Value::TypeIvec4(e) => {
                f.debug_tuple("Value::TypeIvec4").field(e).finish()
              }
              Value::TypeDuration(e) => {
                f.debug_tuple("Value::TypeDuration").field(e).finish()
              }
              Value::TypeProceduralMeshHandle(e) => {
                f.debug_tuple("Value::TypeProceduralMeshHandle").field(e).finish()
              }
              Value::TypeProceduralTextureHandle(e) => {
                f.debug_tuple("Value::TypeProceduralTextureHandle").field(e).finish()
              }
              Value::TypeProceduralSamplerHandle(e) => {
                f.debug_tuple("Value::TypeProceduralSamplerHandle").field(e).finish()
              }
              Value::TypeProceduralMaterialHandle(e) => {
                f.debug_tuple("Value::TypeProceduralMaterialHandle").field(e).finish()
              }
              Value::TypeVec(e) => {
                f.debug_tuple("Value::TypeVec").field(e).finish()
              }
              Value::TypeOption(e) => {
                f.debug_tuple("Value::TypeOption").field(e).finish()
              }
            }
          }
        }
        pub type Entity = wit_bindgen::rt::vec::Vec::<(u32,Value,)>;
        #[derive(Clone)]
        pub struct QueryBuild {
          pub components: wit_bindgen::rt::vec::Vec::<u32>,
          pub includes: wit_bindgen::rt::vec::Vec::<u32>,
          pub excludes: wit_bindgen::rt::vec::Vec::<u32>,
          pub changed: wit_bindgen::rt::vec::Vec::<u32>,
        }
        impl ::core::fmt::Debug for QueryBuild {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("QueryBuild").field("components", &self.components).field("includes", &self.includes).field("excludes", &self.excludes).field("changed", &self.changed).finish()
          }
        }
        #[repr(u8)]
        #[derive(Clone, Copy, PartialEq, Eq)]
        pub enum QueryEvent {
          Frame,
          Spawn,
          Despawn,
        }
        impl ::core::fmt::Debug for QueryEvent {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              QueryEvent::Frame => {
                f.debug_tuple("QueryEvent::Frame").finish()
              }
              QueryEvent::Spawn => {
                f.debug_tuple("QueryEvent::Spawn").finish()
              }
              QueryEvent::Despawn => {
                f.debug_tuple("QueryEvent::Despawn").finish()
              }
            }
          }
        }
        #[allow(clippy::all)]
        pub fn get_index(id: &str,) -> Option<u32>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 8]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let vec0 = id;
            let ptr0 = vec0.as_ptr() as i32;
            let len0 = vec0.len() as i32;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[link(wasm_import_module = "ambient:bindings/component")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "get-index")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_get-index")]
              fn wit_import(
              _: i32, _: i32, _: i32, );
            }
            wit_import(ptr0, len0, ptr1);
            match i32::from(*((ptr1 + 0) as *const u8)) {
              0 => None,
              1 => Some(*((ptr1 + 4) as *const i32) as u32),
              #[cfg(not(debug_assertions))]
              _ => ::core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }
          }
        }
        #[allow(clippy::all)]
        pub fn get_id(index: u32,) -> Option<wit_bindgen::rt::string::String>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 12]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[link(wasm_import_module = "ambient:bindings/component")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "get-id")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_get-id")]
              fn wit_import(
              _: i32, _: i32, );
            }
            wit_import(wit_bindgen::rt::as_i32(index), ptr0);
            match i32::from(*((ptr0 + 0) as *const u8)) {
              0 => None,
              1 => Some({
                let len1 = *((ptr0 + 8) as *const i32) as usize;
                
                {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr0 + 4) as *const i32) as *mut _, len1, len1))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr0 + 4) as *const i32) as *mut _, len1, len1)).unwrap()}}
              }),
              #[cfg(not(debug_assertions))]
              _ => ::core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }
          }
        }
        #[allow(clippy::all)]
        pub fn get_component(entity: EntityId,index: u32,) -> Option<Value>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 96]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[link(wasm_import_module = "ambient:bindings/component")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "get-component")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_get-component")]
              fn wit_import(
              _: i64, _: i64, _: i32, _: i32, );
            }
            wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_i32(index), ptr1);
            match i32::from(*((ptr1 + 0) as *const u8)) {
              0 => None,
              1 => Some({{match i32::from(*((ptr1 + 8) as *const u8)) {
                0 => Value::TypeEmpty(super::super::super::ambient::bindings::types::Empty{dummy:i32::from(*((ptr1 + 16) as *const u8)) as u8, }),
                1 => Value::TypeBool({
                  #[cfg(not(debug_assertions))]
                  { ::core::mem::transmute::<u8, bool>(i32::from(*((ptr1 + 16) as *const u8)) as u8) }
                  #[cfg(debug_assertions)]
                  {
                    match i32::from(*((ptr1 + 16) as *const u8)) {
                      0 => false,
                      1 => true,
                      _ => panic!("invalid bool discriminant"),
                    }
                  }
                }),
                2 => Value::TypeEntityId(super::super::super::ambient::bindings::types::EntityId{id0:*((ptr1 + 16) as *const i64) as u64, id1:*((ptr1 + 24) as *const i64) as u64, }),
                3 => Value::TypeF32(*((ptr1 + 16) as *const f32)),
                4 => Value::TypeF64(*((ptr1 + 16) as *const f64)),
                5 => Value::TypeMat4(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), z:*((ptr1 + 24) as *const f32), w:*((ptr1 + 28) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 32) as *const f32), y:*((ptr1 + 36) as *const f32), z:*((ptr1 + 40) as *const f32), w:*((ptr1 + 44) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 48) as *const f32), y:*((ptr1 + 52) as *const f32), z:*((ptr1 + 56) as *const f32), w:*((ptr1 + 60) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 64) as *const f32), y:*((ptr1 + 68) as *const f32), z:*((ptr1 + 72) as *const f32), w:*((ptr1 + 76) as *const f32), }, }),
                6 => Value::TypeQuat(super::super::super::ambient::bindings::types::Quat{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), z:*((ptr1 + 24) as *const f32), w:*((ptr1 + 28) as *const f32), }),
                7 => Value::TypeString({
                  let len2 = *((ptr1 + 20) as *const i32) as usize;
                  
                  {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 16) as *const i32) as *mut _, len2, len2))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 16) as *const i32) as *mut _, len2, len2)).unwrap()}}
                }),
                8 => Value::TypeU8(i32::from(*((ptr1 + 16) as *const u8)) as u8),
                9 => Value::TypeU16(i32::from(*((ptr1 + 16) as *const u16)) as u16),
                10 => Value::TypeU32(*((ptr1 + 16) as *const i32) as u32),
                11 => Value::TypeU64(*((ptr1 + 16) as *const i64) as u64),
                12 => Value::TypeI8(i32::from(*((ptr1 + 16) as *const i8)) as i8),
                13 => Value::TypeI16(i32::from(*((ptr1 + 16) as *const i16)) as i16),
                14 => Value::TypeI32(*((ptr1 + 16) as *const i32)),
                15 => Value::TypeI64(*((ptr1 + 16) as *const i64)),
                16 => Value::TypeVec2(super::super::super::ambient::bindings::types::Vec2{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), }),
                17 => Value::TypeVec3(super::super::super::ambient::bindings::types::Vec3{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), z:*((ptr1 + 24) as *const f32), }),
                18 => Value::TypeVec4(super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), z:*((ptr1 + 24) as *const f32), w:*((ptr1 + 28) as *const f32), }),
                19 => Value::TypeUvec2(super::super::super::ambient::bindings::types::Uvec2{x:*((ptr1 + 16) as *const i32) as u32, y:*((ptr1 + 20) as *const i32) as u32, }),
                20 => Value::TypeUvec3(super::super::super::ambient::bindings::types::Uvec3{x:*((ptr1 + 16) as *const i32) as u32, y:*((ptr1 + 20) as *const i32) as u32, z:*((ptr1 + 24) as *const i32) as u32, }),
                21 => Value::TypeUvec4(super::super::super::ambient::bindings::types::Uvec4{x:*((ptr1 + 16) as *const i32) as u32, y:*((ptr1 + 20) as *const i32) as u32, z:*((ptr1 + 24) as *const i32) as u32, w:*((ptr1 + 28) as *const i32) as u32, }),
                22 => Value::TypeIvec2(super::super::super::ambient::bindings::types::Ivec2{x:*((ptr1 + 16) as *const i32), y:*((ptr1 + 20) as *const i32), }),
                23 => Value::TypeIvec3(super::super::super::ambient::bindings::types::Ivec3{x:*((ptr1 + 16) as *const i32), y:*((ptr1 + 20) as *const i32), z:*((ptr1 + 24) as *const i32), }),
                24 => Value::TypeIvec4(super::super::super::ambient::bindings::types::Ivec4{x:*((ptr1 + 16) as *const i32), y:*((ptr1 + 20) as *const i32), z:*((ptr1 + 24) as *const i32), w:*((ptr1 + 28) as *const i32), }),
                25 => Value::TypeDuration(super::super::super::ambient::bindings::types::Duration{seconds:*((ptr1 + 16) as *const i64) as u64, nanoseconds:*((ptr1 + 24) as *const i32) as u32, }),
                26 => Value::TypeProceduralMeshHandle(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((ptr1 + 16) as *const i64) as u64, *((ptr1 + 24) as *const i64) as u64), }),
                27 => Value::TypeProceduralTextureHandle(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((ptr1 + 16) as *const i64) as u64, *((ptr1 + 24) as *const i64) as u64), }),
                28 => Value::TypeProceduralSamplerHandle(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((ptr1 + 16) as *const i64) as u64, *((ptr1 + 24) as *const i64) as u64), }),
                29 => Value::TypeProceduralMaterialHandle(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((ptr1 + 16) as *const i64) as u64, *((ptr1 + 24) as *const i64) as u64), }),
                30 => Value::TypeVec({{match i32::from(*((ptr1 + 16) as *const u8)) {
                  0 => VecValue::TypeEmpty({
                    let len3 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len3, len3)
                  }),
                  1 => VecValue::TypeBool({
                    let base4 = *((ptr1 + 20) as *const i32);
                    let len4 = *((ptr1 + 24) as *const i32);
                    let mut result4 = Vec::with_capacity(len4 as usize);
                    for i in 0..len4 {
                      let base = base4 + i *1;
                      result4.push({
                        #[cfg(not(debug_assertions))]
                        { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 0) as *const u8)) as u8) }
                        #[cfg(debug_assertions)]
                        {
                          match i32::from(*((base + 0) as *const u8)) {
                            0 => false,
                            1 => true,
                            _ => panic!("invalid bool discriminant"),
                          }
                        }
                      });
                    }
                    wit_bindgen::rt::dealloc(base4, (len4 as usize) * 1, 1);
                    
                    result4
                  }),
                  2 => VecValue::TypeEntityId({
                    let len5 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len5, len5)
                  }),
                  3 => VecValue::TypeF32({
                    let len6 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len6, len6)
                  }),
                  4 => VecValue::TypeF64({
                    let len7 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len7, len7)
                  }),
                  5 => VecValue::TypeMat4({
                    let len8 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len8, len8)
                  }),
                  6 => VecValue::TypeQuat({
                    let len9 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len9, len9)
                  }),
                  7 => VecValue::TypeString({
                    let base11 = *((ptr1 + 20) as *const i32);
                    let len11 = *((ptr1 + 24) as *const i32);
                    let mut result11 = Vec::with_capacity(len11 as usize);
                    for i in 0..len11 {
                      let base = base11 + i *8;
                      result11.push({
                        let len10 = *((base + 4) as *const i32) as usize;
                        
                        {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len10, len10))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len10, len10)).unwrap()}}
                      });
                    }
                    wit_bindgen::rt::dealloc(base11, (len11 as usize) * 8, 4);
                    
                    result11
                  }),
                  8 => VecValue::TypeU8({
                    let len12 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len12, len12)
                  }),
                  9 => VecValue::TypeU16({
                    let len13 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len13, len13)
                  }),
                  10 => VecValue::TypeU32({
                    let len14 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len14, len14)
                  }),
                  11 => VecValue::TypeU64({
                    let len15 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len15, len15)
                  }),
                  12 => VecValue::TypeI8({
                    let len16 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len16, len16)
                  }),
                  13 => VecValue::TypeI16({
                    let len17 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len17, len17)
                  }),
                  14 => VecValue::TypeI32({
                    let len18 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len18, len18)
                  }),
                  15 => VecValue::TypeI64({
                    let len19 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len19, len19)
                  }),
                  16 => VecValue::TypeVec2({
                    let len20 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len20, len20)
                  }),
                  17 => VecValue::TypeVec3({
                    let len21 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len21, len21)
                  }),
                  18 => VecValue::TypeVec4({
                    let len22 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len22, len22)
                  }),
                  19 => VecValue::TypeUvec2({
                    let len23 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len23, len23)
                  }),
                  20 => VecValue::TypeUvec3({
                    let len24 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len24, len24)
                  }),
                  21 => VecValue::TypeUvec4({
                    let len25 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len25, len25)
                  }),
                  22 => VecValue::TypeIvec2({
                    let len26 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len26, len26)
                  }),
                  23 => VecValue::TypeIvec3({
                    let len27 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len27, len27)
                  }),
                  24 => VecValue::TypeIvec4({
                    let len28 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len28, len28)
                  }),
                  25 => VecValue::TypeDuration({
                    let len29 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len29, len29)
                  }),
                  26 => VecValue::TypeProceduralMeshHandle({
                    let len30 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len30, len30)
                  }),
                  27 => VecValue::TypeProceduralTextureHandle({
                    let len31 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len31, len31)
                  }),
                  28 => VecValue::TypeProceduralSamplerHandle({
                    let len32 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len32, len32)
                  }),
                  #[cfg(debug_assertions)]29 => VecValue::TypeProceduralMaterialHandle({
                    let len33 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len33, len33)
                  }),
                  #[cfg(not(debug_assertions))]_ => VecValue::TypeProceduralMaterialHandle({
                    let len33 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len33, len33)
                  }),
                  #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                }}}),
                #[cfg(debug_assertions)]31 => Value::TypeOption({{match i32::from(*((ptr1 + 16) as *const u8)) {
                  0 => OptionValue::TypeEmpty(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Empty{dummy:i32::from(*((ptr1 + 25) as *const u8)) as u8, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  1 => OptionValue::TypeBool(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      #[cfg(not(debug_assertions))]
                      { ::core::mem::transmute::<u8, bool>(i32::from(*((ptr1 + 25) as *const u8)) as u8) }
                      #[cfg(debug_assertions)]
                      {
                        match i32::from(*((ptr1 + 25) as *const u8)) {
                          0 => false,
                          1 => true,
                          _ => panic!("invalid bool discriminant"),
                        }
                      }
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  2 => OptionValue::TypeEntityId(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::EntityId{id0:*((ptr1 + 32) as *const i64) as u64, id1:*((ptr1 + 40) as *const i64) as u64, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  3 => OptionValue::TypeF32(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 28) as *const f32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  4 => OptionValue::TypeF64(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 32) as *const f64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  5 => OptionValue::TypeMat4(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 44) as *const f32), y:*((ptr1 + 48) as *const f32), z:*((ptr1 + 52) as *const f32), w:*((ptr1 + 56) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 60) as *const f32), y:*((ptr1 + 64) as *const f32), z:*((ptr1 + 68) as *const f32), w:*((ptr1 + 72) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 76) as *const f32), y:*((ptr1 + 80) as *const f32), z:*((ptr1 + 84) as *const f32), w:*((ptr1 + 88) as *const f32), }, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  6 => OptionValue::TypeQuat(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Quat{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  7 => OptionValue::TypeString(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      let len34 = *((ptr1 + 32) as *const i32) as usize;
                      
                      {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 28) as *const i32) as *mut _, len34, len34))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 28) as *const i32) as *mut _, len34, len34)).unwrap()}}
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  8 => OptionValue::TypeU8(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((ptr1 + 25) as *const u8)) as u8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  9 => OptionValue::TypeU16(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((ptr1 + 26) as *const u16)) as u16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  10 => OptionValue::TypeU32(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 28) as *const i32) as u32),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  11 => OptionValue::TypeU64(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 32) as *const i64) as u64),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  12 => OptionValue::TypeI8(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((ptr1 + 25) as *const i8)) as i8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  13 => OptionValue::TypeI16(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((ptr1 + 26) as *const i16)) as i16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  14 => OptionValue::TypeI32(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 28) as *const i32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  15 => OptionValue::TypeI64(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 32) as *const i64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  16 => OptionValue::TypeVec2(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec2{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  17 => OptionValue::TypeVec3(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec3{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  18 => OptionValue::TypeVec4(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  19 => OptionValue::TypeUvec2(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec2{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  20 => OptionValue::TypeUvec3(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec3{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, z:*((ptr1 + 36) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  21 => OptionValue::TypeUvec4(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec4{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, z:*((ptr1 + 36) as *const i32) as u32, w:*((ptr1 + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  22 => OptionValue::TypeIvec2(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec2{x:*((ptr1 + 28) as *const i32), y:*((ptr1 + 32) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  23 => OptionValue::TypeIvec3(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec3{x:*((ptr1 + 28) as *const i32), y:*((ptr1 + 32) as *const i32), z:*((ptr1 + 36) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  24 => OptionValue::TypeIvec4(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec4{x:*((ptr1 + 28) as *const i32), y:*((ptr1 + 32) as *const i32), z:*((ptr1 + 36) as *const i32), w:*((ptr1 + 40) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  25 => OptionValue::TypeDuration(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Duration{seconds:*((ptr1 + 32) as *const i64) as u64, nanoseconds:*((ptr1 + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  26 => OptionValue::TypeProceduralMeshHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  27 => OptionValue::TypeProceduralTextureHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  28 => OptionValue::TypeProceduralSamplerHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]29 => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(not(debug_assertions))]_ => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                }}}),
                #[cfg(not(debug_assertions))]_ => Value::TypeOption({{match i32::from(*((ptr1 + 16) as *const u8)) {
                  0 => OptionValue::TypeEmpty(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Empty{dummy:i32::from(*((ptr1 + 25) as *const u8)) as u8, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  1 => OptionValue::TypeBool(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      #[cfg(not(debug_assertions))]
                      { ::core::mem::transmute::<u8, bool>(i32::from(*((ptr1 + 25) as *const u8)) as u8) }
                      #[cfg(debug_assertions)]
                      {
                        match i32::from(*((ptr1 + 25) as *const u8)) {
                          0 => false,
                          1 => true,
                          _ => panic!("invalid bool discriminant"),
                        }
                      }
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  2 => OptionValue::TypeEntityId(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::EntityId{id0:*((ptr1 + 32) as *const i64) as u64, id1:*((ptr1 + 40) as *const i64) as u64, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  3 => OptionValue::TypeF32(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 28) as *const f32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  4 => OptionValue::TypeF64(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 32) as *const f64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  5 => OptionValue::TypeMat4(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 44) as *const f32), y:*((ptr1 + 48) as *const f32), z:*((ptr1 + 52) as *const f32), w:*((ptr1 + 56) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 60) as *const f32), y:*((ptr1 + 64) as *const f32), z:*((ptr1 + 68) as *const f32), w:*((ptr1 + 72) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 76) as *const f32), y:*((ptr1 + 80) as *const f32), z:*((ptr1 + 84) as *const f32), w:*((ptr1 + 88) as *const f32), }, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  6 => OptionValue::TypeQuat(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Quat{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  7 => OptionValue::TypeString(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      let len34 = *((ptr1 + 32) as *const i32) as usize;
                      
                      {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 28) as *const i32) as *mut _, len34, len34))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 28) as *const i32) as *mut _, len34, len34)).unwrap()}}
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  8 => OptionValue::TypeU8(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((ptr1 + 25) as *const u8)) as u8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  9 => OptionValue::TypeU16(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((ptr1 + 26) as *const u16)) as u16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  10 => OptionValue::TypeU32(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 28) as *const i32) as u32),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  11 => OptionValue::TypeU64(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 32) as *const i64) as u64),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  12 => OptionValue::TypeI8(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((ptr1 + 25) as *const i8)) as i8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  13 => OptionValue::TypeI16(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((ptr1 + 26) as *const i16)) as i16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  14 => OptionValue::TypeI32(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 28) as *const i32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  15 => OptionValue::TypeI64(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 32) as *const i64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  16 => OptionValue::TypeVec2(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec2{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  17 => OptionValue::TypeVec3(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec3{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  18 => OptionValue::TypeVec4(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  19 => OptionValue::TypeUvec2(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec2{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  20 => OptionValue::TypeUvec3(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec3{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, z:*((ptr1 + 36) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  21 => OptionValue::TypeUvec4(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec4{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, z:*((ptr1 + 36) as *const i32) as u32, w:*((ptr1 + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  22 => OptionValue::TypeIvec2(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec2{x:*((ptr1 + 28) as *const i32), y:*((ptr1 + 32) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  23 => OptionValue::TypeIvec3(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec3{x:*((ptr1 + 28) as *const i32), y:*((ptr1 + 32) as *const i32), z:*((ptr1 + 36) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  24 => OptionValue::TypeIvec4(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec4{x:*((ptr1 + 28) as *const i32), y:*((ptr1 + 32) as *const i32), z:*((ptr1 + 36) as *const i32), w:*((ptr1 + 40) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  25 => OptionValue::TypeDuration(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Duration{seconds:*((ptr1 + 32) as *const i64) as u64, nanoseconds:*((ptr1 + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  26 => OptionValue::TypeProceduralMeshHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  27 => OptionValue::TypeProceduralTextureHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  28 => OptionValue::TypeProceduralSamplerHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]29 => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(not(debug_assertions))]_ => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                }}}),
                #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
              }}}),
              #[cfg(not(debug_assertions))]
              _ => ::core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }
          }
        }
        #[allow(clippy::all)]
        pub fn get_components(entity: EntityId,indices: &[u32],) -> Entity{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 8]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
            let vec1 = indices;
            let ptr1 = vec1.as_ptr() as i32;
            let len1 = vec1.len() as i32;
            let ptr2 = ret_area.as_mut_ptr() as i32;
            #[link(wasm_import_module = "ambient:bindings/component")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "get-components")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_get-components")]
              fn wit_import(
              _: i64, _: i64, _: i32, _: i32, _: i32, );
            }
            wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), ptr1, len1, ptr2);
            let base36 = *((ptr2 + 0) as *const i32);
            let len36 = *((ptr2 + 4) as *const i32);
            let mut result36 = Vec::with_capacity(len36 as usize);
            for i in 0..len36 {
              let base = base36 + i *96;
              result36.push((*((base + 0) as *const i32) as u32, {{match i32::from(*((base + 8) as *const u8)) {
                0 => Value::TypeEmpty(super::super::super::ambient::bindings::types::Empty{dummy:i32::from(*((base + 16) as *const u8)) as u8, }),
                1 => Value::TypeBool({
                  #[cfg(not(debug_assertions))]
                  { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 16) as *const u8)) as u8) }
                  #[cfg(debug_assertions)]
                  {
                    match i32::from(*((base + 16) as *const u8)) {
                      0 => false,
                      1 => true,
                      _ => panic!("invalid bool discriminant"),
                    }
                  }
                }),
                2 => Value::TypeEntityId(super::super::super::ambient::bindings::types::EntityId{id0:*((base + 16) as *const i64) as u64, id1:*((base + 24) as *const i64) as u64, }),
                3 => Value::TypeF32(*((base + 16) as *const f32)),
                4 => Value::TypeF64(*((base + 16) as *const f64)),
                5 => Value::TypeMat4(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((base + 32) as *const f32), y:*((base + 36) as *const f32), z:*((base + 40) as *const f32), w:*((base + 44) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((base + 48) as *const f32), y:*((base + 52) as *const f32), z:*((base + 56) as *const f32), w:*((base + 60) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((base + 64) as *const f32), y:*((base + 68) as *const f32), z:*((base + 72) as *const f32), w:*((base + 76) as *const f32), }, }),
                6 => Value::TypeQuat(super::super::super::ambient::bindings::types::Quat{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }),
                7 => Value::TypeString({
                  let len3 = *((base + 20) as *const i32) as usize;
                  
                  {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 16) as *const i32) as *mut _, len3, len3))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 16) as *const i32) as *mut _, len3, len3)).unwrap()}}
                }),
                8 => Value::TypeU8(i32::from(*((base + 16) as *const u8)) as u8),
                9 => Value::TypeU16(i32::from(*((base + 16) as *const u16)) as u16),
                10 => Value::TypeU32(*((base + 16) as *const i32) as u32),
                11 => Value::TypeU64(*((base + 16) as *const i64) as u64),
                12 => Value::TypeI8(i32::from(*((base + 16) as *const i8)) as i8),
                13 => Value::TypeI16(i32::from(*((base + 16) as *const i16)) as i16),
                14 => Value::TypeI32(*((base + 16) as *const i32)),
                15 => Value::TypeI64(*((base + 16) as *const i64)),
                16 => Value::TypeVec2(super::super::super::ambient::bindings::types::Vec2{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), }),
                17 => Value::TypeVec3(super::super::super::ambient::bindings::types::Vec3{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), }),
                18 => Value::TypeVec4(super::super::super::ambient::bindings::types::Vec4{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }),
                19 => Value::TypeUvec2(super::super::super::ambient::bindings::types::Uvec2{x:*((base + 16) as *const i32) as u32, y:*((base + 20) as *const i32) as u32, }),
                20 => Value::TypeUvec3(super::super::super::ambient::bindings::types::Uvec3{x:*((base + 16) as *const i32) as u32, y:*((base + 20) as *const i32) as u32, z:*((base + 24) as *const i32) as u32, }),
                21 => Value::TypeUvec4(super::super::super::ambient::bindings::types::Uvec4{x:*((base + 16) as *const i32) as u32, y:*((base + 20) as *const i32) as u32, z:*((base + 24) as *const i32) as u32, w:*((base + 28) as *const i32) as u32, }),
                22 => Value::TypeIvec2(super::super::super::ambient::bindings::types::Ivec2{x:*((base + 16) as *const i32), y:*((base + 20) as *const i32), }),
                23 => Value::TypeIvec3(super::super::super::ambient::bindings::types::Ivec3{x:*((base + 16) as *const i32), y:*((base + 20) as *const i32), z:*((base + 24) as *const i32), }),
                24 => Value::TypeIvec4(super::super::super::ambient::bindings::types::Ivec4{x:*((base + 16) as *const i32), y:*((base + 20) as *const i32), z:*((base + 24) as *const i32), w:*((base + 28) as *const i32), }),
                25 => Value::TypeDuration(super::super::super::ambient::bindings::types::Duration{seconds:*((base + 16) as *const i64) as u64, nanoseconds:*((base + 24) as *const i32) as u32, }),
                26 => Value::TypeProceduralMeshHandle(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                27 => Value::TypeProceduralTextureHandle(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                28 => Value::TypeProceduralSamplerHandle(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                29 => Value::TypeProceduralMaterialHandle(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                30 => Value::TypeVec({{match i32::from(*((base + 16) as *const u8)) {
                  0 => VecValue::TypeEmpty({
                    let len4 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len4, len4)
                  }),
                  1 => VecValue::TypeBool({
                    let base5 = *((base + 20) as *const i32);
                    let len5 = *((base + 24) as *const i32);
                    let mut result5 = Vec::with_capacity(len5 as usize);
                    for i in 0..len5 {
                      let base = base5 + i *1;
                      result5.push({
                        #[cfg(not(debug_assertions))]
                        { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 0) as *const u8)) as u8) }
                        #[cfg(debug_assertions)]
                        {
                          match i32::from(*((base + 0) as *const u8)) {
                            0 => false,
                            1 => true,
                            _ => panic!("invalid bool discriminant"),
                          }
                        }
                      });
                    }
                    wit_bindgen::rt::dealloc(base5, (len5 as usize) * 1, 1);
                    
                    result5
                  }),
                  2 => VecValue::TypeEntityId({
                    let len6 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len6, len6)
                  }),
                  3 => VecValue::TypeF32({
                    let len7 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len7, len7)
                  }),
                  4 => VecValue::TypeF64({
                    let len8 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len8, len8)
                  }),
                  5 => VecValue::TypeMat4({
                    let len9 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len9, len9)
                  }),
                  6 => VecValue::TypeQuat({
                    let len10 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len10, len10)
                  }),
                  7 => VecValue::TypeString({
                    let base12 = *((base + 20) as *const i32);
                    let len12 = *((base + 24) as *const i32);
                    let mut result12 = Vec::with_capacity(len12 as usize);
                    for i in 0..len12 {
                      let base = base12 + i *8;
                      result12.push({
                        let len11 = *((base + 4) as *const i32) as usize;
                        
                        {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len11, len11))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len11, len11)).unwrap()}}
                      });
                    }
                    wit_bindgen::rt::dealloc(base12, (len12 as usize) * 8, 4);
                    
                    result12
                  }),
                  8 => VecValue::TypeU8({
                    let len13 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len13, len13)
                  }),
                  9 => VecValue::TypeU16({
                    let len14 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len14, len14)
                  }),
                  10 => VecValue::TypeU32({
                    let len15 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len15, len15)
                  }),
                  11 => VecValue::TypeU64({
                    let len16 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len16, len16)
                  }),
                  12 => VecValue::TypeI8({
                    let len17 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len17, len17)
                  }),
                  13 => VecValue::TypeI16({
                    let len18 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len18, len18)
                  }),
                  14 => VecValue::TypeI32({
                    let len19 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len19, len19)
                  }),
                  15 => VecValue::TypeI64({
                    let len20 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len20, len20)
                  }),
                  16 => VecValue::TypeVec2({
                    let len21 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len21, len21)
                  }),
                  17 => VecValue::TypeVec3({
                    let len22 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len22, len22)
                  }),
                  18 => VecValue::TypeVec4({
                    let len23 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len23, len23)
                  }),
                  19 => VecValue::TypeUvec2({
                    let len24 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len24, len24)
                  }),
                  20 => VecValue::TypeUvec3({
                    let len25 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len25, len25)
                  }),
                  21 => VecValue::TypeUvec4({
                    let len26 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len26, len26)
                  }),
                  22 => VecValue::TypeIvec2({
                    let len27 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len27, len27)
                  }),
                  23 => VecValue::TypeIvec3({
                    let len28 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len28, len28)
                  }),
                  24 => VecValue::TypeIvec4({
                    let len29 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len29, len29)
                  }),
                  25 => VecValue::TypeDuration({
                    let len30 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len30, len30)
                  }),
                  26 => VecValue::TypeProceduralMeshHandle({
                    let len31 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len31, len31)
                  }),
                  27 => VecValue::TypeProceduralTextureHandle({
                    let len32 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len32, len32)
                  }),
                  28 => VecValue::TypeProceduralSamplerHandle({
                    let len33 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len33, len33)
                  }),
                  #[cfg(debug_assertions)]29 => VecValue::TypeProceduralMaterialHandle({
                    let len34 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len34, len34)
                  }),
                  #[cfg(not(debug_assertions))]_ => VecValue::TypeProceduralMaterialHandle({
                    let len34 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len34, len34)
                  }),
                  #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                }}}),
                #[cfg(debug_assertions)]31 => Value::TypeOption({{match i32::from(*((base + 16) as *const u8)) {
                  0 => OptionValue::TypeEmpty(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Empty{dummy:i32::from(*((base + 25) as *const u8)) as u8, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  1 => OptionValue::TypeBool(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      #[cfg(not(debug_assertions))]
                      { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 25) as *const u8)) as u8) }
                      #[cfg(debug_assertions)]
                      {
                        match i32::from(*((base + 25) as *const u8)) {
                          0 => false,
                          1 => true,
                          _ => panic!("invalid bool discriminant"),
                        }
                      }
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  2 => OptionValue::TypeEntityId(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::EntityId{id0:*((base + 32) as *const i64) as u64, id1:*((base + 40) as *const i64) as u64, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  3 => OptionValue::TypeF32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const f32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  4 => OptionValue::TypeF64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const f64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  5 => OptionValue::TypeMat4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((base + 44) as *const f32), y:*((base + 48) as *const f32), z:*((base + 52) as *const f32), w:*((base + 56) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((base + 60) as *const f32), y:*((base + 64) as *const f32), z:*((base + 68) as *const f32), w:*((base + 72) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((base + 76) as *const f32), y:*((base + 80) as *const f32), z:*((base + 84) as *const f32), w:*((base + 88) as *const f32), }, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  6 => OptionValue::TypeQuat(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Quat{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  7 => OptionValue::TypeString(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      let len35 = *((base + 32) as *const i32) as usize;
                      
                      {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len35, len35))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len35, len35)).unwrap()}}
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  8 => OptionValue::TypeU8(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 25) as *const u8)) as u8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  9 => OptionValue::TypeU16(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 26) as *const u16)) as u16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  10 => OptionValue::TypeU32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const i32) as u32),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  11 => OptionValue::TypeU64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const i64) as u64),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  12 => OptionValue::TypeI8(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 25) as *const i8)) as i8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  13 => OptionValue::TypeI16(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 26) as *const i16)) as i16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  14 => OptionValue::TypeI32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const i32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  15 => OptionValue::TypeI64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const i64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  16 => OptionValue::TypeVec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec2{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  17 => OptionValue::TypeVec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec3{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  18 => OptionValue::TypeVec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  19 => OptionValue::TypeUvec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec2{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  20 => OptionValue::TypeUvec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec3{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  21 => OptionValue::TypeUvec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec4{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, w:*((base + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  22 => OptionValue::TypeIvec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec2{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  23 => OptionValue::TypeIvec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec3{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), z:*((base + 36) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  24 => OptionValue::TypeIvec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec4{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), z:*((base + 36) as *const i32), w:*((base + 40) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  25 => OptionValue::TypeDuration(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Duration{seconds:*((base + 32) as *const i64) as u64, nanoseconds:*((base + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  26 => OptionValue::TypeProceduralMeshHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  27 => OptionValue::TypeProceduralTextureHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  28 => OptionValue::TypeProceduralSamplerHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]29 => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(not(debug_assertions))]_ => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                }}}),
                #[cfg(not(debug_assertions))]_ => Value::TypeOption({{match i32::from(*((base + 16) as *const u8)) {
                  0 => OptionValue::TypeEmpty(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Empty{dummy:i32::from(*((base + 25) as *const u8)) as u8, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  1 => OptionValue::TypeBool(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      #[cfg(not(debug_assertions))]
                      { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 25) as *const u8)) as u8) }
                      #[cfg(debug_assertions)]
                      {
                        match i32::from(*((base + 25) as *const u8)) {
                          0 => false,
                          1 => true,
                          _ => panic!("invalid bool discriminant"),
                        }
                      }
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  2 => OptionValue::TypeEntityId(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::EntityId{id0:*((base + 32) as *const i64) as u64, id1:*((base + 40) as *const i64) as u64, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  3 => OptionValue::TypeF32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const f32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  4 => OptionValue::TypeF64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const f64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  5 => OptionValue::TypeMat4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((base + 44) as *const f32), y:*((base + 48) as *const f32), z:*((base + 52) as *const f32), w:*((base + 56) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((base + 60) as *const f32), y:*((base + 64) as *const f32), z:*((base + 68) as *const f32), w:*((base + 72) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((base + 76) as *const f32), y:*((base + 80) as *const f32), z:*((base + 84) as *const f32), w:*((base + 88) as *const f32), }, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  6 => OptionValue::TypeQuat(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Quat{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  7 => OptionValue::TypeString(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      let len35 = *((base + 32) as *const i32) as usize;
                      
                      {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len35, len35))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len35, len35)).unwrap()}}
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  8 => OptionValue::TypeU8(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 25) as *const u8)) as u8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  9 => OptionValue::TypeU16(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 26) as *const u16)) as u16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  10 => OptionValue::TypeU32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const i32) as u32),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  11 => OptionValue::TypeU64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const i64) as u64),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  12 => OptionValue::TypeI8(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 25) as *const i8)) as i8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  13 => OptionValue::TypeI16(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 26) as *const i16)) as i16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  14 => OptionValue::TypeI32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const i32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  15 => OptionValue::TypeI64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const i64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  16 => OptionValue::TypeVec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec2{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  17 => OptionValue::TypeVec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec3{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  18 => OptionValue::TypeVec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  19 => OptionValue::TypeUvec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec2{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  20 => OptionValue::TypeUvec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec3{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  21 => OptionValue::TypeUvec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec4{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, w:*((base + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  22 => OptionValue::TypeIvec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec2{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  23 => OptionValue::TypeIvec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec3{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), z:*((base + 36) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  24 => OptionValue::TypeIvec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec4{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), z:*((base + 36) as *const i32), w:*((base + 40) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  25 => OptionValue::TypeDuration(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Duration{seconds:*((base + 32) as *const i64) as u64, nanoseconds:*((base + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  26 => OptionValue::TypeProceduralMeshHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  27 => OptionValue::TypeProceduralTextureHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  28 => OptionValue::TypeProceduralSamplerHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]29 => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(not(debug_assertions))]_ => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                }}}),
                #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
              }}}));
            }
            wit_bindgen::rt::dealloc(base36, (len36 as usize) * 96, 8);
            result36
          }
        }
        #[allow(clippy::all)]
        pub fn get_all_components(entity: EntityId,) -> Entity{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 8]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[link(wasm_import_module = "ambient:bindings/component")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "get-all-components")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_get-all-components")]
              fn wit_import(
              _: i64, _: i64, _: i32, );
            }
            wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), ptr1);
            let base35 = *((ptr1 + 0) as *const i32);
            let len35 = *((ptr1 + 4) as *const i32);
            let mut result35 = Vec::with_capacity(len35 as usize);
            for i in 0..len35 {
              let base = base35 + i *96;
              result35.push((*((base + 0) as *const i32) as u32, {{match i32::from(*((base + 8) as *const u8)) {
                0 => Value::TypeEmpty(super::super::super::ambient::bindings::types::Empty{dummy:i32::from(*((base + 16) as *const u8)) as u8, }),
                1 => Value::TypeBool({
                  #[cfg(not(debug_assertions))]
                  { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 16) as *const u8)) as u8) }
                  #[cfg(debug_assertions)]
                  {
                    match i32::from(*((base + 16) as *const u8)) {
                      0 => false,
                      1 => true,
                      _ => panic!("invalid bool discriminant"),
                    }
                  }
                }),
                2 => Value::TypeEntityId(super::super::super::ambient::bindings::types::EntityId{id0:*((base + 16) as *const i64) as u64, id1:*((base + 24) as *const i64) as u64, }),
                3 => Value::TypeF32(*((base + 16) as *const f32)),
                4 => Value::TypeF64(*((base + 16) as *const f64)),
                5 => Value::TypeMat4(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((base + 32) as *const f32), y:*((base + 36) as *const f32), z:*((base + 40) as *const f32), w:*((base + 44) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((base + 48) as *const f32), y:*((base + 52) as *const f32), z:*((base + 56) as *const f32), w:*((base + 60) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((base + 64) as *const f32), y:*((base + 68) as *const f32), z:*((base + 72) as *const f32), w:*((base + 76) as *const f32), }, }),
                6 => Value::TypeQuat(super::super::super::ambient::bindings::types::Quat{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }),
                7 => Value::TypeString({
                  let len2 = *((base + 20) as *const i32) as usize;
                  
                  {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 16) as *const i32) as *mut _, len2, len2))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 16) as *const i32) as *mut _, len2, len2)).unwrap()}}
                }),
                8 => Value::TypeU8(i32::from(*((base + 16) as *const u8)) as u8),
                9 => Value::TypeU16(i32::from(*((base + 16) as *const u16)) as u16),
                10 => Value::TypeU32(*((base + 16) as *const i32) as u32),
                11 => Value::TypeU64(*((base + 16) as *const i64) as u64),
                12 => Value::TypeI8(i32::from(*((base + 16) as *const i8)) as i8),
                13 => Value::TypeI16(i32::from(*((base + 16) as *const i16)) as i16),
                14 => Value::TypeI32(*((base + 16) as *const i32)),
                15 => Value::TypeI64(*((base + 16) as *const i64)),
                16 => Value::TypeVec2(super::super::super::ambient::bindings::types::Vec2{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), }),
                17 => Value::TypeVec3(super::super::super::ambient::bindings::types::Vec3{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), }),
                18 => Value::TypeVec4(super::super::super::ambient::bindings::types::Vec4{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }),
                19 => Value::TypeUvec2(super::super::super::ambient::bindings::types::Uvec2{x:*((base + 16) as *const i32) as u32, y:*((base + 20) as *const i32) as u32, }),
                20 => Value::TypeUvec3(super::super::super::ambient::bindings::types::Uvec3{x:*((base + 16) as *const i32) as u32, y:*((base + 20) as *const i32) as u32, z:*((base + 24) as *const i32) as u32, }),
                21 => Value::TypeUvec4(super::super::super::ambient::bindings::types::Uvec4{x:*((base + 16) as *const i32) as u32, y:*((base + 20) as *const i32) as u32, z:*((base + 24) as *const i32) as u32, w:*((base + 28) as *const i32) as u32, }),
                22 => Value::TypeIvec2(super::super::super::ambient::bindings::types::Ivec2{x:*((base + 16) as *const i32), y:*((base + 20) as *const i32), }),
                23 => Value::TypeIvec3(super::super::super::ambient::bindings::types::Ivec3{x:*((base + 16) as *const i32), y:*((base + 20) as *const i32), z:*((base + 24) as *const i32), }),
                24 => Value::TypeIvec4(super::super::super::ambient::bindings::types::Ivec4{x:*((base + 16) as *const i32), y:*((base + 20) as *const i32), z:*((base + 24) as *const i32), w:*((base + 28) as *const i32), }),
                25 => Value::TypeDuration(super::super::super::ambient::bindings::types::Duration{seconds:*((base + 16) as *const i64) as u64, nanoseconds:*((base + 24) as *const i32) as u32, }),
                26 => Value::TypeProceduralMeshHandle(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                27 => Value::TypeProceduralTextureHandle(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                28 => Value::TypeProceduralSamplerHandle(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                29 => Value::TypeProceduralMaterialHandle(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                30 => Value::TypeVec({{match i32::from(*((base + 16) as *const u8)) {
                  0 => VecValue::TypeEmpty({
                    let len3 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len3, len3)
                  }),
                  1 => VecValue::TypeBool({
                    let base4 = *((base + 20) as *const i32);
                    let len4 = *((base + 24) as *const i32);
                    let mut result4 = Vec::with_capacity(len4 as usize);
                    for i in 0..len4 {
                      let base = base4 + i *1;
                      result4.push({
                        #[cfg(not(debug_assertions))]
                        { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 0) as *const u8)) as u8) }
                        #[cfg(debug_assertions)]
                        {
                          match i32::from(*((base + 0) as *const u8)) {
                            0 => false,
                            1 => true,
                            _ => panic!("invalid bool discriminant"),
                          }
                        }
                      });
                    }
                    wit_bindgen::rt::dealloc(base4, (len4 as usize) * 1, 1);
                    
                    result4
                  }),
                  2 => VecValue::TypeEntityId({
                    let len5 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len5, len5)
                  }),
                  3 => VecValue::TypeF32({
                    let len6 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len6, len6)
                  }),
                  4 => VecValue::TypeF64({
                    let len7 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len7, len7)
                  }),
                  5 => VecValue::TypeMat4({
                    let len8 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len8, len8)
                  }),
                  6 => VecValue::TypeQuat({
                    let len9 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len9, len9)
                  }),
                  7 => VecValue::TypeString({
                    let base11 = *((base + 20) as *const i32);
                    let len11 = *((base + 24) as *const i32);
                    let mut result11 = Vec::with_capacity(len11 as usize);
                    for i in 0..len11 {
                      let base = base11 + i *8;
                      result11.push({
                        let len10 = *((base + 4) as *const i32) as usize;
                        
                        {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len10, len10))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len10, len10)).unwrap()}}
                      });
                    }
                    wit_bindgen::rt::dealloc(base11, (len11 as usize) * 8, 4);
                    
                    result11
                  }),
                  8 => VecValue::TypeU8({
                    let len12 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len12, len12)
                  }),
                  9 => VecValue::TypeU16({
                    let len13 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len13, len13)
                  }),
                  10 => VecValue::TypeU32({
                    let len14 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len14, len14)
                  }),
                  11 => VecValue::TypeU64({
                    let len15 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len15, len15)
                  }),
                  12 => VecValue::TypeI8({
                    let len16 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len16, len16)
                  }),
                  13 => VecValue::TypeI16({
                    let len17 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len17, len17)
                  }),
                  14 => VecValue::TypeI32({
                    let len18 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len18, len18)
                  }),
                  15 => VecValue::TypeI64({
                    let len19 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len19, len19)
                  }),
                  16 => VecValue::TypeVec2({
                    let len20 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len20, len20)
                  }),
                  17 => VecValue::TypeVec3({
                    let len21 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len21, len21)
                  }),
                  18 => VecValue::TypeVec4({
                    let len22 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len22, len22)
                  }),
                  19 => VecValue::TypeUvec2({
                    let len23 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len23, len23)
                  }),
                  20 => VecValue::TypeUvec3({
                    let len24 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len24, len24)
                  }),
                  21 => VecValue::TypeUvec4({
                    let len25 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len25, len25)
                  }),
                  22 => VecValue::TypeIvec2({
                    let len26 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len26, len26)
                  }),
                  23 => VecValue::TypeIvec3({
                    let len27 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len27, len27)
                  }),
                  24 => VecValue::TypeIvec4({
                    let len28 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len28, len28)
                  }),
                  25 => VecValue::TypeDuration({
                    let len29 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len29, len29)
                  }),
                  26 => VecValue::TypeProceduralMeshHandle({
                    let len30 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len30, len30)
                  }),
                  27 => VecValue::TypeProceduralTextureHandle({
                    let len31 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len31, len31)
                  }),
                  28 => VecValue::TypeProceduralSamplerHandle({
                    let len32 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len32, len32)
                  }),
                  #[cfg(debug_assertions)]29 => VecValue::TypeProceduralMaterialHandle({
                    let len33 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len33, len33)
                  }),
                  #[cfg(not(debug_assertions))]_ => VecValue::TypeProceduralMaterialHandle({
                    let len33 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len33, len33)
                  }),
                  #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                }}}),
                #[cfg(debug_assertions)]31 => Value::TypeOption({{match i32::from(*((base + 16) as *const u8)) {
                  0 => OptionValue::TypeEmpty(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Empty{dummy:i32::from(*((base + 25) as *const u8)) as u8, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  1 => OptionValue::TypeBool(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      #[cfg(not(debug_assertions))]
                      { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 25) as *const u8)) as u8) }
                      #[cfg(debug_assertions)]
                      {
                        match i32::from(*((base + 25) as *const u8)) {
                          0 => false,
                          1 => true,
                          _ => panic!("invalid bool discriminant"),
                        }
                      }
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  2 => OptionValue::TypeEntityId(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::EntityId{id0:*((base + 32) as *const i64) as u64, id1:*((base + 40) as *const i64) as u64, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  3 => OptionValue::TypeF32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const f32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  4 => OptionValue::TypeF64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const f64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  5 => OptionValue::TypeMat4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((base + 44) as *const f32), y:*((base + 48) as *const f32), z:*((base + 52) as *const f32), w:*((base + 56) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((base + 60) as *const f32), y:*((base + 64) as *const f32), z:*((base + 68) as *const f32), w:*((base + 72) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((base + 76) as *const f32), y:*((base + 80) as *const f32), z:*((base + 84) as *const f32), w:*((base + 88) as *const f32), }, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  6 => OptionValue::TypeQuat(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Quat{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  7 => OptionValue::TypeString(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      let len34 = *((base + 32) as *const i32) as usize;
                      
                      {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len34, len34))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len34, len34)).unwrap()}}
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  8 => OptionValue::TypeU8(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 25) as *const u8)) as u8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  9 => OptionValue::TypeU16(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 26) as *const u16)) as u16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  10 => OptionValue::TypeU32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const i32) as u32),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  11 => OptionValue::TypeU64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const i64) as u64),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  12 => OptionValue::TypeI8(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 25) as *const i8)) as i8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  13 => OptionValue::TypeI16(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 26) as *const i16)) as i16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  14 => OptionValue::TypeI32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const i32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  15 => OptionValue::TypeI64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const i64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  16 => OptionValue::TypeVec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec2{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  17 => OptionValue::TypeVec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec3{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  18 => OptionValue::TypeVec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  19 => OptionValue::TypeUvec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec2{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  20 => OptionValue::TypeUvec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec3{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  21 => OptionValue::TypeUvec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec4{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, w:*((base + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  22 => OptionValue::TypeIvec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec2{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  23 => OptionValue::TypeIvec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec3{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), z:*((base + 36) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  24 => OptionValue::TypeIvec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec4{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), z:*((base + 36) as *const i32), w:*((base + 40) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  25 => OptionValue::TypeDuration(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Duration{seconds:*((base + 32) as *const i64) as u64, nanoseconds:*((base + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  26 => OptionValue::TypeProceduralMeshHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  27 => OptionValue::TypeProceduralTextureHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  28 => OptionValue::TypeProceduralSamplerHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]29 => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(not(debug_assertions))]_ => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                }}}),
                #[cfg(not(debug_assertions))]_ => Value::TypeOption({{match i32::from(*((base + 16) as *const u8)) {
                  0 => OptionValue::TypeEmpty(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Empty{dummy:i32::from(*((base + 25) as *const u8)) as u8, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  1 => OptionValue::TypeBool(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      #[cfg(not(debug_assertions))]
                      { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 25) as *const u8)) as u8) }
                      #[cfg(debug_assertions)]
                      {
                        match i32::from(*((base + 25) as *const u8)) {
                          0 => false,
                          1 => true,
                          _ => panic!("invalid bool discriminant"),
                        }
                      }
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  2 => OptionValue::TypeEntityId(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::EntityId{id0:*((base + 32) as *const i64) as u64, id1:*((base + 40) as *const i64) as u64, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  3 => OptionValue::TypeF32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const f32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  4 => OptionValue::TypeF64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const f64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  5 => OptionValue::TypeMat4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((base + 44) as *const f32), y:*((base + 48) as *const f32), z:*((base + 52) as *const f32), w:*((base + 56) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((base + 60) as *const f32), y:*((base + 64) as *const f32), z:*((base + 68) as *const f32), w:*((base + 72) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((base + 76) as *const f32), y:*((base + 80) as *const f32), z:*((base + 84) as *const f32), w:*((base + 88) as *const f32), }, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  6 => OptionValue::TypeQuat(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Quat{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  7 => OptionValue::TypeString(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      let len34 = *((base + 32) as *const i32) as usize;
                      
                      {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len34, len34))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len34, len34)).unwrap()}}
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  8 => OptionValue::TypeU8(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 25) as *const u8)) as u8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  9 => OptionValue::TypeU16(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 26) as *const u16)) as u16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  10 => OptionValue::TypeU32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const i32) as u32),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  11 => OptionValue::TypeU64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const i64) as u64),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  12 => OptionValue::TypeI8(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 25) as *const i8)) as i8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  13 => OptionValue::TypeI16(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 26) as *const i16)) as i16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  14 => OptionValue::TypeI32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const i32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  15 => OptionValue::TypeI64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const i64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  16 => OptionValue::TypeVec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec2{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  17 => OptionValue::TypeVec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec3{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  18 => OptionValue::TypeVec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  19 => OptionValue::TypeUvec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec2{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  20 => OptionValue::TypeUvec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec3{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  21 => OptionValue::TypeUvec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec4{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, w:*((base + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  22 => OptionValue::TypeIvec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec2{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  23 => OptionValue::TypeIvec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec3{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), z:*((base + 36) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  24 => OptionValue::TypeIvec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec4{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), z:*((base + 36) as *const i32), w:*((base + 40) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  25 => OptionValue::TypeDuration(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Duration{seconds:*((base + 32) as *const i64) as u64, nanoseconds:*((base + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  26 => OptionValue::TypeProceduralMeshHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  27 => OptionValue::TypeProceduralTextureHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  28 => OptionValue::TypeProceduralSamplerHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]29 => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(not(debug_assertions))]_ => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                }}}),
                #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
              }}}));
            }
            wit_bindgen::rt::dealloc(base35, (len35 as usize) * 96, 8);
            result35
          }
        }
        #[allow(clippy::all)]
        pub fn add_component(entity: EntityId,index: u32,value: &Value,){
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            let mut cleanup_list = Vec::new();
            
            #[repr(align(8))]
            struct RetArea([u8; 112]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;let super::super::super::ambient::bindings::types::EntityId{ id0:id01, id1:id11, } = entity;
            *((ptr0 + 0) as *mut i64) = wit_bindgen::rt::as_i64(id01);
            *((ptr0 + 8) as *mut i64) = wit_bindgen::rt::as_i64(id11);
            *((ptr0 + 16) as *mut i32) = wit_bindgen::rt::as_i32(index);
            match value {
              Value::TypeEmpty(e) => {
                *((ptr0 + 24) as *mut u8) = (0i32) as u8;
                let super::super::super::ambient::bindings::types::Empty{ dummy:dummy2, } = e;
                *((ptr0 + 32) as *mut u8) = (wit_bindgen::rt::as_i32(dummy2)) as u8;
                
              },
              Value::TypeBool(e) => {
                *((ptr0 + 24) as *mut u8) = (1i32) as u8;
                *((ptr0 + 32) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                
              },
              Value::TypeEntityId(e) => {
                *((ptr0 + 24) as *mut u8) = (2i32) as u8;
                let super::super::super::ambient::bindings::types::EntityId{ id0:id03, id1:id13, } = e;
                *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(id03);
                *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(id13);
                
              },
              Value::TypeF32(e) => {
                *((ptr0 + 24) as *mut u8) = (3i32) as u8;
                *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(e);
                
              },
              Value::TypeF64(e) => {
                *((ptr0 + 24) as *mut u8) = (4i32) as u8;
                *((ptr0 + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                
              },
              Value::TypeMat4(e) => {
                *((ptr0 + 24) as *mut u8) = (5i32) as u8;
                let super::super::super::ambient::bindings::types::Mat4{ x:x4, y:y4, z:z4, w:w4, } = e;
                let super::super::super::ambient::bindings::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = x4;
                *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x5);
                *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y5);
                *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z5);
                *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w5);
                let super::super::super::ambient::bindings::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = y4;
                *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(x6);
                *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(y6);
                *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(z6);
                *((ptr0 + 60) as *mut f32) = wit_bindgen::rt::as_f32(w6);
                let super::super::super::ambient::bindings::types::Vec4{ x:x7, y:y7, z:z7, w:w7, } = z4;
                *((ptr0 + 64) as *mut f32) = wit_bindgen::rt::as_f32(x7);
                *((ptr0 + 68) as *mut f32) = wit_bindgen::rt::as_f32(y7);
                *((ptr0 + 72) as *mut f32) = wit_bindgen::rt::as_f32(z7);
                *((ptr0 + 76) as *mut f32) = wit_bindgen::rt::as_f32(w7);
                let super::super::super::ambient::bindings::types::Vec4{ x:x8, y:y8, z:z8, w:w8, } = w4;
                *((ptr0 + 80) as *mut f32) = wit_bindgen::rt::as_f32(x8);
                *((ptr0 + 84) as *mut f32) = wit_bindgen::rt::as_f32(y8);
                *((ptr0 + 88) as *mut f32) = wit_bindgen::rt::as_f32(z8);
                *((ptr0 + 92) as *mut f32) = wit_bindgen::rt::as_f32(w8);
                
              },
              Value::TypeQuat(e) => {
                *((ptr0 + 24) as *mut u8) = (6i32) as u8;
                let super::super::super::ambient::bindings::types::Quat{ x:x9, y:y9, z:z9, w:w9, } = e;
                *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x9);
                *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y9);
                *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z9);
                *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w9);
                
              },
              Value::TypeString(e) => {
                *((ptr0 + 24) as *mut u8) = (7i32) as u8;
                let vec10 = e;
                let ptr10 = vec10.as_ptr() as i32;
                let len10 = vec10.len() as i32;
                *((ptr0 + 36) as *mut i32) = len10;
                *((ptr0 + 32) as *mut i32) = ptr10;
                
              },
              Value::TypeU8(e) => {
                *((ptr0 + 24) as *mut u8) = (8i32) as u8;
                *((ptr0 + 32) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                
              },
              Value::TypeU16(e) => {
                *((ptr0 + 24) as *mut u8) = (9i32) as u8;
                *((ptr0 + 32) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                
              },
              Value::TypeU32(e) => {
                *((ptr0 + 24) as *mut u8) = (10i32) as u8;
                *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(e);
                
              },
              Value::TypeU64(e) => {
                *((ptr0 + 24) as *mut u8) = (11i32) as u8;
                *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                
              },
              Value::TypeI8(e) => {
                *((ptr0 + 24) as *mut u8) = (12i32) as u8;
                *((ptr0 + 32) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                
              },
              Value::TypeI16(e) => {
                *((ptr0 + 24) as *mut u8) = (13i32) as u8;
                *((ptr0 + 32) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                
              },
              Value::TypeI32(e) => {
                *((ptr0 + 24) as *mut u8) = (14i32) as u8;
                *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(e);
                
              },
              Value::TypeI64(e) => {
                *((ptr0 + 24) as *mut u8) = (15i32) as u8;
                *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                
              },
              Value::TypeVec2(e) => {
                *((ptr0 + 24) as *mut u8) = (16i32) as u8;
                let super::super::super::ambient::bindings::types::Vec2{ x:x11, y:y11, } = e;
                *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x11);
                *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y11);
                
              },
              Value::TypeVec3(e) => {
                *((ptr0 + 24) as *mut u8) = (17i32) as u8;
                let super::super::super::ambient::bindings::types::Vec3{ x:x12, y:y12, z:z12, } = e;
                *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x12);
                *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y12);
                *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z12);
                
              },
              Value::TypeVec4(e) => {
                *((ptr0 + 24) as *mut u8) = (18i32) as u8;
                let super::super::super::ambient::bindings::types::Vec4{ x:x13, y:y13, z:z13, w:w13, } = e;
                *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x13);
                *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y13);
                *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z13);
                *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w13);
                
              },
              Value::TypeUvec2(e) => {
                *((ptr0 + 24) as *mut u8) = (19i32) as u8;
                let super::super::super::ambient::bindings::types::Uvec2{ x:x14, y:y14, } = e;
                *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x14);
                *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y14);
                
              },
              Value::TypeUvec3(e) => {
                *((ptr0 + 24) as *mut u8) = (20i32) as u8;
                let super::super::super::ambient::bindings::types::Uvec3{ x:x15, y:y15, z:z15, } = e;
                *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x15);
                *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y15);
                *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z15);
                
              },
              Value::TypeUvec4(e) => {
                *((ptr0 + 24) as *mut u8) = (21i32) as u8;
                let super::super::super::ambient::bindings::types::Uvec4{ x:x16, y:y16, z:z16, w:w16, } = e;
                *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x16);
                *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y16);
                *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z16);
                *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(w16);
                
              },
              Value::TypeIvec2(e) => {
                *((ptr0 + 24) as *mut u8) = (22i32) as u8;
                let super::super::super::ambient::bindings::types::Ivec2{ x:x17, y:y17, } = e;
                *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x17);
                *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y17);
                
              },
              Value::TypeIvec3(e) => {
                *((ptr0 + 24) as *mut u8) = (23i32) as u8;
                let super::super::super::ambient::bindings::types::Ivec3{ x:x18, y:y18, z:z18, } = e;
                *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x18);
                *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y18);
                *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z18);
                
              },
              Value::TypeIvec4(e) => {
                *((ptr0 + 24) as *mut u8) = (24i32) as u8;
                let super::super::super::ambient::bindings::types::Ivec4{ x:x19, y:y19, z:z19, w:w19, } = e;
                *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x19);
                *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y19);
                *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z19);
                *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(w19);
                
              },
              Value::TypeDuration(e) => {
                *((ptr0 + 24) as *mut u8) = (25i32) as u8;
                let super::super::super::ambient::bindings::types::Duration{ seconds:seconds20, nanoseconds:nanoseconds20, } = e;
                *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(seconds20);
                *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(nanoseconds20);
                
              },
              Value::TypeProceduralMeshHandle(e) => {
                *((ptr0 + 24) as *mut u8) = (26i32) as u8;
                let super::super::super::ambient::bindings::client_mesh::Handle{ ulid:ulid21, } = e;
                let (t22_0, t22_1, ) = ulid21;
                *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t22_0);
                *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t22_1);
                
              },
              Value::TypeProceduralTextureHandle(e) => {
                *((ptr0 + 24) as *mut u8) = (27i32) as u8;
                let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid23, } = e;
                let (t24_0, t24_1, ) = ulid23;
                *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t24_0);
                *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t24_1);
                
              },
              Value::TypeProceduralSamplerHandle(e) => {
                *((ptr0 + 24) as *mut u8) = (28i32) as u8;
                let super::super::super::ambient::bindings::client_sampler::Handle{ ulid:ulid25, } = e;
                let (t26_0, t26_1, ) = ulid25;
                *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t26_0);
                *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t26_1);
                
              },
              Value::TypeProceduralMaterialHandle(e) => {
                *((ptr0 + 24) as *mut u8) = (29i32) as u8;
                let super::super::super::ambient::bindings::client_material::Handle{ ulid:ulid27, } = e;
                let (t28_0, t28_1, ) = ulid27;
                *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t28_0);
                *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t28_1);
                
              },
              Value::TypeVec(e) => {
                *((ptr0 + 24) as *mut u8) = (30i32) as u8;
                match e {
                  VecValue::TypeEmpty(e) => {
                    *((ptr0 + 32) as *mut u8) = (0i32) as u8;
                    let vec29 = e;
                    let ptr29 = vec29.as_ptr() as i32;
                    let len29 = vec29.len() as i32;
                    *((ptr0 + 40) as *mut i32) = len29;
                    *((ptr0 + 36) as *mut i32) = ptr29;
                    
                  },
                  VecValue::TypeBool(e) => {
                    *((ptr0 + 32) as *mut u8) = (1i32) as u8;
                    let vec30 = e;
                    let len30 = vec30.len() as i32;
                    let layout30 = alloc::Layout::from_size_align_unchecked(vec30.len() * 1, 1);
                    let result30 = if layout30.size() != 0
                    {
                      let ptr = alloc::alloc(layout30);
                      if ptr.is_null()
                      {
                        alloc::handle_alloc_error(layout30);
                      }
                      ptr
                    }else {
                      ::core::ptr::null_mut()
                    };
                    for (i, e) in vec30.into_iter().enumerate() {
                      let base = result30 as i32 + (i as i32) * 1;
                      {
                        *((base + 0) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                        
                      }}
                      *((ptr0 + 40) as *mut i32) = len30;
                      *((ptr0 + 36) as *mut i32) = result30 as i32;
                      cleanup_list.extend_from_slice(&[(result30, layout30),]);
                      
                    },
                    VecValue::TypeEntityId(e) => {
                      *((ptr0 + 32) as *mut u8) = (2i32) as u8;
                      let vec31 = e;
                      let ptr31 = vec31.as_ptr() as i32;
                      let len31 = vec31.len() as i32;
                      *((ptr0 + 40) as *mut i32) = len31;
                      *((ptr0 + 36) as *mut i32) = ptr31;
                      
                    },
                    VecValue::TypeF32(e) => {
                      *((ptr0 + 32) as *mut u8) = (3i32) as u8;
                      let vec32 = e;
                      let ptr32 = vec32.as_ptr() as i32;
                      let len32 = vec32.len() as i32;
                      *((ptr0 + 40) as *mut i32) = len32;
                      *((ptr0 + 36) as *mut i32) = ptr32;
                      
                    },
                    VecValue::TypeF64(e) => {
                      *((ptr0 + 32) as *mut u8) = (4i32) as u8;
                      let vec33 = e;
                      let ptr33 = vec33.as_ptr() as i32;
                      let len33 = vec33.len() as i32;
                      *((ptr0 + 40) as *mut i32) = len33;
                      *((ptr0 + 36) as *mut i32) = ptr33;
                      
                    },
                    VecValue::TypeMat4(e) => {
                      *((ptr0 + 32) as *mut u8) = (5i32) as u8;
                      let vec34 = e;
                      let ptr34 = vec34.as_ptr() as i32;
                      let len34 = vec34.len() as i32;
                      *((ptr0 + 40) as *mut i32) = len34;
                      *((ptr0 + 36) as *mut i32) = ptr34;
                      
                    },
                    VecValue::TypeQuat(e) => {
                      *((ptr0 + 32) as *mut u8) = (6i32) as u8;
                      let vec35 = e;
                      let ptr35 = vec35.as_ptr() as i32;
                      let len35 = vec35.len() as i32;
                      *((ptr0 + 40) as *mut i32) = len35;
                      *((ptr0 + 36) as *mut i32) = ptr35;
                      
                    },
                    VecValue::TypeString(e) => {
                      *((ptr0 + 32) as *mut u8) = (7i32) as u8;
                      let vec37 = e;
                      let len37 = vec37.len() as i32;
                      let layout37 = alloc::Layout::from_size_align_unchecked(vec37.len() * 8, 4);
                      let result37 = if layout37.size() != 0
                      {
                        let ptr = alloc::alloc(layout37);
                        if ptr.is_null()
                        {
                          alloc::handle_alloc_error(layout37);
                        }
                        ptr
                      }else {
                        ::core::ptr::null_mut()
                      };
                      for (i, e) in vec37.into_iter().enumerate() {
                        let base = result37 as i32 + (i as i32) * 8;
                        {
                          let vec36 = e;
                          let ptr36 = vec36.as_ptr() as i32;
                          let len36 = vec36.len() as i32;
                          *((base + 4) as *mut i32) = len36;
                          *((base + 0) as *mut i32) = ptr36;
                          
                        }}
                        *((ptr0 + 40) as *mut i32) = len37;
                        *((ptr0 + 36) as *mut i32) = result37 as i32;
                        cleanup_list.extend_from_slice(&[(result37, layout37),]);
                        
                      },
                      VecValue::TypeU8(e) => {
                        *((ptr0 + 32) as *mut u8) = (8i32) as u8;
                        let vec38 = e;
                        let ptr38 = vec38.as_ptr() as i32;
                        let len38 = vec38.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len38;
                        *((ptr0 + 36) as *mut i32) = ptr38;
                        
                      },
                      VecValue::TypeU16(e) => {
                        *((ptr0 + 32) as *mut u8) = (9i32) as u8;
                        let vec39 = e;
                        let ptr39 = vec39.as_ptr() as i32;
                        let len39 = vec39.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len39;
                        *((ptr0 + 36) as *mut i32) = ptr39;
                        
                      },
                      VecValue::TypeU32(e) => {
                        *((ptr0 + 32) as *mut u8) = (10i32) as u8;
                        let vec40 = e;
                        let ptr40 = vec40.as_ptr() as i32;
                        let len40 = vec40.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len40;
                        *((ptr0 + 36) as *mut i32) = ptr40;
                        
                      },
                      VecValue::TypeU64(e) => {
                        *((ptr0 + 32) as *mut u8) = (11i32) as u8;
                        let vec41 = e;
                        let ptr41 = vec41.as_ptr() as i32;
                        let len41 = vec41.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len41;
                        *((ptr0 + 36) as *mut i32) = ptr41;
                        
                      },
                      VecValue::TypeI8(e) => {
                        *((ptr0 + 32) as *mut u8) = (12i32) as u8;
                        let vec42 = e;
                        let ptr42 = vec42.as_ptr() as i32;
                        let len42 = vec42.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len42;
                        *((ptr0 + 36) as *mut i32) = ptr42;
                        
                      },
                      VecValue::TypeI16(e) => {
                        *((ptr0 + 32) as *mut u8) = (13i32) as u8;
                        let vec43 = e;
                        let ptr43 = vec43.as_ptr() as i32;
                        let len43 = vec43.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len43;
                        *((ptr0 + 36) as *mut i32) = ptr43;
                        
                      },
                      VecValue::TypeI32(e) => {
                        *((ptr0 + 32) as *mut u8) = (14i32) as u8;
                        let vec44 = e;
                        let ptr44 = vec44.as_ptr() as i32;
                        let len44 = vec44.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len44;
                        *((ptr0 + 36) as *mut i32) = ptr44;
                        
                      },
                      VecValue::TypeI64(e) => {
                        *((ptr0 + 32) as *mut u8) = (15i32) as u8;
                        let vec45 = e;
                        let ptr45 = vec45.as_ptr() as i32;
                        let len45 = vec45.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len45;
                        *((ptr0 + 36) as *mut i32) = ptr45;
                        
                      },
                      VecValue::TypeVec2(e) => {
                        *((ptr0 + 32) as *mut u8) = (16i32) as u8;
                        let vec46 = e;
                        let ptr46 = vec46.as_ptr() as i32;
                        let len46 = vec46.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len46;
                        *((ptr0 + 36) as *mut i32) = ptr46;
                        
                      },
                      VecValue::TypeVec3(e) => {
                        *((ptr0 + 32) as *mut u8) = (17i32) as u8;
                        let vec47 = e;
                        let ptr47 = vec47.as_ptr() as i32;
                        let len47 = vec47.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len47;
                        *((ptr0 + 36) as *mut i32) = ptr47;
                        
                      },
                      VecValue::TypeVec4(e) => {
                        *((ptr0 + 32) as *mut u8) = (18i32) as u8;
                        let vec48 = e;
                        let ptr48 = vec48.as_ptr() as i32;
                        let len48 = vec48.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len48;
                        *((ptr0 + 36) as *mut i32) = ptr48;
                        
                      },
                      VecValue::TypeUvec2(e) => {
                        *((ptr0 + 32) as *mut u8) = (19i32) as u8;
                        let vec49 = e;
                        let ptr49 = vec49.as_ptr() as i32;
                        let len49 = vec49.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len49;
                        *((ptr0 + 36) as *mut i32) = ptr49;
                        
                      },
                      VecValue::TypeUvec3(e) => {
                        *((ptr0 + 32) as *mut u8) = (20i32) as u8;
                        let vec50 = e;
                        let ptr50 = vec50.as_ptr() as i32;
                        let len50 = vec50.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len50;
                        *((ptr0 + 36) as *mut i32) = ptr50;
                        
                      },
                      VecValue::TypeUvec4(e) => {
                        *((ptr0 + 32) as *mut u8) = (21i32) as u8;
                        let vec51 = e;
                        let ptr51 = vec51.as_ptr() as i32;
                        let len51 = vec51.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len51;
                        *((ptr0 + 36) as *mut i32) = ptr51;
                        
                      },
                      VecValue::TypeIvec2(e) => {
                        *((ptr0 + 32) as *mut u8) = (22i32) as u8;
                        let vec52 = e;
                        let ptr52 = vec52.as_ptr() as i32;
                        let len52 = vec52.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len52;
                        *((ptr0 + 36) as *mut i32) = ptr52;
                        
                      },
                      VecValue::TypeIvec3(e) => {
                        *((ptr0 + 32) as *mut u8) = (23i32) as u8;
                        let vec53 = e;
                        let ptr53 = vec53.as_ptr() as i32;
                        let len53 = vec53.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len53;
                        *((ptr0 + 36) as *mut i32) = ptr53;
                        
                      },
                      VecValue::TypeIvec4(e) => {
                        *((ptr0 + 32) as *mut u8) = (24i32) as u8;
                        let vec54 = e;
                        let ptr54 = vec54.as_ptr() as i32;
                        let len54 = vec54.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len54;
                        *((ptr0 + 36) as *mut i32) = ptr54;
                        
                      },
                      VecValue::TypeDuration(e) => {
                        *((ptr0 + 32) as *mut u8) = (25i32) as u8;
                        let vec55 = e;
                        let ptr55 = vec55.as_ptr() as i32;
                        let len55 = vec55.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len55;
                        *((ptr0 + 36) as *mut i32) = ptr55;
                        
                      },
                      VecValue::TypeProceduralMeshHandle(e) => {
                        *((ptr0 + 32) as *mut u8) = (26i32) as u8;
                        let vec56 = e;
                        let ptr56 = vec56.as_ptr() as i32;
                        let len56 = vec56.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len56;
                        *((ptr0 + 36) as *mut i32) = ptr56;
                        
                      },
                      VecValue::TypeProceduralTextureHandle(e) => {
                        *((ptr0 + 32) as *mut u8) = (27i32) as u8;
                        let vec57 = e;
                        let ptr57 = vec57.as_ptr() as i32;
                        let len57 = vec57.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len57;
                        *((ptr0 + 36) as *mut i32) = ptr57;
                        
                      },
                      VecValue::TypeProceduralSamplerHandle(e) => {
                        *((ptr0 + 32) as *mut u8) = (28i32) as u8;
                        let vec58 = e;
                        let ptr58 = vec58.as_ptr() as i32;
                        let len58 = vec58.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len58;
                        *((ptr0 + 36) as *mut i32) = ptr58;
                        
                      },
                      VecValue::TypeProceduralMaterialHandle(e) => {
                        *((ptr0 + 32) as *mut u8) = (29i32) as u8;
                        let vec59 = e;
                        let ptr59 = vec59.as_ptr() as i32;
                        let len59 = vec59.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len59;
                        *((ptr0 + 36) as *mut i32) = ptr59;
                        
                      },
                    };
                    
                  },
                  Value::TypeOption(e) => {
                    *((ptr0 + 24) as *mut u8) = (31i32) as u8;
                    match e {
                      OptionValue::TypeEmpty(e) => {
                        *((ptr0 + 32) as *mut u8) = (0i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Empty{ dummy:dummy60, } = e;
                            *((ptr0 + 41) as *mut u8) = (wit_bindgen::rt::as_i32(dummy60)) as u8;
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeBool(e) => {
                        *((ptr0 + 32) as *mut u8) = (1i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            *((ptr0 + 41) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeEntityId(e) => {
                        *((ptr0 + 32) as *mut u8) = (2i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::EntityId{ id0:id061, id1:id161, } = e;
                            *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(id061);
                            *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(id161);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeF32(e) => {
                        *((ptr0 + 32) as *mut u8) = (3i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(e);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeF64(e) => {
                        *((ptr0 + 32) as *mut u8) = (4i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            *((ptr0 + 48) as *mut f64) = wit_bindgen::rt::as_f64(e);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeMat4(e) => {
                        *((ptr0 + 32) as *mut u8) = (5i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Mat4{ x:x62, y:y62, z:z62, w:w62, } = e;
                            let super::super::super::ambient::bindings::types::Vec4{ x:x63, y:y63, z:z63, w:w63, } = x62;
                            *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x63);
                            *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y63);
                            *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z63);
                            *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w63);
                            let super::super::super::ambient::bindings::types::Vec4{ x:x64, y:y64, z:z64, w:w64, } = y62;
                            *((ptr0 + 60) as *mut f32) = wit_bindgen::rt::as_f32(x64);
                            *((ptr0 + 64) as *mut f32) = wit_bindgen::rt::as_f32(y64);
                            *((ptr0 + 68) as *mut f32) = wit_bindgen::rt::as_f32(z64);
                            *((ptr0 + 72) as *mut f32) = wit_bindgen::rt::as_f32(w64);
                            let super::super::super::ambient::bindings::types::Vec4{ x:x65, y:y65, z:z65, w:w65, } = z62;
                            *((ptr0 + 76) as *mut f32) = wit_bindgen::rt::as_f32(x65);
                            *((ptr0 + 80) as *mut f32) = wit_bindgen::rt::as_f32(y65);
                            *((ptr0 + 84) as *mut f32) = wit_bindgen::rt::as_f32(z65);
                            *((ptr0 + 88) as *mut f32) = wit_bindgen::rt::as_f32(w65);
                            let super::super::super::ambient::bindings::types::Vec4{ x:x66, y:y66, z:z66, w:w66, } = w62;
                            *((ptr0 + 92) as *mut f32) = wit_bindgen::rt::as_f32(x66);
                            *((ptr0 + 96) as *mut f32) = wit_bindgen::rt::as_f32(y66);
                            *((ptr0 + 100) as *mut f32) = wit_bindgen::rt::as_f32(z66);
                            *((ptr0 + 104) as *mut f32) = wit_bindgen::rt::as_f32(w66);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeQuat(e) => {
                        *((ptr0 + 32) as *mut u8) = (6i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Quat{ x:x67, y:y67, z:z67, w:w67, } = e;
                            *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x67);
                            *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y67);
                            *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z67);
                            *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w67);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeString(e) => {
                        *((ptr0 + 32) as *mut u8) = (7i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let vec68 = e;
                            let ptr68 = vec68.as_ptr() as i32;
                            let len68 = vec68.len() as i32;
                            *((ptr0 + 48) as *mut i32) = len68;
                            *((ptr0 + 44) as *mut i32) = ptr68;
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeU8(e) => {
                        *((ptr0 + 32) as *mut u8) = (8i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            *((ptr0 + 41) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeU16(e) => {
                        *((ptr0 + 32) as *mut u8) = (9i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            *((ptr0 + 42) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeU32(e) => {
                        *((ptr0 + 32) as *mut u8) = (10i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(e);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeU64(e) => {
                        *((ptr0 + 32) as *mut u8) = (11i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(e);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeI8(e) => {
                        *((ptr0 + 32) as *mut u8) = (12i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            *((ptr0 + 41) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeI16(e) => {
                        *((ptr0 + 32) as *mut u8) = (13i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            *((ptr0 + 42) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeI32(e) => {
                        *((ptr0 + 32) as *mut u8) = (14i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(e);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeI64(e) => {
                        *((ptr0 + 32) as *mut u8) = (15i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(e);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeVec2(e) => {
                        *((ptr0 + 32) as *mut u8) = (16i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Vec2{ x:x69, y:y69, } = e;
                            *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x69);
                            *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y69);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeVec3(e) => {
                        *((ptr0 + 32) as *mut u8) = (17i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Vec3{ x:x70, y:y70, z:z70, } = e;
                            *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x70);
                            *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y70);
                            *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z70);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeVec4(e) => {
                        *((ptr0 + 32) as *mut u8) = (18i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Vec4{ x:x71, y:y71, z:z71, w:w71, } = e;
                            *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x71);
                            *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y71);
                            *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z71);
                            *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w71);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeUvec2(e) => {
                        *((ptr0 + 32) as *mut u8) = (19i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Uvec2{ x:x72, y:y72, } = e;
                            *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x72);
                            *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y72);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeUvec3(e) => {
                        *((ptr0 + 32) as *mut u8) = (20i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Uvec3{ x:x73, y:y73, z:z73, } = e;
                            *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x73);
                            *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y73);
                            *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z73);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeUvec4(e) => {
                        *((ptr0 + 32) as *mut u8) = (21i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Uvec4{ x:x74, y:y74, z:z74, w:w74, } = e;
                            *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x74);
                            *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y74);
                            *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z74);
                            *((ptr0 + 56) as *mut i32) = wit_bindgen::rt::as_i32(w74);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeIvec2(e) => {
                        *((ptr0 + 32) as *mut u8) = (22i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Ivec2{ x:x75, y:y75, } = e;
                            *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x75);
                            *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y75);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeIvec3(e) => {
                        *((ptr0 + 32) as *mut u8) = (23i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Ivec3{ x:x76, y:y76, z:z76, } = e;
                            *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x76);
                            *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y76);
                            *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z76);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeIvec4(e) => {
                        *((ptr0 + 32) as *mut u8) = (24i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Ivec4{ x:x77, y:y77, z:z77, w:w77, } = e;
                            *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x77);
                            *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y77);
                            *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z77);
                            *((ptr0 + 56) as *mut i32) = wit_bindgen::rt::as_i32(w77);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeDuration(e) => {
                        *((ptr0 + 32) as *mut u8) = (25i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Duration{ seconds:seconds78, nanoseconds:nanoseconds78, } = e;
                            *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(seconds78);
                            *((ptr0 + 56) as *mut i32) = wit_bindgen::rt::as_i32(nanoseconds78);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeProceduralMeshHandle(e) => {
                        *((ptr0 + 32) as *mut u8) = (26i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::client_mesh::Handle{ ulid:ulid79, } = e;
                            let (t80_0, t80_1, ) = ulid79;
                            *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t80_0);
                            *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t80_1);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeProceduralTextureHandle(e) => {
                        *((ptr0 + 32) as *mut u8) = (27i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid81, } = e;
                            let (t82_0, t82_1, ) = ulid81;
                            *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t82_0);
                            *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t82_1);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeProceduralSamplerHandle(e) => {
                        *((ptr0 + 32) as *mut u8) = (28i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::client_sampler::Handle{ ulid:ulid83, } = e;
                            let (t84_0, t84_1, ) = ulid83;
                            *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t84_0);
                            *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t84_1);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeProceduralMaterialHandle(e) => {
                        *((ptr0 + 32) as *mut u8) = (29i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::client_material::Handle{ ulid:ulid85, } = e;
                            let (t86_0, t86_1, ) = ulid85;
                            *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t86_0);
                            *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t86_1);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                    };
                    
                  },
                };
                
                #[link(wasm_import_module = "ambient:bindings/component")]
                extern "C" {
                  #[cfg_attr(target_arch = "wasm32", link_name = "add-component")]
                  #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_add-component")]
                  fn wit_import(
                  _: i32, );
                }
                wit_import(ptr0);
                for (ptr, layout) in cleanup_list {
                  
                  if layout.size() != 0 {
                    
                    alloc::dealloc(ptr, layout);
                    
                  }
                  
                }
              }
            }
            #[allow(clippy::all)]
            pub fn add_components(entity: EntityId,data: &Entity,){
              
              #[allow(unused_imports)]
              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
              unsafe {
                let mut cleanup_list = Vec::new();
                let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                let vec87 = data;
                let len87 = vec87.len() as i32;
                let layout87 = alloc::Layout::from_size_align_unchecked(vec87.len() * 96, 8);
                let result87 = if layout87.size() != 0
                {
                  let ptr = alloc::alloc(layout87);
                  if ptr.is_null()
                  {
                    alloc::handle_alloc_error(layout87);
                  }
                  ptr
                }else {
                  ::core::ptr::null_mut()
                };
                for (i, e) in vec87.into_iter().enumerate() {
                  let base = result87 as i32 + (i as i32) * 96;
                  {
                    let (t1_0, t1_1, ) = e;
                    *((base + 0) as *mut i32) = wit_bindgen::rt::as_i32(t1_0);
                    match t1_1 {
                      Value::TypeEmpty(e) => {
                        *((base + 8) as *mut u8) = (0i32) as u8;
                        let super::super::super::ambient::bindings::types::Empty{ dummy:dummy2, } = e;
                        *((base + 16) as *mut u8) = (wit_bindgen::rt::as_i32(dummy2)) as u8;
                        
                      },
                      Value::TypeBool(e) => {
                        *((base + 8) as *mut u8) = (1i32) as u8;
                        *((base + 16) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                        
                      },
                      Value::TypeEntityId(e) => {
                        *((base + 8) as *mut u8) = (2i32) as u8;
                        let super::super::super::ambient::bindings::types::EntityId{ id0:id03, id1:id13, } = e;
                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(id03);
                        *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(id13);
                        
                      },
                      Value::TypeF32(e) => {
                        *((base + 8) as *mut u8) = (3i32) as u8;
                        *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(e);
                        
                      },
                      Value::TypeF64(e) => {
                        *((base + 8) as *mut u8) = (4i32) as u8;
                        *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                        
                      },
                      Value::TypeMat4(e) => {
                        *((base + 8) as *mut u8) = (5i32) as u8;
                        let super::super::super::ambient::bindings::types::Mat4{ x:x4, y:y4, z:z4, w:w4, } = e;
                        let super::super::super::ambient::bindings::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = x4;
                        *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x5);
                        *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y5);
                        *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z5);
                        *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w5);
                        let super::super::super::ambient::bindings::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = y4;
                        *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(x6);
                        *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(y6);
                        *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(z6);
                        *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(w6);
                        let super::super::super::ambient::bindings::types::Vec4{ x:x7, y:y7, z:z7, w:w7, } = z4;
                        *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(x7);
                        *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(y7);
                        *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(z7);
                        *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(w7);
                        let super::super::super::ambient::bindings::types::Vec4{ x:x8, y:y8, z:z8, w:w8, } = w4;
                        *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(x8);
                        *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(y8);
                        *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(z8);
                        *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(w8);
                        
                      },
                      Value::TypeQuat(e) => {
                        *((base + 8) as *mut u8) = (6i32) as u8;
                        let super::super::super::ambient::bindings::types::Quat{ x:x9, y:y9, z:z9, w:w9, } = e;
                        *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x9);
                        *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y9);
                        *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z9);
                        *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w9);
                        
                      },
                      Value::TypeString(e) => {
                        *((base + 8) as *mut u8) = (7i32) as u8;
                        let vec10 = e;
                        let ptr10 = vec10.as_ptr() as i32;
                        let len10 = vec10.len() as i32;
                        *((base + 20) as *mut i32) = len10;
                        *((base + 16) as *mut i32) = ptr10;
                        
                      },
                      Value::TypeU8(e) => {
                        *((base + 8) as *mut u8) = (8i32) as u8;
                        *((base + 16) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                        
                      },
                      Value::TypeU16(e) => {
                        *((base + 8) as *mut u8) = (9i32) as u8;
                        *((base + 16) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                        
                      },
                      Value::TypeU32(e) => {
                        *((base + 8) as *mut u8) = (10i32) as u8;
                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                        
                      },
                      Value::TypeU64(e) => {
                        *((base + 8) as *mut u8) = (11i32) as u8;
                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                        
                      },
                      Value::TypeI8(e) => {
                        *((base + 8) as *mut u8) = (12i32) as u8;
                        *((base + 16) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                        
                      },
                      Value::TypeI16(e) => {
                        *((base + 8) as *mut u8) = (13i32) as u8;
                        *((base + 16) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                        
                      },
                      Value::TypeI32(e) => {
                        *((base + 8) as *mut u8) = (14i32) as u8;
                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                        
                      },
                      Value::TypeI64(e) => {
                        *((base + 8) as *mut u8) = (15i32) as u8;
                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                        
                      },
                      Value::TypeVec2(e) => {
                        *((base + 8) as *mut u8) = (16i32) as u8;
                        let super::super::super::ambient::bindings::types::Vec2{ x:x11, y:y11, } = e;
                        *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x11);
                        *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y11);
                        
                      },
                      Value::TypeVec3(e) => {
                        *((base + 8) as *mut u8) = (17i32) as u8;
                        let super::super::super::ambient::bindings::types::Vec3{ x:x12, y:y12, z:z12, } = e;
                        *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x12);
                        *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y12);
                        *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z12);
                        
                      },
                      Value::TypeVec4(e) => {
                        *((base + 8) as *mut u8) = (18i32) as u8;
                        let super::super::super::ambient::bindings::types::Vec4{ x:x13, y:y13, z:z13, w:w13, } = e;
                        *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x13);
                        *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y13);
                        *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z13);
                        *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w13);
                        
                      },
                      Value::TypeUvec2(e) => {
                        *((base + 8) as *mut u8) = (19i32) as u8;
                        let super::super::super::ambient::bindings::types::Uvec2{ x:x14, y:y14, } = e;
                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x14);
                        *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y14);
                        
                      },
                      Value::TypeUvec3(e) => {
                        *((base + 8) as *mut u8) = (20i32) as u8;
                        let super::super::super::ambient::bindings::types::Uvec3{ x:x15, y:y15, z:z15, } = e;
                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x15);
                        *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y15);
                        *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z15);
                        
                      },
                      Value::TypeUvec4(e) => {
                        *((base + 8) as *mut u8) = (21i32) as u8;
                        let super::super::super::ambient::bindings::types::Uvec4{ x:x16, y:y16, z:z16, w:w16, } = e;
                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x16);
                        *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y16);
                        *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z16);
                        *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(w16);
                        
                      },
                      Value::TypeIvec2(e) => {
                        *((base + 8) as *mut u8) = (22i32) as u8;
                        let super::super::super::ambient::bindings::types::Ivec2{ x:x17, y:y17, } = e;
                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x17);
                        *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y17);
                        
                      },
                      Value::TypeIvec3(e) => {
                        *((base + 8) as *mut u8) = (23i32) as u8;
                        let super::super::super::ambient::bindings::types::Ivec3{ x:x18, y:y18, z:z18, } = e;
                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x18);
                        *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y18);
                        *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z18);
                        
                      },
                      Value::TypeIvec4(e) => {
                        *((base + 8) as *mut u8) = (24i32) as u8;
                        let super::super::super::ambient::bindings::types::Ivec4{ x:x19, y:y19, z:z19, w:w19, } = e;
                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x19);
                        *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y19);
                        *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z19);
                        *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(w19);
                        
                      },
                      Value::TypeDuration(e) => {
                        *((base + 8) as *mut u8) = (25i32) as u8;
                        let super::super::super::ambient::bindings::types::Duration{ seconds:seconds20, nanoseconds:nanoseconds20, } = e;
                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(seconds20);
                        *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(nanoseconds20);
                        
                      },
                      Value::TypeProceduralMeshHandle(e) => {
                        *((base + 8) as *mut u8) = (26i32) as u8;
                        let super::super::super::ambient::bindings::client_mesh::Handle{ ulid:ulid21, } = e;
                        let (t22_0, t22_1, ) = ulid21;
                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t22_0);
                        *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t22_1);
                        
                      },
                      Value::TypeProceduralTextureHandle(e) => {
                        *((base + 8) as *mut u8) = (27i32) as u8;
                        let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid23, } = e;
                        let (t24_0, t24_1, ) = ulid23;
                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t24_0);
                        *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t24_1);
                        
                      },
                      Value::TypeProceduralSamplerHandle(e) => {
                        *((base + 8) as *mut u8) = (28i32) as u8;
                        let super::super::super::ambient::bindings::client_sampler::Handle{ ulid:ulid25, } = e;
                        let (t26_0, t26_1, ) = ulid25;
                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t26_0);
                        *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t26_1);
                        
                      },
                      Value::TypeProceduralMaterialHandle(e) => {
                        *((base + 8) as *mut u8) = (29i32) as u8;
                        let super::super::super::ambient::bindings::client_material::Handle{ ulid:ulid27, } = e;
                        let (t28_0, t28_1, ) = ulid27;
                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t28_0);
                        *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t28_1);
                        
                      },
                      Value::TypeVec(e) => {
                        *((base + 8) as *mut u8) = (30i32) as u8;
                        match e {
                          VecValue::TypeEmpty(e) => {
                            *((base + 16) as *mut u8) = (0i32) as u8;
                            let vec29 = e;
                            let ptr29 = vec29.as_ptr() as i32;
                            let len29 = vec29.len() as i32;
                            *((base + 24) as *mut i32) = len29;
                            *((base + 20) as *mut i32) = ptr29;
                            
                          },
                          VecValue::TypeBool(e) => {
                            *((base + 16) as *mut u8) = (1i32) as u8;
                            let vec30 = e;
                            let len30 = vec30.len() as i32;
                            let layout30 = alloc::Layout::from_size_align_unchecked(vec30.len() * 1, 1);
                            let result30 = if layout30.size() != 0
                            {
                              let ptr = alloc::alloc(layout30);
                              if ptr.is_null()
                              {
                                alloc::handle_alloc_error(layout30);
                              }
                              ptr
                            }else {
                              ::core::ptr::null_mut()
                            };
                            for (i, e) in vec30.into_iter().enumerate() {
                              let base = result30 as i32 + (i as i32) * 1;
                              {
                                *((base + 0) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                
                              }}
                              *((base + 24) as *mut i32) = len30;
                              *((base + 20) as *mut i32) = result30 as i32;
                              cleanup_list.extend_from_slice(&[(result30, layout30),]);
                              
                            },
                            VecValue::TypeEntityId(e) => {
                              *((base + 16) as *mut u8) = (2i32) as u8;
                              let vec31 = e;
                              let ptr31 = vec31.as_ptr() as i32;
                              let len31 = vec31.len() as i32;
                              *((base + 24) as *mut i32) = len31;
                              *((base + 20) as *mut i32) = ptr31;
                              
                            },
                            VecValue::TypeF32(e) => {
                              *((base + 16) as *mut u8) = (3i32) as u8;
                              let vec32 = e;
                              let ptr32 = vec32.as_ptr() as i32;
                              let len32 = vec32.len() as i32;
                              *((base + 24) as *mut i32) = len32;
                              *((base + 20) as *mut i32) = ptr32;
                              
                            },
                            VecValue::TypeF64(e) => {
                              *((base + 16) as *mut u8) = (4i32) as u8;
                              let vec33 = e;
                              let ptr33 = vec33.as_ptr() as i32;
                              let len33 = vec33.len() as i32;
                              *((base + 24) as *mut i32) = len33;
                              *((base + 20) as *mut i32) = ptr33;
                              
                            },
                            VecValue::TypeMat4(e) => {
                              *((base + 16) as *mut u8) = (5i32) as u8;
                              let vec34 = e;
                              let ptr34 = vec34.as_ptr() as i32;
                              let len34 = vec34.len() as i32;
                              *((base + 24) as *mut i32) = len34;
                              *((base + 20) as *mut i32) = ptr34;
                              
                            },
                            VecValue::TypeQuat(e) => {
                              *((base + 16) as *mut u8) = (6i32) as u8;
                              let vec35 = e;
                              let ptr35 = vec35.as_ptr() as i32;
                              let len35 = vec35.len() as i32;
                              *((base + 24) as *mut i32) = len35;
                              *((base + 20) as *mut i32) = ptr35;
                              
                            },
                            VecValue::TypeString(e) => {
                              *((base + 16) as *mut u8) = (7i32) as u8;
                              let vec37 = e;
                              let len37 = vec37.len() as i32;
                              let layout37 = alloc::Layout::from_size_align_unchecked(vec37.len() * 8, 4);
                              let result37 = if layout37.size() != 0
                              {
                                let ptr = alloc::alloc(layout37);
                                if ptr.is_null()
                                {
                                  alloc::handle_alloc_error(layout37);
                                }
                                ptr
                              }else {
                                ::core::ptr::null_mut()
                              };
                              for (i, e) in vec37.into_iter().enumerate() {
                                let base = result37 as i32 + (i as i32) * 8;
                                {
                                  let vec36 = e;
                                  let ptr36 = vec36.as_ptr() as i32;
                                  let len36 = vec36.len() as i32;
                                  *((base + 4) as *mut i32) = len36;
                                  *((base + 0) as *mut i32) = ptr36;
                                  
                                }}
                                *((base + 24) as *mut i32) = len37;
                                *((base + 20) as *mut i32) = result37 as i32;
                                cleanup_list.extend_from_slice(&[(result37, layout37),]);
                                
                              },
                              VecValue::TypeU8(e) => {
                                *((base + 16) as *mut u8) = (8i32) as u8;
                                let vec38 = e;
                                let ptr38 = vec38.as_ptr() as i32;
                                let len38 = vec38.len() as i32;
                                *((base + 24) as *mut i32) = len38;
                                *((base + 20) as *mut i32) = ptr38;
                                
                              },
                              VecValue::TypeU16(e) => {
                                *((base + 16) as *mut u8) = (9i32) as u8;
                                let vec39 = e;
                                let ptr39 = vec39.as_ptr() as i32;
                                let len39 = vec39.len() as i32;
                                *((base + 24) as *mut i32) = len39;
                                *((base + 20) as *mut i32) = ptr39;
                                
                              },
                              VecValue::TypeU32(e) => {
                                *((base + 16) as *mut u8) = (10i32) as u8;
                                let vec40 = e;
                                let ptr40 = vec40.as_ptr() as i32;
                                let len40 = vec40.len() as i32;
                                *((base + 24) as *mut i32) = len40;
                                *((base + 20) as *mut i32) = ptr40;
                                
                              },
                              VecValue::TypeU64(e) => {
                                *((base + 16) as *mut u8) = (11i32) as u8;
                                let vec41 = e;
                                let ptr41 = vec41.as_ptr() as i32;
                                let len41 = vec41.len() as i32;
                                *((base + 24) as *mut i32) = len41;
                                *((base + 20) as *mut i32) = ptr41;
                                
                              },
                              VecValue::TypeI8(e) => {
                                *((base + 16) as *mut u8) = (12i32) as u8;
                                let vec42 = e;
                                let ptr42 = vec42.as_ptr() as i32;
                                let len42 = vec42.len() as i32;
                                *((base + 24) as *mut i32) = len42;
                                *((base + 20) as *mut i32) = ptr42;
                                
                              },
                              VecValue::TypeI16(e) => {
                                *((base + 16) as *mut u8) = (13i32) as u8;
                                let vec43 = e;
                                let ptr43 = vec43.as_ptr() as i32;
                                let len43 = vec43.len() as i32;
                                *((base + 24) as *mut i32) = len43;
                                *((base + 20) as *mut i32) = ptr43;
                                
                              },
                              VecValue::TypeI32(e) => {
                                *((base + 16) as *mut u8) = (14i32) as u8;
                                let vec44 = e;
                                let ptr44 = vec44.as_ptr() as i32;
                                let len44 = vec44.len() as i32;
                                *((base + 24) as *mut i32) = len44;
                                *((base + 20) as *mut i32) = ptr44;
                                
                              },
                              VecValue::TypeI64(e) => {
                                *((base + 16) as *mut u8) = (15i32) as u8;
                                let vec45 = e;
                                let ptr45 = vec45.as_ptr() as i32;
                                let len45 = vec45.len() as i32;
                                *((base + 24) as *mut i32) = len45;
                                *((base + 20) as *mut i32) = ptr45;
                                
                              },
                              VecValue::TypeVec2(e) => {
                                *((base + 16) as *mut u8) = (16i32) as u8;
                                let vec46 = e;
                                let ptr46 = vec46.as_ptr() as i32;
                                let len46 = vec46.len() as i32;
                                *((base + 24) as *mut i32) = len46;
                                *((base + 20) as *mut i32) = ptr46;
                                
                              },
                              VecValue::TypeVec3(e) => {
                                *((base + 16) as *mut u8) = (17i32) as u8;
                                let vec47 = e;
                                let ptr47 = vec47.as_ptr() as i32;
                                let len47 = vec47.len() as i32;
                                *((base + 24) as *mut i32) = len47;
                                *((base + 20) as *mut i32) = ptr47;
                                
                              },
                              VecValue::TypeVec4(e) => {
                                *((base + 16) as *mut u8) = (18i32) as u8;
                                let vec48 = e;
                                let ptr48 = vec48.as_ptr() as i32;
                                let len48 = vec48.len() as i32;
                                *((base + 24) as *mut i32) = len48;
                                *((base + 20) as *mut i32) = ptr48;
                                
                              },
                              VecValue::TypeUvec2(e) => {
                                *((base + 16) as *mut u8) = (19i32) as u8;
                                let vec49 = e;
                                let ptr49 = vec49.as_ptr() as i32;
                                let len49 = vec49.len() as i32;
                                *((base + 24) as *mut i32) = len49;
                                *((base + 20) as *mut i32) = ptr49;
                                
                              },
                              VecValue::TypeUvec3(e) => {
                                *((base + 16) as *mut u8) = (20i32) as u8;
                                let vec50 = e;
                                let ptr50 = vec50.as_ptr() as i32;
                                let len50 = vec50.len() as i32;
                                *((base + 24) as *mut i32) = len50;
                                *((base + 20) as *mut i32) = ptr50;
                                
                              },
                              VecValue::TypeUvec4(e) => {
                                *((base + 16) as *mut u8) = (21i32) as u8;
                                let vec51 = e;
                                let ptr51 = vec51.as_ptr() as i32;
                                let len51 = vec51.len() as i32;
                                *((base + 24) as *mut i32) = len51;
                                *((base + 20) as *mut i32) = ptr51;
                                
                              },
                              VecValue::TypeIvec2(e) => {
                                *((base + 16) as *mut u8) = (22i32) as u8;
                                let vec52 = e;
                                let ptr52 = vec52.as_ptr() as i32;
                                let len52 = vec52.len() as i32;
                                *((base + 24) as *mut i32) = len52;
                                *((base + 20) as *mut i32) = ptr52;
                                
                              },
                              VecValue::TypeIvec3(e) => {
                                *((base + 16) as *mut u8) = (23i32) as u8;
                                let vec53 = e;
                                let ptr53 = vec53.as_ptr() as i32;
                                let len53 = vec53.len() as i32;
                                *((base + 24) as *mut i32) = len53;
                                *((base + 20) as *mut i32) = ptr53;
                                
                              },
                              VecValue::TypeIvec4(e) => {
                                *((base + 16) as *mut u8) = (24i32) as u8;
                                let vec54 = e;
                                let ptr54 = vec54.as_ptr() as i32;
                                let len54 = vec54.len() as i32;
                                *((base + 24) as *mut i32) = len54;
                                *((base + 20) as *mut i32) = ptr54;
                                
                              },
                              VecValue::TypeDuration(e) => {
                                *((base + 16) as *mut u8) = (25i32) as u8;
                                let vec55 = e;
                                let ptr55 = vec55.as_ptr() as i32;
                                let len55 = vec55.len() as i32;
                                *((base + 24) as *mut i32) = len55;
                                *((base + 20) as *mut i32) = ptr55;
                                
                              },
                              VecValue::TypeProceduralMeshHandle(e) => {
                                *((base + 16) as *mut u8) = (26i32) as u8;
                                let vec56 = e;
                                let ptr56 = vec56.as_ptr() as i32;
                                let len56 = vec56.len() as i32;
                                *((base + 24) as *mut i32) = len56;
                                *((base + 20) as *mut i32) = ptr56;
                                
                              },
                              VecValue::TypeProceduralTextureHandle(e) => {
                                *((base + 16) as *mut u8) = (27i32) as u8;
                                let vec57 = e;
                                let ptr57 = vec57.as_ptr() as i32;
                                let len57 = vec57.len() as i32;
                                *((base + 24) as *mut i32) = len57;
                                *((base + 20) as *mut i32) = ptr57;
                                
                              },
                              VecValue::TypeProceduralSamplerHandle(e) => {
                                *((base + 16) as *mut u8) = (28i32) as u8;
                                let vec58 = e;
                                let ptr58 = vec58.as_ptr() as i32;
                                let len58 = vec58.len() as i32;
                                *((base + 24) as *mut i32) = len58;
                                *((base + 20) as *mut i32) = ptr58;
                                
                              },
                              VecValue::TypeProceduralMaterialHandle(e) => {
                                *((base + 16) as *mut u8) = (29i32) as u8;
                                let vec59 = e;
                                let ptr59 = vec59.as_ptr() as i32;
                                let len59 = vec59.len() as i32;
                                *((base + 24) as *mut i32) = len59;
                                *((base + 20) as *mut i32) = ptr59;
                                
                              },
                            };
                            
                          },
                          Value::TypeOption(e) => {
                            *((base + 8) as *mut u8) = (31i32) as u8;
                            match e {
                              OptionValue::TypeEmpty(e) => {
                                *((base + 16) as *mut u8) = (0i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Empty{ dummy:dummy60, } = e;
                                    *((base + 25) as *mut u8) = (wit_bindgen::rt::as_i32(dummy60)) as u8;
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeBool(e) => {
                                *((base + 16) as *mut u8) = (1i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    *((base + 25) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeEntityId(e) => {
                                *((base + 16) as *mut u8) = (2i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::EntityId{ id0:id061, id1:id161, } = e;
                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(id061);
                                    *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(id161);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeF32(e) => {
                                *((base + 16) as *mut u8) = (3i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(e);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeF64(e) => {
                                *((base + 16) as *mut u8) = (4i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeMat4(e) => {
                                *((base + 16) as *mut u8) = (5i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Mat4{ x:x62, y:y62, z:z62, w:w62, } = e;
                                    let super::super::super::ambient::bindings::types::Vec4{ x:x63, y:y63, z:z63, w:w63, } = x62;
                                    *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x63);
                                    *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y63);
                                    *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z63);
                                    *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w63);
                                    let super::super::super::ambient::bindings::types::Vec4{ x:x64, y:y64, z:z64, w:w64, } = y62;
                                    *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(x64);
                                    *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(y64);
                                    *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(z64);
                                    *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(w64);
                                    let super::super::super::ambient::bindings::types::Vec4{ x:x65, y:y65, z:z65, w:w65, } = z62;
                                    *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(x65);
                                    *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(y65);
                                    *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(z65);
                                    *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(w65);
                                    let super::super::super::ambient::bindings::types::Vec4{ x:x66, y:y66, z:z66, w:w66, } = w62;
                                    *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(x66);
                                    *((base + 80) as *mut f32) = wit_bindgen::rt::as_f32(y66);
                                    *((base + 84) as *mut f32) = wit_bindgen::rt::as_f32(z66);
                                    *((base + 88) as *mut f32) = wit_bindgen::rt::as_f32(w66);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeQuat(e) => {
                                *((base + 16) as *mut u8) = (6i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Quat{ x:x67, y:y67, z:z67, w:w67, } = e;
                                    *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x67);
                                    *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y67);
                                    *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z67);
                                    *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w67);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeString(e) => {
                                *((base + 16) as *mut u8) = (7i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let vec68 = e;
                                    let ptr68 = vec68.as_ptr() as i32;
                                    let len68 = vec68.len() as i32;
                                    *((base + 32) as *mut i32) = len68;
                                    *((base + 28) as *mut i32) = ptr68;
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeU8(e) => {
                                *((base + 16) as *mut u8) = (8i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    *((base + 25) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeU16(e) => {
                                *((base + 16) as *mut u8) = (9i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    *((base + 26) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeU32(e) => {
                                *((base + 16) as *mut u8) = (10i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeU64(e) => {
                                *((base + 16) as *mut u8) = (11i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeI8(e) => {
                                *((base + 16) as *mut u8) = (12i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    *((base + 25) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeI16(e) => {
                                *((base + 16) as *mut u8) = (13i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    *((base + 26) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeI32(e) => {
                                *((base + 16) as *mut u8) = (14i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeI64(e) => {
                                *((base + 16) as *mut u8) = (15i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeVec2(e) => {
                                *((base + 16) as *mut u8) = (16i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Vec2{ x:x69, y:y69, } = e;
                                    *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x69);
                                    *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y69);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeVec3(e) => {
                                *((base + 16) as *mut u8) = (17i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Vec3{ x:x70, y:y70, z:z70, } = e;
                                    *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x70);
                                    *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y70);
                                    *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z70);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeVec4(e) => {
                                *((base + 16) as *mut u8) = (18i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Vec4{ x:x71, y:y71, z:z71, w:w71, } = e;
                                    *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x71);
                                    *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y71);
                                    *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z71);
                                    *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w71);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeUvec2(e) => {
                                *((base + 16) as *mut u8) = (19i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Uvec2{ x:x72, y:y72, } = e;
                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x72);
                                    *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y72);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeUvec3(e) => {
                                *((base + 16) as *mut u8) = (20i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Uvec3{ x:x73, y:y73, z:z73, } = e;
                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x73);
                                    *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y73);
                                    *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z73);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeUvec4(e) => {
                                *((base + 16) as *mut u8) = (21i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Uvec4{ x:x74, y:y74, z:z74, w:w74, } = e;
                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x74);
                                    *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y74);
                                    *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z74);
                                    *((base + 40) as *mut i32) = wit_bindgen::rt::as_i32(w74);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeIvec2(e) => {
                                *((base + 16) as *mut u8) = (22i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Ivec2{ x:x75, y:y75, } = e;
                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x75);
                                    *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y75);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeIvec3(e) => {
                                *((base + 16) as *mut u8) = (23i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Ivec3{ x:x76, y:y76, z:z76, } = e;
                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x76);
                                    *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y76);
                                    *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z76);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeIvec4(e) => {
                                *((base + 16) as *mut u8) = (24i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Ivec4{ x:x77, y:y77, z:z77, w:w77, } = e;
                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x77);
                                    *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y77);
                                    *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z77);
                                    *((base + 40) as *mut i32) = wit_bindgen::rt::as_i32(w77);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeDuration(e) => {
                                *((base + 16) as *mut u8) = (25i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Duration{ seconds:seconds78, nanoseconds:nanoseconds78, } = e;
                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(seconds78);
                                    *((base + 40) as *mut i32) = wit_bindgen::rt::as_i32(nanoseconds78);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeProceduralMeshHandle(e) => {
                                *((base + 16) as *mut u8) = (26i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::client_mesh::Handle{ ulid:ulid79, } = e;
                                    let (t80_0, t80_1, ) = ulid79;
                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t80_0);
                                    *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t80_1);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeProceduralTextureHandle(e) => {
                                *((base + 16) as *mut u8) = (27i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid81, } = e;
                                    let (t82_0, t82_1, ) = ulid81;
                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t82_0);
                                    *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t82_1);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeProceduralSamplerHandle(e) => {
                                *((base + 16) as *mut u8) = (28i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::client_sampler::Handle{ ulid:ulid83, } = e;
                                    let (t84_0, t84_1, ) = ulid83;
                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t84_0);
                                    *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t84_1);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeProceduralMaterialHandle(e) => {
                                *((base + 16) as *mut u8) = (29i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::client_material::Handle{ ulid:ulid85, } = e;
                                    let (t86_0, t86_1, ) = ulid85;
                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t86_0);
                                    *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t86_1);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                            };
                            
                          },
                        };
                        
                      }}
                      
                      #[link(wasm_import_module = "ambient:bindings/component")]
                      extern "C" {
                        #[cfg_attr(target_arch = "wasm32", link_name = "add-components")]
                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_add-components")]
                        fn wit_import(
                        _: i64, _: i64, _: i32, _: i32, );
                      }
                      wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), result87 as i32, len87);
                      if layout87.size() != 0 {
                        alloc::dealloc(result87, layout87);
                      }
                      for (ptr, layout) in cleanup_list {
                        
                        if layout.size() != 0 {
                          
                          alloc::dealloc(ptr, layout);
                          
                        }
                        
                      }
                    }
                  }
                  #[allow(clippy::all)]
                  pub fn set_component(entity: EntityId,index: u32,value: &Value,){
                    
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    unsafe {
                      let mut cleanup_list = Vec::new();
                      
                      #[repr(align(8))]
                      struct RetArea([u8; 112]);
                      let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                      let ptr0 = ret_area.as_mut_ptr() as i32;let super::super::super::ambient::bindings::types::EntityId{ id0:id01, id1:id11, } = entity;
                      *((ptr0 + 0) as *mut i64) = wit_bindgen::rt::as_i64(id01);
                      *((ptr0 + 8) as *mut i64) = wit_bindgen::rt::as_i64(id11);
                      *((ptr0 + 16) as *mut i32) = wit_bindgen::rt::as_i32(index);
                      match value {
                        Value::TypeEmpty(e) => {
                          *((ptr0 + 24) as *mut u8) = (0i32) as u8;
                          let super::super::super::ambient::bindings::types::Empty{ dummy:dummy2, } = e;
                          *((ptr0 + 32) as *mut u8) = (wit_bindgen::rt::as_i32(dummy2)) as u8;
                          
                        },
                        Value::TypeBool(e) => {
                          *((ptr0 + 24) as *mut u8) = (1i32) as u8;
                          *((ptr0 + 32) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                          
                        },
                        Value::TypeEntityId(e) => {
                          *((ptr0 + 24) as *mut u8) = (2i32) as u8;
                          let super::super::super::ambient::bindings::types::EntityId{ id0:id03, id1:id13, } = e;
                          *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(id03);
                          *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(id13);
                          
                        },
                        Value::TypeF32(e) => {
                          *((ptr0 + 24) as *mut u8) = (3i32) as u8;
                          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(e);
                          
                        },
                        Value::TypeF64(e) => {
                          *((ptr0 + 24) as *mut u8) = (4i32) as u8;
                          *((ptr0 + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                          
                        },
                        Value::TypeMat4(e) => {
                          *((ptr0 + 24) as *mut u8) = (5i32) as u8;
                          let super::super::super::ambient::bindings::types::Mat4{ x:x4, y:y4, z:z4, w:w4, } = e;
                          let super::super::super::ambient::bindings::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = x4;
                          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x5);
                          *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y5);
                          *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z5);
                          *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w5);
                          let super::super::super::ambient::bindings::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = y4;
                          *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(x6);
                          *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(y6);
                          *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(z6);
                          *((ptr0 + 60) as *mut f32) = wit_bindgen::rt::as_f32(w6);
                          let super::super::super::ambient::bindings::types::Vec4{ x:x7, y:y7, z:z7, w:w7, } = z4;
                          *((ptr0 + 64) as *mut f32) = wit_bindgen::rt::as_f32(x7);
                          *((ptr0 + 68) as *mut f32) = wit_bindgen::rt::as_f32(y7);
                          *((ptr0 + 72) as *mut f32) = wit_bindgen::rt::as_f32(z7);
                          *((ptr0 + 76) as *mut f32) = wit_bindgen::rt::as_f32(w7);
                          let super::super::super::ambient::bindings::types::Vec4{ x:x8, y:y8, z:z8, w:w8, } = w4;
                          *((ptr0 + 80) as *mut f32) = wit_bindgen::rt::as_f32(x8);
                          *((ptr0 + 84) as *mut f32) = wit_bindgen::rt::as_f32(y8);
                          *((ptr0 + 88) as *mut f32) = wit_bindgen::rt::as_f32(z8);
                          *((ptr0 + 92) as *mut f32) = wit_bindgen::rt::as_f32(w8);
                          
                        },
                        Value::TypeQuat(e) => {
                          *((ptr0 + 24) as *mut u8) = (6i32) as u8;
                          let super::super::super::ambient::bindings::types::Quat{ x:x9, y:y9, z:z9, w:w9, } = e;
                          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x9);
                          *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y9);
                          *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z9);
                          *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w9);
                          
                        },
                        Value::TypeString(e) => {
                          *((ptr0 + 24) as *mut u8) = (7i32) as u8;
                          let vec10 = e;
                          let ptr10 = vec10.as_ptr() as i32;
                          let len10 = vec10.len() as i32;
                          *((ptr0 + 36) as *mut i32) = len10;
                          *((ptr0 + 32) as *mut i32) = ptr10;
                          
                        },
                        Value::TypeU8(e) => {
                          *((ptr0 + 24) as *mut u8) = (8i32) as u8;
                          *((ptr0 + 32) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                          
                        },
                        Value::TypeU16(e) => {
                          *((ptr0 + 24) as *mut u8) = (9i32) as u8;
                          *((ptr0 + 32) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                          
                        },
                        Value::TypeU32(e) => {
                          *((ptr0 + 24) as *mut u8) = (10i32) as u8;
                          *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(e);
                          
                        },
                        Value::TypeU64(e) => {
                          *((ptr0 + 24) as *mut u8) = (11i32) as u8;
                          *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                          
                        },
                        Value::TypeI8(e) => {
                          *((ptr0 + 24) as *mut u8) = (12i32) as u8;
                          *((ptr0 + 32) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                          
                        },
                        Value::TypeI16(e) => {
                          *((ptr0 + 24) as *mut u8) = (13i32) as u8;
                          *((ptr0 + 32) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                          
                        },
                        Value::TypeI32(e) => {
                          *((ptr0 + 24) as *mut u8) = (14i32) as u8;
                          *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(e);
                          
                        },
                        Value::TypeI64(e) => {
                          *((ptr0 + 24) as *mut u8) = (15i32) as u8;
                          *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                          
                        },
                        Value::TypeVec2(e) => {
                          *((ptr0 + 24) as *mut u8) = (16i32) as u8;
                          let super::super::super::ambient::bindings::types::Vec2{ x:x11, y:y11, } = e;
                          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x11);
                          *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y11);
                          
                        },
                        Value::TypeVec3(e) => {
                          *((ptr0 + 24) as *mut u8) = (17i32) as u8;
                          let super::super::super::ambient::bindings::types::Vec3{ x:x12, y:y12, z:z12, } = e;
                          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x12);
                          *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y12);
                          *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z12);
                          
                        },
                        Value::TypeVec4(e) => {
                          *((ptr0 + 24) as *mut u8) = (18i32) as u8;
                          let super::super::super::ambient::bindings::types::Vec4{ x:x13, y:y13, z:z13, w:w13, } = e;
                          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x13);
                          *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y13);
                          *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z13);
                          *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w13);
                          
                        },
                        Value::TypeUvec2(e) => {
                          *((ptr0 + 24) as *mut u8) = (19i32) as u8;
                          let super::super::super::ambient::bindings::types::Uvec2{ x:x14, y:y14, } = e;
                          *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x14);
                          *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y14);
                          
                        },
                        Value::TypeUvec3(e) => {
                          *((ptr0 + 24) as *mut u8) = (20i32) as u8;
                          let super::super::super::ambient::bindings::types::Uvec3{ x:x15, y:y15, z:z15, } = e;
                          *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x15);
                          *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y15);
                          *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z15);
                          
                        },
                        Value::TypeUvec4(e) => {
                          *((ptr0 + 24) as *mut u8) = (21i32) as u8;
                          let super::super::super::ambient::bindings::types::Uvec4{ x:x16, y:y16, z:z16, w:w16, } = e;
                          *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x16);
                          *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y16);
                          *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z16);
                          *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(w16);
                          
                        },
                        Value::TypeIvec2(e) => {
                          *((ptr0 + 24) as *mut u8) = (22i32) as u8;
                          let super::super::super::ambient::bindings::types::Ivec2{ x:x17, y:y17, } = e;
                          *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x17);
                          *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y17);
                          
                        },
                        Value::TypeIvec3(e) => {
                          *((ptr0 + 24) as *mut u8) = (23i32) as u8;
                          let super::super::super::ambient::bindings::types::Ivec3{ x:x18, y:y18, z:z18, } = e;
                          *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x18);
                          *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y18);
                          *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z18);
                          
                        },
                        Value::TypeIvec4(e) => {
                          *((ptr0 + 24) as *mut u8) = (24i32) as u8;
                          let super::super::super::ambient::bindings::types::Ivec4{ x:x19, y:y19, z:z19, w:w19, } = e;
                          *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x19);
                          *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y19);
                          *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z19);
                          *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(w19);
                          
                        },
                        Value::TypeDuration(e) => {
                          *((ptr0 + 24) as *mut u8) = (25i32) as u8;
                          let super::super::super::ambient::bindings::types::Duration{ seconds:seconds20, nanoseconds:nanoseconds20, } = e;
                          *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(seconds20);
                          *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(nanoseconds20);
                          
                        },
                        Value::TypeProceduralMeshHandle(e) => {
                          *((ptr0 + 24) as *mut u8) = (26i32) as u8;
                          let super::super::super::ambient::bindings::client_mesh::Handle{ ulid:ulid21, } = e;
                          let (t22_0, t22_1, ) = ulid21;
                          *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t22_0);
                          *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t22_1);
                          
                        },
                        Value::TypeProceduralTextureHandle(e) => {
                          *((ptr0 + 24) as *mut u8) = (27i32) as u8;
                          let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid23, } = e;
                          let (t24_0, t24_1, ) = ulid23;
                          *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t24_0);
                          *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t24_1);
                          
                        },
                        Value::TypeProceduralSamplerHandle(e) => {
                          *((ptr0 + 24) as *mut u8) = (28i32) as u8;
                          let super::super::super::ambient::bindings::client_sampler::Handle{ ulid:ulid25, } = e;
                          let (t26_0, t26_1, ) = ulid25;
                          *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t26_0);
                          *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t26_1);
                          
                        },
                        Value::TypeProceduralMaterialHandle(e) => {
                          *((ptr0 + 24) as *mut u8) = (29i32) as u8;
                          let super::super::super::ambient::bindings::client_material::Handle{ ulid:ulid27, } = e;
                          let (t28_0, t28_1, ) = ulid27;
                          *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t28_0);
                          *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t28_1);
                          
                        },
                        Value::TypeVec(e) => {
                          *((ptr0 + 24) as *mut u8) = (30i32) as u8;
                          match e {
                            VecValue::TypeEmpty(e) => {
                              *((ptr0 + 32) as *mut u8) = (0i32) as u8;
                              let vec29 = e;
                              let ptr29 = vec29.as_ptr() as i32;
                              let len29 = vec29.len() as i32;
                              *((ptr0 + 40) as *mut i32) = len29;
                              *((ptr0 + 36) as *mut i32) = ptr29;
                              
                            },
                            VecValue::TypeBool(e) => {
                              *((ptr0 + 32) as *mut u8) = (1i32) as u8;
                              let vec30 = e;
                              let len30 = vec30.len() as i32;
                              let layout30 = alloc::Layout::from_size_align_unchecked(vec30.len() * 1, 1);
                              let result30 = if layout30.size() != 0
                              {
                                let ptr = alloc::alloc(layout30);
                                if ptr.is_null()
                                {
                                  alloc::handle_alloc_error(layout30);
                                }
                                ptr
                              }else {
                                ::core::ptr::null_mut()
                              };
                              for (i, e) in vec30.into_iter().enumerate() {
                                let base = result30 as i32 + (i as i32) * 1;
                                {
                                  *((base + 0) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                  
                                }}
                                *((ptr0 + 40) as *mut i32) = len30;
                                *((ptr0 + 36) as *mut i32) = result30 as i32;
                                cleanup_list.extend_from_slice(&[(result30, layout30),]);
                                
                              },
                              VecValue::TypeEntityId(e) => {
                                *((ptr0 + 32) as *mut u8) = (2i32) as u8;
                                let vec31 = e;
                                let ptr31 = vec31.as_ptr() as i32;
                                let len31 = vec31.len() as i32;
                                *((ptr0 + 40) as *mut i32) = len31;
                                *((ptr0 + 36) as *mut i32) = ptr31;
                                
                              },
                              VecValue::TypeF32(e) => {
                                *((ptr0 + 32) as *mut u8) = (3i32) as u8;
                                let vec32 = e;
                                let ptr32 = vec32.as_ptr() as i32;
                                let len32 = vec32.len() as i32;
                                *((ptr0 + 40) as *mut i32) = len32;
                                *((ptr0 + 36) as *mut i32) = ptr32;
                                
                              },
                              VecValue::TypeF64(e) => {
                                *((ptr0 + 32) as *mut u8) = (4i32) as u8;
                                let vec33 = e;
                                let ptr33 = vec33.as_ptr() as i32;
                                let len33 = vec33.len() as i32;
                                *((ptr0 + 40) as *mut i32) = len33;
                                *((ptr0 + 36) as *mut i32) = ptr33;
                                
                              },
                              VecValue::TypeMat4(e) => {
                                *((ptr0 + 32) as *mut u8) = (5i32) as u8;
                                let vec34 = e;
                                let ptr34 = vec34.as_ptr() as i32;
                                let len34 = vec34.len() as i32;
                                *((ptr0 + 40) as *mut i32) = len34;
                                *((ptr0 + 36) as *mut i32) = ptr34;
                                
                              },
                              VecValue::TypeQuat(e) => {
                                *((ptr0 + 32) as *mut u8) = (6i32) as u8;
                                let vec35 = e;
                                let ptr35 = vec35.as_ptr() as i32;
                                let len35 = vec35.len() as i32;
                                *((ptr0 + 40) as *mut i32) = len35;
                                *((ptr0 + 36) as *mut i32) = ptr35;
                                
                              },
                              VecValue::TypeString(e) => {
                                *((ptr0 + 32) as *mut u8) = (7i32) as u8;
                                let vec37 = e;
                                let len37 = vec37.len() as i32;
                                let layout37 = alloc::Layout::from_size_align_unchecked(vec37.len() * 8, 4);
                                let result37 = if layout37.size() != 0
                                {
                                  let ptr = alloc::alloc(layout37);
                                  if ptr.is_null()
                                  {
                                    alloc::handle_alloc_error(layout37);
                                  }
                                  ptr
                                }else {
                                  ::core::ptr::null_mut()
                                };
                                for (i, e) in vec37.into_iter().enumerate() {
                                  let base = result37 as i32 + (i as i32) * 8;
                                  {
                                    let vec36 = e;
                                    let ptr36 = vec36.as_ptr() as i32;
                                    let len36 = vec36.len() as i32;
                                    *((base + 4) as *mut i32) = len36;
                                    *((base + 0) as *mut i32) = ptr36;
                                    
                                  }}
                                  *((ptr0 + 40) as *mut i32) = len37;
                                  *((ptr0 + 36) as *mut i32) = result37 as i32;
                                  cleanup_list.extend_from_slice(&[(result37, layout37),]);
                                  
                                },
                                VecValue::TypeU8(e) => {
                                  *((ptr0 + 32) as *mut u8) = (8i32) as u8;
                                  let vec38 = e;
                                  let ptr38 = vec38.as_ptr() as i32;
                                  let len38 = vec38.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len38;
                                  *((ptr0 + 36) as *mut i32) = ptr38;
                                  
                                },
                                VecValue::TypeU16(e) => {
                                  *((ptr0 + 32) as *mut u8) = (9i32) as u8;
                                  let vec39 = e;
                                  let ptr39 = vec39.as_ptr() as i32;
                                  let len39 = vec39.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len39;
                                  *((ptr0 + 36) as *mut i32) = ptr39;
                                  
                                },
                                VecValue::TypeU32(e) => {
                                  *((ptr0 + 32) as *mut u8) = (10i32) as u8;
                                  let vec40 = e;
                                  let ptr40 = vec40.as_ptr() as i32;
                                  let len40 = vec40.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len40;
                                  *((ptr0 + 36) as *mut i32) = ptr40;
                                  
                                },
                                VecValue::TypeU64(e) => {
                                  *((ptr0 + 32) as *mut u8) = (11i32) as u8;
                                  let vec41 = e;
                                  let ptr41 = vec41.as_ptr() as i32;
                                  let len41 = vec41.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len41;
                                  *((ptr0 + 36) as *mut i32) = ptr41;
                                  
                                },
                                VecValue::TypeI8(e) => {
                                  *((ptr0 + 32) as *mut u8) = (12i32) as u8;
                                  let vec42 = e;
                                  let ptr42 = vec42.as_ptr() as i32;
                                  let len42 = vec42.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len42;
                                  *((ptr0 + 36) as *mut i32) = ptr42;
                                  
                                },
                                VecValue::TypeI16(e) => {
                                  *((ptr0 + 32) as *mut u8) = (13i32) as u8;
                                  let vec43 = e;
                                  let ptr43 = vec43.as_ptr() as i32;
                                  let len43 = vec43.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len43;
                                  *((ptr0 + 36) as *mut i32) = ptr43;
                                  
                                },
                                VecValue::TypeI32(e) => {
                                  *((ptr0 + 32) as *mut u8) = (14i32) as u8;
                                  let vec44 = e;
                                  let ptr44 = vec44.as_ptr() as i32;
                                  let len44 = vec44.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len44;
                                  *((ptr0 + 36) as *mut i32) = ptr44;
                                  
                                },
                                VecValue::TypeI64(e) => {
                                  *((ptr0 + 32) as *mut u8) = (15i32) as u8;
                                  let vec45 = e;
                                  let ptr45 = vec45.as_ptr() as i32;
                                  let len45 = vec45.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len45;
                                  *((ptr0 + 36) as *mut i32) = ptr45;
                                  
                                },
                                VecValue::TypeVec2(e) => {
                                  *((ptr0 + 32) as *mut u8) = (16i32) as u8;
                                  let vec46 = e;
                                  let ptr46 = vec46.as_ptr() as i32;
                                  let len46 = vec46.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len46;
                                  *((ptr0 + 36) as *mut i32) = ptr46;
                                  
                                },
                                VecValue::TypeVec3(e) => {
                                  *((ptr0 + 32) as *mut u8) = (17i32) as u8;
                                  let vec47 = e;
                                  let ptr47 = vec47.as_ptr() as i32;
                                  let len47 = vec47.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len47;
                                  *((ptr0 + 36) as *mut i32) = ptr47;
                                  
                                },
                                VecValue::TypeVec4(e) => {
                                  *((ptr0 + 32) as *mut u8) = (18i32) as u8;
                                  let vec48 = e;
                                  let ptr48 = vec48.as_ptr() as i32;
                                  let len48 = vec48.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len48;
                                  *((ptr0 + 36) as *mut i32) = ptr48;
                                  
                                },
                                VecValue::TypeUvec2(e) => {
                                  *((ptr0 + 32) as *mut u8) = (19i32) as u8;
                                  let vec49 = e;
                                  let ptr49 = vec49.as_ptr() as i32;
                                  let len49 = vec49.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len49;
                                  *((ptr0 + 36) as *mut i32) = ptr49;
                                  
                                },
                                VecValue::TypeUvec3(e) => {
                                  *((ptr0 + 32) as *mut u8) = (20i32) as u8;
                                  let vec50 = e;
                                  let ptr50 = vec50.as_ptr() as i32;
                                  let len50 = vec50.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len50;
                                  *((ptr0 + 36) as *mut i32) = ptr50;
                                  
                                },
                                VecValue::TypeUvec4(e) => {
                                  *((ptr0 + 32) as *mut u8) = (21i32) as u8;
                                  let vec51 = e;
                                  let ptr51 = vec51.as_ptr() as i32;
                                  let len51 = vec51.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len51;
                                  *((ptr0 + 36) as *mut i32) = ptr51;
                                  
                                },
                                VecValue::TypeIvec2(e) => {
                                  *((ptr0 + 32) as *mut u8) = (22i32) as u8;
                                  let vec52 = e;
                                  let ptr52 = vec52.as_ptr() as i32;
                                  let len52 = vec52.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len52;
                                  *((ptr0 + 36) as *mut i32) = ptr52;
                                  
                                },
                                VecValue::TypeIvec3(e) => {
                                  *((ptr0 + 32) as *mut u8) = (23i32) as u8;
                                  let vec53 = e;
                                  let ptr53 = vec53.as_ptr() as i32;
                                  let len53 = vec53.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len53;
                                  *((ptr0 + 36) as *mut i32) = ptr53;
                                  
                                },
                                VecValue::TypeIvec4(e) => {
                                  *((ptr0 + 32) as *mut u8) = (24i32) as u8;
                                  let vec54 = e;
                                  let ptr54 = vec54.as_ptr() as i32;
                                  let len54 = vec54.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len54;
                                  *((ptr0 + 36) as *mut i32) = ptr54;
                                  
                                },
                                VecValue::TypeDuration(e) => {
                                  *((ptr0 + 32) as *mut u8) = (25i32) as u8;
                                  let vec55 = e;
                                  let ptr55 = vec55.as_ptr() as i32;
                                  let len55 = vec55.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len55;
                                  *((ptr0 + 36) as *mut i32) = ptr55;
                                  
                                },
                                VecValue::TypeProceduralMeshHandle(e) => {
                                  *((ptr0 + 32) as *mut u8) = (26i32) as u8;
                                  let vec56 = e;
                                  let ptr56 = vec56.as_ptr() as i32;
                                  let len56 = vec56.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len56;
                                  *((ptr0 + 36) as *mut i32) = ptr56;
                                  
                                },
                                VecValue::TypeProceduralTextureHandle(e) => {
                                  *((ptr0 + 32) as *mut u8) = (27i32) as u8;
                                  let vec57 = e;
                                  let ptr57 = vec57.as_ptr() as i32;
                                  let len57 = vec57.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len57;
                                  *((ptr0 + 36) as *mut i32) = ptr57;
                                  
                                },
                                VecValue::TypeProceduralSamplerHandle(e) => {
                                  *((ptr0 + 32) as *mut u8) = (28i32) as u8;
                                  let vec58 = e;
                                  let ptr58 = vec58.as_ptr() as i32;
                                  let len58 = vec58.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len58;
                                  *((ptr0 + 36) as *mut i32) = ptr58;
                                  
                                },
                                VecValue::TypeProceduralMaterialHandle(e) => {
                                  *((ptr0 + 32) as *mut u8) = (29i32) as u8;
                                  let vec59 = e;
                                  let ptr59 = vec59.as_ptr() as i32;
                                  let len59 = vec59.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len59;
                                  *((ptr0 + 36) as *mut i32) = ptr59;
                                  
                                },
                              };
                              
                            },
                            Value::TypeOption(e) => {
                              *((ptr0 + 24) as *mut u8) = (31i32) as u8;
                              match e {
                                OptionValue::TypeEmpty(e) => {
                                  *((ptr0 + 32) as *mut u8) = (0i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Empty{ dummy:dummy60, } = e;
                                      *((ptr0 + 41) as *mut u8) = (wit_bindgen::rt::as_i32(dummy60)) as u8;
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeBool(e) => {
                                  *((ptr0 + 32) as *mut u8) = (1i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      *((ptr0 + 41) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeEntityId(e) => {
                                  *((ptr0 + 32) as *mut u8) = (2i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::EntityId{ id0:id061, id1:id161, } = e;
                                      *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(id061);
                                      *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(id161);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeF32(e) => {
                                  *((ptr0 + 32) as *mut u8) = (3i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(e);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeF64(e) => {
                                  *((ptr0 + 32) as *mut u8) = (4i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      *((ptr0 + 48) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeMat4(e) => {
                                  *((ptr0 + 32) as *mut u8) = (5i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Mat4{ x:x62, y:y62, z:z62, w:w62, } = e;
                                      let super::super::super::ambient::bindings::types::Vec4{ x:x63, y:y63, z:z63, w:w63, } = x62;
                                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x63);
                                      *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y63);
                                      *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z63);
                                      *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w63);
                                      let super::super::super::ambient::bindings::types::Vec4{ x:x64, y:y64, z:z64, w:w64, } = y62;
                                      *((ptr0 + 60) as *mut f32) = wit_bindgen::rt::as_f32(x64);
                                      *((ptr0 + 64) as *mut f32) = wit_bindgen::rt::as_f32(y64);
                                      *((ptr0 + 68) as *mut f32) = wit_bindgen::rt::as_f32(z64);
                                      *((ptr0 + 72) as *mut f32) = wit_bindgen::rt::as_f32(w64);
                                      let super::super::super::ambient::bindings::types::Vec4{ x:x65, y:y65, z:z65, w:w65, } = z62;
                                      *((ptr0 + 76) as *mut f32) = wit_bindgen::rt::as_f32(x65);
                                      *((ptr0 + 80) as *mut f32) = wit_bindgen::rt::as_f32(y65);
                                      *((ptr0 + 84) as *mut f32) = wit_bindgen::rt::as_f32(z65);
                                      *((ptr0 + 88) as *mut f32) = wit_bindgen::rt::as_f32(w65);
                                      let super::super::super::ambient::bindings::types::Vec4{ x:x66, y:y66, z:z66, w:w66, } = w62;
                                      *((ptr0 + 92) as *mut f32) = wit_bindgen::rt::as_f32(x66);
                                      *((ptr0 + 96) as *mut f32) = wit_bindgen::rt::as_f32(y66);
                                      *((ptr0 + 100) as *mut f32) = wit_bindgen::rt::as_f32(z66);
                                      *((ptr0 + 104) as *mut f32) = wit_bindgen::rt::as_f32(w66);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeQuat(e) => {
                                  *((ptr0 + 32) as *mut u8) = (6i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Quat{ x:x67, y:y67, z:z67, w:w67, } = e;
                                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x67);
                                      *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y67);
                                      *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z67);
                                      *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w67);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeString(e) => {
                                  *((ptr0 + 32) as *mut u8) = (7i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let vec68 = e;
                                      let ptr68 = vec68.as_ptr() as i32;
                                      let len68 = vec68.len() as i32;
                                      *((ptr0 + 48) as *mut i32) = len68;
                                      *((ptr0 + 44) as *mut i32) = ptr68;
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeU8(e) => {
                                  *((ptr0 + 32) as *mut u8) = (8i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      *((ptr0 + 41) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeU16(e) => {
                                  *((ptr0 + 32) as *mut u8) = (9i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      *((ptr0 + 42) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeU32(e) => {
                                  *((ptr0 + 32) as *mut u8) = (10i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeU64(e) => {
                                  *((ptr0 + 32) as *mut u8) = (11i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeI8(e) => {
                                  *((ptr0 + 32) as *mut u8) = (12i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      *((ptr0 + 41) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeI16(e) => {
                                  *((ptr0 + 32) as *mut u8) = (13i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      *((ptr0 + 42) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeI32(e) => {
                                  *((ptr0 + 32) as *mut u8) = (14i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeI64(e) => {
                                  *((ptr0 + 32) as *mut u8) = (15i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeVec2(e) => {
                                  *((ptr0 + 32) as *mut u8) = (16i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Vec2{ x:x69, y:y69, } = e;
                                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x69);
                                      *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y69);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeVec3(e) => {
                                  *((ptr0 + 32) as *mut u8) = (17i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Vec3{ x:x70, y:y70, z:z70, } = e;
                                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x70);
                                      *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y70);
                                      *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z70);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeVec4(e) => {
                                  *((ptr0 + 32) as *mut u8) = (18i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Vec4{ x:x71, y:y71, z:z71, w:w71, } = e;
                                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x71);
                                      *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y71);
                                      *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z71);
                                      *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w71);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeUvec2(e) => {
                                  *((ptr0 + 32) as *mut u8) = (19i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Uvec2{ x:x72, y:y72, } = e;
                                      *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x72);
                                      *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y72);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeUvec3(e) => {
                                  *((ptr0 + 32) as *mut u8) = (20i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Uvec3{ x:x73, y:y73, z:z73, } = e;
                                      *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x73);
                                      *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y73);
                                      *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z73);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeUvec4(e) => {
                                  *((ptr0 + 32) as *mut u8) = (21i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Uvec4{ x:x74, y:y74, z:z74, w:w74, } = e;
                                      *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x74);
                                      *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y74);
                                      *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z74);
                                      *((ptr0 + 56) as *mut i32) = wit_bindgen::rt::as_i32(w74);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeIvec2(e) => {
                                  *((ptr0 + 32) as *mut u8) = (22i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Ivec2{ x:x75, y:y75, } = e;
                                      *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x75);
                                      *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y75);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeIvec3(e) => {
                                  *((ptr0 + 32) as *mut u8) = (23i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Ivec3{ x:x76, y:y76, z:z76, } = e;
                                      *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x76);
                                      *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y76);
                                      *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z76);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeIvec4(e) => {
                                  *((ptr0 + 32) as *mut u8) = (24i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Ivec4{ x:x77, y:y77, z:z77, w:w77, } = e;
                                      *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x77);
                                      *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y77);
                                      *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z77);
                                      *((ptr0 + 56) as *mut i32) = wit_bindgen::rt::as_i32(w77);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeDuration(e) => {
                                  *((ptr0 + 32) as *mut u8) = (25i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Duration{ seconds:seconds78, nanoseconds:nanoseconds78, } = e;
                                      *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(seconds78);
                                      *((ptr0 + 56) as *mut i32) = wit_bindgen::rt::as_i32(nanoseconds78);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeProceduralMeshHandle(e) => {
                                  *((ptr0 + 32) as *mut u8) = (26i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::client_mesh::Handle{ ulid:ulid79, } = e;
                                      let (t80_0, t80_1, ) = ulid79;
                                      *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t80_0);
                                      *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t80_1);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeProceduralTextureHandle(e) => {
                                  *((ptr0 + 32) as *mut u8) = (27i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid81, } = e;
                                      let (t82_0, t82_1, ) = ulid81;
                                      *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t82_0);
                                      *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t82_1);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeProceduralSamplerHandle(e) => {
                                  *((ptr0 + 32) as *mut u8) = (28i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::client_sampler::Handle{ ulid:ulid83, } = e;
                                      let (t84_0, t84_1, ) = ulid83;
                                      *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t84_0);
                                      *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t84_1);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeProceduralMaterialHandle(e) => {
                                  *((ptr0 + 32) as *mut u8) = (29i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::client_material::Handle{ ulid:ulid85, } = e;
                                      let (t86_0, t86_1, ) = ulid85;
                                      *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t86_0);
                                      *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t86_1);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                              };
                              
                            },
                          };
                          
                          #[link(wasm_import_module = "ambient:bindings/component")]
                          extern "C" {
                            #[cfg_attr(target_arch = "wasm32", link_name = "set-component")]
                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_set-component")]
                            fn wit_import(
                            _: i32, );
                          }
                          wit_import(ptr0);
                          for (ptr, layout) in cleanup_list {
                            
                            if layout.size() != 0 {
                              
                              alloc::dealloc(ptr, layout);
                              
                            }
                            
                          }
                        }
                      }
                      #[allow(clippy::all)]
                      pub fn set_components(entity: EntityId,data: &Entity,){
                        
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        unsafe {
                          let mut cleanup_list = Vec::new();
                          let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                          let vec87 = data;
                          let len87 = vec87.len() as i32;
                          let layout87 = alloc::Layout::from_size_align_unchecked(vec87.len() * 96, 8);
                          let result87 = if layout87.size() != 0
                          {
                            let ptr = alloc::alloc(layout87);
                            if ptr.is_null()
                            {
                              alloc::handle_alloc_error(layout87);
                            }
                            ptr
                          }else {
                            ::core::ptr::null_mut()
                          };
                          for (i, e) in vec87.into_iter().enumerate() {
                            let base = result87 as i32 + (i as i32) * 96;
                            {
                              let (t1_0, t1_1, ) = e;
                              *((base + 0) as *mut i32) = wit_bindgen::rt::as_i32(t1_0);
                              match t1_1 {
                                Value::TypeEmpty(e) => {
                                  *((base + 8) as *mut u8) = (0i32) as u8;
                                  let super::super::super::ambient::bindings::types::Empty{ dummy:dummy2, } = e;
                                  *((base + 16) as *mut u8) = (wit_bindgen::rt::as_i32(dummy2)) as u8;
                                  
                                },
                                Value::TypeBool(e) => {
                                  *((base + 8) as *mut u8) = (1i32) as u8;
                                  *((base + 16) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                  
                                },
                                Value::TypeEntityId(e) => {
                                  *((base + 8) as *mut u8) = (2i32) as u8;
                                  let super::super::super::ambient::bindings::types::EntityId{ id0:id03, id1:id13, } = e;
                                  *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(id03);
                                  *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(id13);
                                  
                                },
                                Value::TypeF32(e) => {
                                  *((base + 8) as *mut u8) = (3i32) as u8;
                                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(e);
                                  
                                },
                                Value::TypeF64(e) => {
                                  *((base + 8) as *mut u8) = (4i32) as u8;
                                  *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                  
                                },
                                Value::TypeMat4(e) => {
                                  *((base + 8) as *mut u8) = (5i32) as u8;
                                  let super::super::super::ambient::bindings::types::Mat4{ x:x4, y:y4, z:z4, w:w4, } = e;
                                  let super::super::super::ambient::bindings::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = x4;
                                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x5);
                                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y5);
                                  *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z5);
                                  *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w5);
                                  let super::super::super::ambient::bindings::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = y4;
                                  *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(x6);
                                  *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(y6);
                                  *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(z6);
                                  *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(w6);
                                  let super::super::super::ambient::bindings::types::Vec4{ x:x7, y:y7, z:z7, w:w7, } = z4;
                                  *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(x7);
                                  *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(y7);
                                  *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(z7);
                                  *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(w7);
                                  let super::super::super::ambient::bindings::types::Vec4{ x:x8, y:y8, z:z8, w:w8, } = w4;
                                  *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(x8);
                                  *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(y8);
                                  *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(z8);
                                  *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(w8);
                                  
                                },
                                Value::TypeQuat(e) => {
                                  *((base + 8) as *mut u8) = (6i32) as u8;
                                  let super::super::super::ambient::bindings::types::Quat{ x:x9, y:y9, z:z9, w:w9, } = e;
                                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x9);
                                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y9);
                                  *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z9);
                                  *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w9);
                                  
                                },
                                Value::TypeString(e) => {
                                  *((base + 8) as *mut u8) = (7i32) as u8;
                                  let vec10 = e;
                                  let ptr10 = vec10.as_ptr() as i32;
                                  let len10 = vec10.len() as i32;
                                  *((base + 20) as *mut i32) = len10;
                                  *((base + 16) as *mut i32) = ptr10;
                                  
                                },
                                Value::TypeU8(e) => {
                                  *((base + 8) as *mut u8) = (8i32) as u8;
                                  *((base + 16) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                  
                                },
                                Value::TypeU16(e) => {
                                  *((base + 8) as *mut u8) = (9i32) as u8;
                                  *((base + 16) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                                  
                                },
                                Value::TypeU32(e) => {
                                  *((base + 8) as *mut u8) = (10i32) as u8;
                                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                  
                                },
                                Value::TypeU64(e) => {
                                  *((base + 8) as *mut u8) = (11i32) as u8;
                                  *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                  
                                },
                                Value::TypeI8(e) => {
                                  *((base + 8) as *mut u8) = (12i32) as u8;
                                  *((base + 16) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                  
                                },
                                Value::TypeI16(e) => {
                                  *((base + 8) as *mut u8) = (13i32) as u8;
                                  *((base + 16) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                                  
                                },
                                Value::TypeI32(e) => {
                                  *((base + 8) as *mut u8) = (14i32) as u8;
                                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                  
                                },
                                Value::TypeI64(e) => {
                                  *((base + 8) as *mut u8) = (15i32) as u8;
                                  *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                  
                                },
                                Value::TypeVec2(e) => {
                                  *((base + 8) as *mut u8) = (16i32) as u8;
                                  let super::super::super::ambient::bindings::types::Vec2{ x:x11, y:y11, } = e;
                                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x11);
                                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y11);
                                  
                                },
                                Value::TypeVec3(e) => {
                                  *((base + 8) as *mut u8) = (17i32) as u8;
                                  let super::super::super::ambient::bindings::types::Vec3{ x:x12, y:y12, z:z12, } = e;
                                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x12);
                                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y12);
                                  *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z12);
                                  
                                },
                                Value::TypeVec4(e) => {
                                  *((base + 8) as *mut u8) = (18i32) as u8;
                                  let super::super::super::ambient::bindings::types::Vec4{ x:x13, y:y13, z:z13, w:w13, } = e;
                                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x13);
                                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y13);
                                  *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z13);
                                  *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w13);
                                  
                                },
                                Value::TypeUvec2(e) => {
                                  *((base + 8) as *mut u8) = (19i32) as u8;
                                  let super::super::super::ambient::bindings::types::Uvec2{ x:x14, y:y14, } = e;
                                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x14);
                                  *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y14);
                                  
                                },
                                Value::TypeUvec3(e) => {
                                  *((base + 8) as *mut u8) = (20i32) as u8;
                                  let super::super::super::ambient::bindings::types::Uvec3{ x:x15, y:y15, z:z15, } = e;
                                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x15);
                                  *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y15);
                                  *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z15);
                                  
                                },
                                Value::TypeUvec4(e) => {
                                  *((base + 8) as *mut u8) = (21i32) as u8;
                                  let super::super::super::ambient::bindings::types::Uvec4{ x:x16, y:y16, z:z16, w:w16, } = e;
                                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x16);
                                  *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y16);
                                  *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z16);
                                  *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(w16);
                                  
                                },
                                Value::TypeIvec2(e) => {
                                  *((base + 8) as *mut u8) = (22i32) as u8;
                                  let super::super::super::ambient::bindings::types::Ivec2{ x:x17, y:y17, } = e;
                                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x17);
                                  *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y17);
                                  
                                },
                                Value::TypeIvec3(e) => {
                                  *((base + 8) as *mut u8) = (23i32) as u8;
                                  let super::super::super::ambient::bindings::types::Ivec3{ x:x18, y:y18, z:z18, } = e;
                                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x18);
                                  *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y18);
                                  *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z18);
                                  
                                },
                                Value::TypeIvec4(e) => {
                                  *((base + 8) as *mut u8) = (24i32) as u8;
                                  let super::super::super::ambient::bindings::types::Ivec4{ x:x19, y:y19, z:z19, w:w19, } = e;
                                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x19);
                                  *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y19);
                                  *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z19);
                                  *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(w19);
                                  
                                },
                                Value::TypeDuration(e) => {
                                  *((base + 8) as *mut u8) = (25i32) as u8;
                                  let super::super::super::ambient::bindings::types::Duration{ seconds:seconds20, nanoseconds:nanoseconds20, } = e;
                                  *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(seconds20);
                                  *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(nanoseconds20);
                                  
                                },
                                Value::TypeProceduralMeshHandle(e) => {
                                  *((base + 8) as *mut u8) = (26i32) as u8;
                                  let super::super::super::ambient::bindings::client_mesh::Handle{ ulid:ulid21, } = e;
                                  let (t22_0, t22_1, ) = ulid21;
                                  *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t22_0);
                                  *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t22_1);
                                  
                                },
                                Value::TypeProceduralTextureHandle(e) => {
                                  *((base + 8) as *mut u8) = (27i32) as u8;
                                  let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid23, } = e;
                                  let (t24_0, t24_1, ) = ulid23;
                                  *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t24_0);
                                  *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t24_1);
                                  
                                },
                                Value::TypeProceduralSamplerHandle(e) => {
                                  *((base + 8) as *mut u8) = (28i32) as u8;
                                  let super::super::super::ambient::bindings::client_sampler::Handle{ ulid:ulid25, } = e;
                                  let (t26_0, t26_1, ) = ulid25;
                                  *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t26_0);
                                  *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t26_1);
                                  
                                },
                                Value::TypeProceduralMaterialHandle(e) => {
                                  *((base + 8) as *mut u8) = (29i32) as u8;
                                  let super::super::super::ambient::bindings::client_material::Handle{ ulid:ulid27, } = e;
                                  let (t28_0, t28_1, ) = ulid27;
                                  *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t28_0);
                                  *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t28_1);
                                  
                                },
                                Value::TypeVec(e) => {
                                  *((base + 8) as *mut u8) = (30i32) as u8;
                                  match e {
                                    VecValue::TypeEmpty(e) => {
                                      *((base + 16) as *mut u8) = (0i32) as u8;
                                      let vec29 = e;
                                      let ptr29 = vec29.as_ptr() as i32;
                                      let len29 = vec29.len() as i32;
                                      *((base + 24) as *mut i32) = len29;
                                      *((base + 20) as *mut i32) = ptr29;
                                      
                                    },
                                    VecValue::TypeBool(e) => {
                                      *((base + 16) as *mut u8) = (1i32) as u8;
                                      let vec30 = e;
                                      let len30 = vec30.len() as i32;
                                      let layout30 = alloc::Layout::from_size_align_unchecked(vec30.len() * 1, 1);
                                      let result30 = if layout30.size() != 0
                                      {
                                        let ptr = alloc::alloc(layout30);
                                        if ptr.is_null()
                                        {
                                          alloc::handle_alloc_error(layout30);
                                        }
                                        ptr
                                      }else {
                                        ::core::ptr::null_mut()
                                      };
                                      for (i, e) in vec30.into_iter().enumerate() {
                                        let base = result30 as i32 + (i as i32) * 1;
                                        {
                                          *((base + 0) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                          
                                        }}
                                        *((base + 24) as *mut i32) = len30;
                                        *((base + 20) as *mut i32) = result30 as i32;
                                        cleanup_list.extend_from_slice(&[(result30, layout30),]);
                                        
                                      },
                                      VecValue::TypeEntityId(e) => {
                                        *((base + 16) as *mut u8) = (2i32) as u8;
                                        let vec31 = e;
                                        let ptr31 = vec31.as_ptr() as i32;
                                        let len31 = vec31.len() as i32;
                                        *((base + 24) as *mut i32) = len31;
                                        *((base + 20) as *mut i32) = ptr31;
                                        
                                      },
                                      VecValue::TypeF32(e) => {
                                        *((base + 16) as *mut u8) = (3i32) as u8;
                                        let vec32 = e;
                                        let ptr32 = vec32.as_ptr() as i32;
                                        let len32 = vec32.len() as i32;
                                        *((base + 24) as *mut i32) = len32;
                                        *((base + 20) as *mut i32) = ptr32;
                                        
                                      },
                                      VecValue::TypeF64(e) => {
                                        *((base + 16) as *mut u8) = (4i32) as u8;
                                        let vec33 = e;
                                        let ptr33 = vec33.as_ptr() as i32;
                                        let len33 = vec33.len() as i32;
                                        *((base + 24) as *mut i32) = len33;
                                        *((base + 20) as *mut i32) = ptr33;
                                        
                                      },
                                      VecValue::TypeMat4(e) => {
                                        *((base + 16) as *mut u8) = (5i32) as u8;
                                        let vec34 = e;
                                        let ptr34 = vec34.as_ptr() as i32;
                                        let len34 = vec34.len() as i32;
                                        *((base + 24) as *mut i32) = len34;
                                        *((base + 20) as *mut i32) = ptr34;
                                        
                                      },
                                      VecValue::TypeQuat(e) => {
                                        *((base + 16) as *mut u8) = (6i32) as u8;
                                        let vec35 = e;
                                        let ptr35 = vec35.as_ptr() as i32;
                                        let len35 = vec35.len() as i32;
                                        *((base + 24) as *mut i32) = len35;
                                        *((base + 20) as *mut i32) = ptr35;
                                        
                                      },
                                      VecValue::TypeString(e) => {
                                        *((base + 16) as *mut u8) = (7i32) as u8;
                                        let vec37 = e;
                                        let len37 = vec37.len() as i32;
                                        let layout37 = alloc::Layout::from_size_align_unchecked(vec37.len() * 8, 4);
                                        let result37 = if layout37.size() != 0
                                        {
                                          let ptr = alloc::alloc(layout37);
                                          if ptr.is_null()
                                          {
                                            alloc::handle_alloc_error(layout37);
                                          }
                                          ptr
                                        }else {
                                          ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec37.into_iter().enumerate() {
                                          let base = result37 as i32 + (i as i32) * 8;
                                          {
                                            let vec36 = e;
                                            let ptr36 = vec36.as_ptr() as i32;
                                            let len36 = vec36.len() as i32;
                                            *((base + 4) as *mut i32) = len36;
                                            *((base + 0) as *mut i32) = ptr36;
                                            
                                          }}
                                          *((base + 24) as *mut i32) = len37;
                                          *((base + 20) as *mut i32) = result37 as i32;
                                          cleanup_list.extend_from_slice(&[(result37, layout37),]);
                                          
                                        },
                                        VecValue::TypeU8(e) => {
                                          *((base + 16) as *mut u8) = (8i32) as u8;
                                          let vec38 = e;
                                          let ptr38 = vec38.as_ptr() as i32;
                                          let len38 = vec38.len() as i32;
                                          *((base + 24) as *mut i32) = len38;
                                          *((base + 20) as *mut i32) = ptr38;
                                          
                                        },
                                        VecValue::TypeU16(e) => {
                                          *((base + 16) as *mut u8) = (9i32) as u8;
                                          let vec39 = e;
                                          let ptr39 = vec39.as_ptr() as i32;
                                          let len39 = vec39.len() as i32;
                                          *((base + 24) as *mut i32) = len39;
                                          *((base + 20) as *mut i32) = ptr39;
                                          
                                        },
                                        VecValue::TypeU32(e) => {
                                          *((base + 16) as *mut u8) = (10i32) as u8;
                                          let vec40 = e;
                                          let ptr40 = vec40.as_ptr() as i32;
                                          let len40 = vec40.len() as i32;
                                          *((base + 24) as *mut i32) = len40;
                                          *((base + 20) as *mut i32) = ptr40;
                                          
                                        },
                                        VecValue::TypeU64(e) => {
                                          *((base + 16) as *mut u8) = (11i32) as u8;
                                          let vec41 = e;
                                          let ptr41 = vec41.as_ptr() as i32;
                                          let len41 = vec41.len() as i32;
                                          *((base + 24) as *mut i32) = len41;
                                          *((base + 20) as *mut i32) = ptr41;
                                          
                                        },
                                        VecValue::TypeI8(e) => {
                                          *((base + 16) as *mut u8) = (12i32) as u8;
                                          let vec42 = e;
                                          let ptr42 = vec42.as_ptr() as i32;
                                          let len42 = vec42.len() as i32;
                                          *((base + 24) as *mut i32) = len42;
                                          *((base + 20) as *mut i32) = ptr42;
                                          
                                        },
                                        VecValue::TypeI16(e) => {
                                          *((base + 16) as *mut u8) = (13i32) as u8;
                                          let vec43 = e;
                                          let ptr43 = vec43.as_ptr() as i32;
                                          let len43 = vec43.len() as i32;
                                          *((base + 24) as *mut i32) = len43;
                                          *((base + 20) as *mut i32) = ptr43;
                                          
                                        },
                                        VecValue::TypeI32(e) => {
                                          *((base + 16) as *mut u8) = (14i32) as u8;
                                          let vec44 = e;
                                          let ptr44 = vec44.as_ptr() as i32;
                                          let len44 = vec44.len() as i32;
                                          *((base + 24) as *mut i32) = len44;
                                          *((base + 20) as *mut i32) = ptr44;
                                          
                                        },
                                        VecValue::TypeI64(e) => {
                                          *((base + 16) as *mut u8) = (15i32) as u8;
                                          let vec45 = e;
                                          let ptr45 = vec45.as_ptr() as i32;
                                          let len45 = vec45.len() as i32;
                                          *((base + 24) as *mut i32) = len45;
                                          *((base + 20) as *mut i32) = ptr45;
                                          
                                        },
                                        VecValue::TypeVec2(e) => {
                                          *((base + 16) as *mut u8) = (16i32) as u8;
                                          let vec46 = e;
                                          let ptr46 = vec46.as_ptr() as i32;
                                          let len46 = vec46.len() as i32;
                                          *((base + 24) as *mut i32) = len46;
                                          *((base + 20) as *mut i32) = ptr46;
                                          
                                        },
                                        VecValue::TypeVec3(e) => {
                                          *((base + 16) as *mut u8) = (17i32) as u8;
                                          let vec47 = e;
                                          let ptr47 = vec47.as_ptr() as i32;
                                          let len47 = vec47.len() as i32;
                                          *((base + 24) as *mut i32) = len47;
                                          *((base + 20) as *mut i32) = ptr47;
                                          
                                        },
                                        VecValue::TypeVec4(e) => {
                                          *((base + 16) as *mut u8) = (18i32) as u8;
                                          let vec48 = e;
                                          let ptr48 = vec48.as_ptr() as i32;
                                          let len48 = vec48.len() as i32;
                                          *((base + 24) as *mut i32) = len48;
                                          *((base + 20) as *mut i32) = ptr48;
                                          
                                        },
                                        VecValue::TypeUvec2(e) => {
                                          *((base + 16) as *mut u8) = (19i32) as u8;
                                          let vec49 = e;
                                          let ptr49 = vec49.as_ptr() as i32;
                                          let len49 = vec49.len() as i32;
                                          *((base + 24) as *mut i32) = len49;
                                          *((base + 20) as *mut i32) = ptr49;
                                          
                                        },
                                        VecValue::TypeUvec3(e) => {
                                          *((base + 16) as *mut u8) = (20i32) as u8;
                                          let vec50 = e;
                                          let ptr50 = vec50.as_ptr() as i32;
                                          let len50 = vec50.len() as i32;
                                          *((base + 24) as *mut i32) = len50;
                                          *((base + 20) as *mut i32) = ptr50;
                                          
                                        },
                                        VecValue::TypeUvec4(e) => {
                                          *((base + 16) as *mut u8) = (21i32) as u8;
                                          let vec51 = e;
                                          let ptr51 = vec51.as_ptr() as i32;
                                          let len51 = vec51.len() as i32;
                                          *((base + 24) as *mut i32) = len51;
                                          *((base + 20) as *mut i32) = ptr51;
                                          
                                        },
                                        VecValue::TypeIvec2(e) => {
                                          *((base + 16) as *mut u8) = (22i32) as u8;
                                          let vec52 = e;
                                          let ptr52 = vec52.as_ptr() as i32;
                                          let len52 = vec52.len() as i32;
                                          *((base + 24) as *mut i32) = len52;
                                          *((base + 20) as *mut i32) = ptr52;
                                          
                                        },
                                        VecValue::TypeIvec3(e) => {
                                          *((base + 16) as *mut u8) = (23i32) as u8;
                                          let vec53 = e;
                                          let ptr53 = vec53.as_ptr() as i32;
                                          let len53 = vec53.len() as i32;
                                          *((base + 24) as *mut i32) = len53;
                                          *((base + 20) as *mut i32) = ptr53;
                                          
                                        },
                                        VecValue::TypeIvec4(e) => {
                                          *((base + 16) as *mut u8) = (24i32) as u8;
                                          let vec54 = e;
                                          let ptr54 = vec54.as_ptr() as i32;
                                          let len54 = vec54.len() as i32;
                                          *((base + 24) as *mut i32) = len54;
                                          *((base + 20) as *mut i32) = ptr54;
                                          
                                        },
                                        VecValue::TypeDuration(e) => {
                                          *((base + 16) as *mut u8) = (25i32) as u8;
                                          let vec55 = e;
                                          let ptr55 = vec55.as_ptr() as i32;
                                          let len55 = vec55.len() as i32;
                                          *((base + 24) as *mut i32) = len55;
                                          *((base + 20) as *mut i32) = ptr55;
                                          
                                        },
                                        VecValue::TypeProceduralMeshHandle(e) => {
                                          *((base + 16) as *mut u8) = (26i32) as u8;
                                          let vec56 = e;
                                          let ptr56 = vec56.as_ptr() as i32;
                                          let len56 = vec56.len() as i32;
                                          *((base + 24) as *mut i32) = len56;
                                          *((base + 20) as *mut i32) = ptr56;
                                          
                                        },
                                        VecValue::TypeProceduralTextureHandle(e) => {
                                          *((base + 16) as *mut u8) = (27i32) as u8;
                                          let vec57 = e;
                                          let ptr57 = vec57.as_ptr() as i32;
                                          let len57 = vec57.len() as i32;
                                          *((base + 24) as *mut i32) = len57;
                                          *((base + 20) as *mut i32) = ptr57;
                                          
                                        },
                                        VecValue::TypeProceduralSamplerHandle(e) => {
                                          *((base + 16) as *mut u8) = (28i32) as u8;
                                          let vec58 = e;
                                          let ptr58 = vec58.as_ptr() as i32;
                                          let len58 = vec58.len() as i32;
                                          *((base + 24) as *mut i32) = len58;
                                          *((base + 20) as *mut i32) = ptr58;
                                          
                                        },
                                        VecValue::TypeProceduralMaterialHandle(e) => {
                                          *((base + 16) as *mut u8) = (29i32) as u8;
                                          let vec59 = e;
                                          let ptr59 = vec59.as_ptr() as i32;
                                          let len59 = vec59.len() as i32;
                                          *((base + 24) as *mut i32) = len59;
                                          *((base + 20) as *mut i32) = ptr59;
                                          
                                        },
                                      };
                                      
                                    },
                                    Value::TypeOption(e) => {
                                      *((base + 8) as *mut u8) = (31i32) as u8;
                                      match e {
                                        OptionValue::TypeEmpty(e) => {
                                          *((base + 16) as *mut u8) = (0i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Empty{ dummy:dummy60, } = e;
                                              *((base + 25) as *mut u8) = (wit_bindgen::rt::as_i32(dummy60)) as u8;
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeBool(e) => {
                                          *((base + 16) as *mut u8) = (1i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 25) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeEntityId(e) => {
                                          *((base + 16) as *mut u8) = (2i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::EntityId{ id0:id061, id1:id161, } = e;
                                              *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(id061);
                                              *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(id161);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeF32(e) => {
                                          *((base + 16) as *mut u8) = (3i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(e);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeF64(e) => {
                                          *((base + 16) as *mut u8) = (4i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeMat4(e) => {
                                          *((base + 16) as *mut u8) = (5i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Mat4{ x:x62, y:y62, z:z62, w:w62, } = e;
                                              let super::super::super::ambient::bindings::types::Vec4{ x:x63, y:y63, z:z63, w:w63, } = x62;
                                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x63);
                                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y63);
                                              *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z63);
                                              *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w63);
                                              let super::super::super::ambient::bindings::types::Vec4{ x:x64, y:y64, z:z64, w:w64, } = y62;
                                              *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(x64);
                                              *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(y64);
                                              *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(z64);
                                              *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(w64);
                                              let super::super::super::ambient::bindings::types::Vec4{ x:x65, y:y65, z:z65, w:w65, } = z62;
                                              *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(x65);
                                              *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(y65);
                                              *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(z65);
                                              *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(w65);
                                              let super::super::super::ambient::bindings::types::Vec4{ x:x66, y:y66, z:z66, w:w66, } = w62;
                                              *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(x66);
                                              *((base + 80) as *mut f32) = wit_bindgen::rt::as_f32(y66);
                                              *((base + 84) as *mut f32) = wit_bindgen::rt::as_f32(z66);
                                              *((base + 88) as *mut f32) = wit_bindgen::rt::as_f32(w66);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeQuat(e) => {
                                          *((base + 16) as *mut u8) = (6i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Quat{ x:x67, y:y67, z:z67, w:w67, } = e;
                                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x67);
                                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y67);
                                              *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z67);
                                              *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w67);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeString(e) => {
                                          *((base + 16) as *mut u8) = (7i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let vec68 = e;
                                              let ptr68 = vec68.as_ptr() as i32;
                                              let len68 = vec68.len() as i32;
                                              *((base + 32) as *mut i32) = len68;
                                              *((base + 28) as *mut i32) = ptr68;
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeU8(e) => {
                                          *((base + 16) as *mut u8) = (8i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 25) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeU16(e) => {
                                          *((base + 16) as *mut u8) = (9i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 26) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeU32(e) => {
                                          *((base + 16) as *mut u8) = (10i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeU64(e) => {
                                          *((base + 16) as *mut u8) = (11i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeI8(e) => {
                                          *((base + 16) as *mut u8) = (12i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 25) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeI16(e) => {
                                          *((base + 16) as *mut u8) = (13i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 26) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeI32(e) => {
                                          *((base + 16) as *mut u8) = (14i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeI64(e) => {
                                          *((base + 16) as *mut u8) = (15i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeVec2(e) => {
                                          *((base + 16) as *mut u8) = (16i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Vec2{ x:x69, y:y69, } = e;
                                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x69);
                                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y69);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeVec3(e) => {
                                          *((base + 16) as *mut u8) = (17i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Vec3{ x:x70, y:y70, z:z70, } = e;
                                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x70);
                                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y70);
                                              *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z70);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeVec4(e) => {
                                          *((base + 16) as *mut u8) = (18i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Vec4{ x:x71, y:y71, z:z71, w:w71, } = e;
                                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x71);
                                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y71);
                                              *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z71);
                                              *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w71);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeUvec2(e) => {
                                          *((base + 16) as *mut u8) = (19i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Uvec2{ x:x72, y:y72, } = e;
                                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x72);
                                              *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y72);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeUvec3(e) => {
                                          *((base + 16) as *mut u8) = (20i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Uvec3{ x:x73, y:y73, z:z73, } = e;
                                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x73);
                                              *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y73);
                                              *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z73);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeUvec4(e) => {
                                          *((base + 16) as *mut u8) = (21i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Uvec4{ x:x74, y:y74, z:z74, w:w74, } = e;
                                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x74);
                                              *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y74);
                                              *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z74);
                                              *((base + 40) as *mut i32) = wit_bindgen::rt::as_i32(w74);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeIvec2(e) => {
                                          *((base + 16) as *mut u8) = (22i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Ivec2{ x:x75, y:y75, } = e;
                                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x75);
                                              *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y75);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeIvec3(e) => {
                                          *((base + 16) as *mut u8) = (23i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Ivec3{ x:x76, y:y76, z:z76, } = e;
                                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x76);
                                              *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y76);
                                              *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z76);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeIvec4(e) => {
                                          *((base + 16) as *mut u8) = (24i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Ivec4{ x:x77, y:y77, z:z77, w:w77, } = e;
                                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x77);
                                              *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y77);
                                              *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z77);
                                              *((base + 40) as *mut i32) = wit_bindgen::rt::as_i32(w77);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeDuration(e) => {
                                          *((base + 16) as *mut u8) = (25i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Duration{ seconds:seconds78, nanoseconds:nanoseconds78, } = e;
                                              *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(seconds78);
                                              *((base + 40) as *mut i32) = wit_bindgen::rt::as_i32(nanoseconds78);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeProceduralMeshHandle(e) => {
                                          *((base + 16) as *mut u8) = (26i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::client_mesh::Handle{ ulid:ulid79, } = e;
                                              let (t80_0, t80_1, ) = ulid79;
                                              *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t80_0);
                                              *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t80_1);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeProceduralTextureHandle(e) => {
                                          *((base + 16) as *mut u8) = (27i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid81, } = e;
                                              let (t82_0, t82_1, ) = ulid81;
                                              *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t82_0);
                                              *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t82_1);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeProceduralSamplerHandle(e) => {
                                          *((base + 16) as *mut u8) = (28i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::client_sampler::Handle{ ulid:ulid83, } = e;
                                              let (t84_0, t84_1, ) = ulid83;
                                              *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t84_0);
                                              *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t84_1);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeProceduralMaterialHandle(e) => {
                                          *((base + 16) as *mut u8) = (29i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::client_material::Handle{ ulid:ulid85, } = e;
                                              let (t86_0, t86_1, ) = ulid85;
                                              *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t86_0);
                                              *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t86_1);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                      };
                                      
                                    },
                                  };
                                  
                                }}
                                
                                #[link(wasm_import_module = "ambient:bindings/component")]
                                extern "C" {
                                  #[cfg_attr(target_arch = "wasm32", link_name = "set-components")]
                                  #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_set-components")]
                                  fn wit_import(
                                  _: i64, _: i64, _: i32, _: i32, );
                                }
                                wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), result87 as i32, len87);
                                if layout87.size() != 0 {
                                  alloc::dealloc(result87, layout87);
                                }
                                for (ptr, layout) in cleanup_list {
                                  
                                  if layout.size() != 0 {
                                    
                                    alloc::dealloc(ptr, layout);
                                    
                                  }
                                  
                                }
                              }
                            }
                            #[allow(clippy::all)]
                            pub fn has_component(entity: EntityId,index: u32,) -> bool{
                              
                              #[allow(unused_imports)]
                              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                              unsafe {
                                let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                                
                                #[link(wasm_import_module = "ambient:bindings/component")]
                                extern "C" {
                                  #[cfg_attr(target_arch = "wasm32", link_name = "has-component")]
                                  #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_has-component")]
                                  fn wit_import(
                                  _: i64, _: i64, _: i32, ) -> i32;
                                }
                                let ret = wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_i32(index));
                                {
                                  #[cfg(not(debug_assertions))]
                                  { ::core::mem::transmute::<u8, bool>(ret as u8) }
                                  #[cfg(debug_assertions)]
                                  {
                                    match ret {
                                      0 => false,
                                      1 => true,
                                      _ => panic!("invalid bool discriminant"),
                                    }
                                  }
                                }
                              }
                            }
                            #[allow(clippy::all)]
                            pub fn has_components(entity: EntityId,indices: &[u32],) -> bool{
                              
                              #[allow(unused_imports)]
                              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                              unsafe {
                                let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                                let vec1 = indices;
                                let ptr1 = vec1.as_ptr() as i32;
                                let len1 = vec1.len() as i32;
                                
                                #[link(wasm_import_module = "ambient:bindings/component")]
                                extern "C" {
                                  #[cfg_attr(target_arch = "wasm32", link_name = "has-components")]
                                  #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_has-components")]
                                  fn wit_import(
                                  _: i64, _: i64, _: i32, _: i32, ) -> i32;
                                }
                                let ret = wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), ptr1, len1);
                                {
                                  #[cfg(not(debug_assertions))]
                                  { ::core::mem::transmute::<u8, bool>(ret as u8) }
                                  #[cfg(debug_assertions)]
                                  {
                                    match ret {
                                      0 => false,
                                      1 => true,
                                      _ => panic!("invalid bool discriminant"),
                                    }
                                  }
                                }
                              }
                            }
                            #[allow(clippy::all)]
                            pub fn remove_component(entity: EntityId,index: u32,){
                              
                              #[allow(unused_imports)]
                              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                              unsafe {
                                let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                                
                                #[link(wasm_import_module = "ambient:bindings/component")]
                                extern "C" {
                                  #[cfg_attr(target_arch = "wasm32", link_name = "remove-component")]
                                  #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_remove-component")]
                                  fn wit_import(
                                  _: i64, _: i64, _: i32, );
                                }
                                wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_i32(index));
                              }
                            }
                            #[allow(clippy::all)]
                            pub fn remove_components(entity: EntityId,indices: &[u32],){
                              
                              #[allow(unused_imports)]
                              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                              unsafe {
                                let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                                let vec1 = indices;
                                let ptr1 = vec1.as_ptr() as i32;
                                let len1 = vec1.len() as i32;
                                
                                #[link(wasm_import_module = "ambient:bindings/component")]
                                extern "C" {
                                  #[cfg_attr(target_arch = "wasm32", link_name = "remove-components")]
                                  #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_remove-components")]
                                  fn wit_import(
                                  _: i64, _: i64, _: i32, _: i32, );
                                }
                                wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), ptr1, len1);
                              }
                            }
                            #[allow(clippy::all)]
                            pub fn query(q: &QueryBuild,t: QueryEvent,) -> u64{
                              
                              #[allow(unused_imports)]
                              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                              unsafe {
                                let QueryBuild{ components:components0, includes:includes0, excludes:excludes0, changed:changed0, } = q;
                                let vec1 = components0;
                                let ptr1 = vec1.as_ptr() as i32;
                                let len1 = vec1.len() as i32;
                                let vec2 = includes0;
                                let ptr2 = vec2.as_ptr() as i32;
                                let len2 = vec2.len() as i32;
                                let vec3 = excludes0;
                                let ptr3 = vec3.as_ptr() as i32;
                                let len3 = vec3.len() as i32;
                                let vec4 = changed0;
                                let ptr4 = vec4.as_ptr() as i32;
                                let len4 = vec4.len() as i32;
                                
                                #[link(wasm_import_module = "ambient:bindings/component")]
                                extern "C" {
                                  #[cfg_attr(target_arch = "wasm32", link_name = "query")]
                                  #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_query")]
                                  fn wit_import(
                                  _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ) -> i64;
                                }
                                let ret = wit_import(ptr1, len1, ptr2, len2, ptr3, len3, ptr4, len4, match t {
                                  QueryEvent::Frame => 0,
                                  QueryEvent::Spawn => 1,
                                  QueryEvent::Despawn => 2,
                                });
                                ret as u64
                              }
                            }
                            #[allow(clippy::all)]
                            pub fn query_eval(q: u64,) -> wit_bindgen::rt::vec::Vec::<(EntityId,wit_bindgen::rt::vec::Vec::<Value>,)>{
                              
                              #[allow(unused_imports)]
                              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                              unsafe {
                                
                                #[repr(align(4))]
                                struct RetArea([u8; 8]);
                                let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                let ptr0 = ret_area.as_mut_ptr() as i32;
                                #[link(wasm_import_module = "ambient:bindings/component")]
                                extern "C" {
                                  #[cfg_attr(target_arch = "wasm32", link_name = "query-eval")]
                                  #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_query-eval")]
                                  fn wit_import(
                                  _: i64, _: i32, );
                                }
                                wit_import(wit_bindgen::rt::as_i64(q), ptr0);
                                let base35 = *((ptr0 + 0) as *const i32);
                                let len35 = *((ptr0 + 4) as *const i32);
                                let mut result35 = Vec::with_capacity(len35 as usize);
                                for i in 0..len35 {
                                  let base = base35 + i *24;
                                  result35.push({
                                    let base34 = *((base + 16) as *const i32);
                                    let len34 = *((base + 20) as *const i32);
                                    let mut result34 = Vec::with_capacity(len34 as usize);
                                    for i in 0..len34 {
                                      let base = base34 + i *88;
                                      result34.push({{match i32::from(*((base + 0) as *const u8)) {
                                        0 => Value::TypeEmpty(super::super::super::ambient::bindings::types::Empty{dummy:i32::from(*((base + 8) as *const u8)) as u8, }),
                                        1 => Value::TypeBool({
                                          #[cfg(not(debug_assertions))]
                                          { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 8) as *const u8)) as u8) }
                                          #[cfg(debug_assertions)]
                                          {
                                            match i32::from(*((base + 8) as *const u8)) {
                                              0 => false,
                                              1 => true,
                                              _ => panic!("invalid bool discriminant"),
                                            }
                                          }
                                        }),
                                        2 => Value::TypeEntityId(super::super::super::ambient::bindings::types::EntityId{id0:*((base + 8) as *const i64) as u64, id1:*((base + 16) as *const i64) as u64, }),
                                        3 => Value::TypeF32(*((base + 8) as *const f32)),
                                        4 => Value::TypeF64(*((base + 8) as *const f64)),
                                        5 => Value::TypeMat4(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((base + 8) as *const f32), y:*((base + 12) as *const f32), z:*((base + 16) as *const f32), w:*((base + 20) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((base + 24) as *const f32), y:*((base + 28) as *const f32), z:*((base + 32) as *const f32), w:*((base + 36) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((base + 40) as *const f32), y:*((base + 44) as *const f32), z:*((base + 48) as *const f32), w:*((base + 52) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((base + 56) as *const f32), y:*((base + 60) as *const f32), z:*((base + 64) as *const f32), w:*((base + 68) as *const f32), }, }),
                                        6 => Value::TypeQuat(super::super::super::ambient::bindings::types::Quat{x:*((base + 8) as *const f32), y:*((base + 12) as *const f32), z:*((base + 16) as *const f32), w:*((base + 20) as *const f32), }),
                                        7 => Value::TypeString({
                                          let len1 = *((base + 12) as *const i32) as usize;
                                          
                                          {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 8) as *const i32) as *mut _, len1, len1))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 8) as *const i32) as *mut _, len1, len1)).unwrap()}}
                                        }),
                                        8 => Value::TypeU8(i32::from(*((base + 8) as *const u8)) as u8),
                                        9 => Value::TypeU16(i32::from(*((base + 8) as *const u16)) as u16),
                                        10 => Value::TypeU32(*((base + 8) as *const i32) as u32),
                                        11 => Value::TypeU64(*((base + 8) as *const i64) as u64),
                                        12 => Value::TypeI8(i32::from(*((base + 8) as *const i8)) as i8),
                                        13 => Value::TypeI16(i32::from(*((base + 8) as *const i16)) as i16),
                                        14 => Value::TypeI32(*((base + 8) as *const i32)),
                                        15 => Value::TypeI64(*((base + 8) as *const i64)),
                                        16 => Value::TypeVec2(super::super::super::ambient::bindings::types::Vec2{x:*((base + 8) as *const f32), y:*((base + 12) as *const f32), }),
                                        17 => Value::TypeVec3(super::super::super::ambient::bindings::types::Vec3{x:*((base + 8) as *const f32), y:*((base + 12) as *const f32), z:*((base + 16) as *const f32), }),
                                        18 => Value::TypeVec4(super::super::super::ambient::bindings::types::Vec4{x:*((base + 8) as *const f32), y:*((base + 12) as *const f32), z:*((base + 16) as *const f32), w:*((base + 20) as *const f32), }),
                                        19 => Value::TypeUvec2(super::super::super::ambient::bindings::types::Uvec2{x:*((base + 8) as *const i32) as u32, y:*((base + 12) as *const i32) as u32, }),
                                        20 => Value::TypeUvec3(super::super::super::ambient::bindings::types::Uvec3{x:*((base + 8) as *const i32) as u32, y:*((base + 12) as *const i32) as u32, z:*((base + 16) as *const i32) as u32, }),
                                        21 => Value::TypeUvec4(super::super::super::ambient::bindings::types::Uvec4{x:*((base + 8) as *const i32) as u32, y:*((base + 12) as *const i32) as u32, z:*((base + 16) as *const i32) as u32, w:*((base + 20) as *const i32) as u32, }),
                                        22 => Value::TypeIvec2(super::super::super::ambient::bindings::types::Ivec2{x:*((base + 8) as *const i32), y:*((base + 12) as *const i32), }),
                                        23 => Value::TypeIvec3(super::super::super::ambient::bindings::types::Ivec3{x:*((base + 8) as *const i32), y:*((base + 12) as *const i32), z:*((base + 16) as *const i32), }),
                                        24 => Value::TypeIvec4(super::super::super::ambient::bindings::types::Ivec4{x:*((base + 8) as *const i32), y:*((base + 12) as *const i32), z:*((base + 16) as *const i32), w:*((base + 20) as *const i32), }),
                                        25 => Value::TypeDuration(super::super::super::ambient::bindings::types::Duration{seconds:*((base + 8) as *const i64) as u64, nanoseconds:*((base + 16) as *const i32) as u32, }),
                                        26 => Value::TypeProceduralMeshHandle(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((base + 8) as *const i64) as u64, *((base + 16) as *const i64) as u64), }),
                                        27 => Value::TypeProceduralTextureHandle(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((base + 8) as *const i64) as u64, *((base + 16) as *const i64) as u64), }),
                                        28 => Value::TypeProceduralSamplerHandle(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((base + 8) as *const i64) as u64, *((base + 16) as *const i64) as u64), }),
                                        29 => Value::TypeProceduralMaterialHandle(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 8) as *const i64) as u64, *((base + 16) as *const i64) as u64), }),
                                        30 => Value::TypeVec({{match i32::from(*((base + 8) as *const u8)) {
                                          0 => VecValue::TypeEmpty({
                                            let len2 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len2, len2)
                                          }),
                                          1 => VecValue::TypeBool({
                                            let base3 = *((base + 12) as *const i32);
                                            let len3 = *((base + 16) as *const i32);
                                            let mut result3 = Vec::with_capacity(len3 as usize);
                                            for i in 0..len3 {
                                              let base = base3 + i *1;
                                              result3.push({
                                                #[cfg(not(debug_assertions))]
                                                { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 0) as *const u8)) as u8) }
                                                #[cfg(debug_assertions)]
                                                {
                                                  match i32::from(*((base + 0) as *const u8)) {
                                                    0 => false,
                                                    1 => true,
                                                    _ => panic!("invalid bool discriminant"),
                                                  }
                                                }
                                              });
                                            }
                                            wit_bindgen::rt::dealloc(base3, (len3 as usize) * 1, 1);
                                            
                                            result3
                                          }),
                                          2 => VecValue::TypeEntityId({
                                            let len4 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len4, len4)
                                          }),
                                          3 => VecValue::TypeF32({
                                            let len5 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len5, len5)
                                          }),
                                          4 => VecValue::TypeF64({
                                            let len6 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len6, len6)
                                          }),
                                          5 => VecValue::TypeMat4({
                                            let len7 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len7, len7)
                                          }),
                                          6 => VecValue::TypeQuat({
                                            let len8 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len8, len8)
                                          }),
                                          7 => VecValue::TypeString({
                                            let base10 = *((base + 12) as *const i32);
                                            let len10 = *((base + 16) as *const i32);
                                            let mut result10 = Vec::with_capacity(len10 as usize);
                                            for i in 0..len10 {
                                              let base = base10 + i *8;
                                              result10.push({
                                                let len9 = *((base + 4) as *const i32) as usize;
                                                
                                                {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len9, len9))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len9, len9)).unwrap()}}
                                              });
                                            }
                                            wit_bindgen::rt::dealloc(base10, (len10 as usize) * 8, 4);
                                            
                                            result10
                                          }),
                                          8 => VecValue::TypeU8({
                                            let len11 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len11, len11)
                                          }),
                                          9 => VecValue::TypeU16({
                                            let len12 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len12, len12)
                                          }),
                                          10 => VecValue::TypeU32({
                                            let len13 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len13, len13)
                                          }),
                                          11 => VecValue::TypeU64({
                                            let len14 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len14, len14)
                                          }),
                                          12 => VecValue::TypeI8({
                                            let len15 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len15, len15)
                                          }),
                                          13 => VecValue::TypeI16({
                                            let len16 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len16, len16)
                                          }),
                                          14 => VecValue::TypeI32({
                                            let len17 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len17, len17)
                                          }),
                                          15 => VecValue::TypeI64({
                                            let len18 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len18, len18)
                                          }),
                                          16 => VecValue::TypeVec2({
                                            let len19 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len19, len19)
                                          }),
                                          17 => VecValue::TypeVec3({
                                            let len20 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len20, len20)
                                          }),
                                          18 => VecValue::TypeVec4({
                                            let len21 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len21, len21)
                                          }),
                                          19 => VecValue::TypeUvec2({
                                            let len22 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len22, len22)
                                          }),
                                          20 => VecValue::TypeUvec3({
                                            let len23 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len23, len23)
                                          }),
                                          21 => VecValue::TypeUvec4({
                                            let len24 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len24, len24)
                                          }),
                                          22 => VecValue::TypeIvec2({
                                            let len25 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len25, len25)
                                          }),
                                          23 => VecValue::TypeIvec3({
                                            let len26 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len26, len26)
                                          }),
                                          24 => VecValue::TypeIvec4({
                                            let len27 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len27, len27)
                                          }),
                                          25 => VecValue::TypeDuration({
                                            let len28 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len28, len28)
                                          }),
                                          26 => VecValue::TypeProceduralMeshHandle({
                                            let len29 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len29, len29)
                                          }),
                                          27 => VecValue::TypeProceduralTextureHandle({
                                            let len30 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len30, len30)
                                          }),
                                          28 => VecValue::TypeProceduralSamplerHandle({
                                            let len31 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len31, len31)
                                          }),
                                          #[cfg(debug_assertions)]29 => VecValue::TypeProceduralMaterialHandle({
                                            let len32 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len32, len32)
                                          }),
                                          #[cfg(not(debug_assertions))]_ => VecValue::TypeProceduralMaterialHandle({
                                            let len32 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len32, len32)
                                          }),
                                          #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                        }}}),
                                        #[cfg(debug_assertions)]31 => Value::TypeOption({{match i32::from(*((base + 8) as *const u8)) {
                                          0 => OptionValue::TypeEmpty(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Empty{dummy:i32::from(*((base + 17) as *const u8)) as u8, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          1 => OptionValue::TypeBool(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some({
                                              #[cfg(not(debug_assertions))]
                                              { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 17) as *const u8)) as u8) }
                                              #[cfg(debug_assertions)]
                                              {
                                                match i32::from(*((base + 17) as *const u8)) {
                                                  0 => false,
                                                  1 => true,
                                                  _ => panic!("invalid bool discriminant"),
                                                }
                                              }
                                            }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          2 => OptionValue::TypeEntityId(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::EntityId{id0:*((base + 24) as *const i64) as u64, id1:*((base + 32) as *const i64) as u64, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          3 => OptionValue::TypeF32(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 20) as *const f32)),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          4 => OptionValue::TypeF64(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 24) as *const f64)),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          5 => OptionValue::TypeMat4(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((base + 36) as *const f32), y:*((base + 40) as *const f32), z:*((base + 44) as *const f32), w:*((base + 48) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((base + 52) as *const f32), y:*((base + 56) as *const f32), z:*((base + 60) as *const f32), w:*((base + 64) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((base + 68) as *const f32), y:*((base + 72) as *const f32), z:*((base + 76) as *const f32), w:*((base + 80) as *const f32), }, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          6 => OptionValue::TypeQuat(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Quat{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          7 => OptionValue::TypeString(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some({
                                              let len33 = *((base + 24) as *const i32) as usize;
                                              
                                              {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len33, len33))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len33, len33)).unwrap()}}
                                            }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          8 => OptionValue::TypeU8(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(i32::from(*((base + 17) as *const u8)) as u8),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          9 => OptionValue::TypeU16(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(i32::from(*((base + 18) as *const u16)) as u16),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          10 => OptionValue::TypeU32(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 20) as *const i32) as u32),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          11 => OptionValue::TypeU64(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 24) as *const i64) as u64),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          12 => OptionValue::TypeI8(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(i32::from(*((base + 17) as *const i8)) as i8),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          13 => OptionValue::TypeI16(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(i32::from(*((base + 18) as *const i16)) as i16),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          14 => OptionValue::TypeI32(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 20) as *const i32)),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          15 => OptionValue::TypeI64(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 24) as *const i64)),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          16 => OptionValue::TypeVec2(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Vec2{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          17 => OptionValue::TypeVec3(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Vec3{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          18 => OptionValue::TypeVec4(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Vec4{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          19 => OptionValue::TypeUvec2(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Uvec2{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          20 => OptionValue::TypeUvec3(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Uvec3{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, z:*((base + 28) as *const i32) as u32, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          21 => OptionValue::TypeUvec4(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Uvec4{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, z:*((base + 28) as *const i32) as u32, w:*((base + 32) as *const i32) as u32, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          22 => OptionValue::TypeIvec2(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Ivec2{x:*((base + 20) as *const i32), y:*((base + 24) as *const i32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          23 => OptionValue::TypeIvec3(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Ivec3{x:*((base + 20) as *const i32), y:*((base + 24) as *const i32), z:*((base + 28) as *const i32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          24 => OptionValue::TypeIvec4(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Ivec4{x:*((base + 20) as *const i32), y:*((base + 24) as *const i32), z:*((base + 28) as *const i32), w:*((base + 32) as *const i32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          25 => OptionValue::TypeDuration(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Duration{seconds:*((base + 24) as *const i64) as u64, nanoseconds:*((base + 32) as *const i32) as u32, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          26 => OptionValue::TypeProceduralMeshHandle(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          27 => OptionValue::TypeProceduralTextureHandle(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          28 => OptionValue::TypeProceduralSamplerHandle(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          #[cfg(debug_assertions)]29 => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          #[cfg(not(debug_assertions))]_ => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                        }}}),
                                        #[cfg(not(debug_assertions))]_ => Value::TypeOption({{match i32::from(*((base + 8) as *const u8)) {
                                          0 => OptionValue::TypeEmpty(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Empty{dummy:i32::from(*((base + 17) as *const u8)) as u8, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          1 => OptionValue::TypeBool(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some({
                                              #[cfg(not(debug_assertions))]
                                              { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 17) as *const u8)) as u8) }
                                              #[cfg(debug_assertions)]
                                              {
                                                match i32::from(*((base + 17) as *const u8)) {
                                                  0 => false,
                                                  1 => true,
                                                  _ => panic!("invalid bool discriminant"),
                                                }
                                              }
                                            }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          2 => OptionValue::TypeEntityId(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::EntityId{id0:*((base + 24) as *const i64) as u64, id1:*((base + 32) as *const i64) as u64, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          3 => OptionValue::TypeF32(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 20) as *const f32)),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          4 => OptionValue::TypeF64(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 24) as *const f64)),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          5 => OptionValue::TypeMat4(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((base + 36) as *const f32), y:*((base + 40) as *const f32), z:*((base + 44) as *const f32), w:*((base + 48) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((base + 52) as *const f32), y:*((base + 56) as *const f32), z:*((base + 60) as *const f32), w:*((base + 64) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((base + 68) as *const f32), y:*((base + 72) as *const f32), z:*((base + 76) as *const f32), w:*((base + 80) as *const f32), }, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          6 => OptionValue::TypeQuat(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Quat{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          7 => OptionValue::TypeString(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some({
                                              let len33 = *((base + 24) as *const i32) as usize;
                                              
                                              {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len33, len33))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len33, len33)).unwrap()}}
                                            }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          8 => OptionValue::TypeU8(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(i32::from(*((base + 17) as *const u8)) as u8),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          9 => OptionValue::TypeU16(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(i32::from(*((base + 18) as *const u16)) as u16),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          10 => OptionValue::TypeU32(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 20) as *const i32) as u32),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          11 => OptionValue::TypeU64(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 24) as *const i64) as u64),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          12 => OptionValue::TypeI8(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(i32::from(*((base + 17) as *const i8)) as i8),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          13 => OptionValue::TypeI16(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(i32::from(*((base + 18) as *const i16)) as i16),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          14 => OptionValue::TypeI32(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 20) as *const i32)),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          15 => OptionValue::TypeI64(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 24) as *const i64)),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          16 => OptionValue::TypeVec2(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Vec2{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          17 => OptionValue::TypeVec3(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Vec3{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          18 => OptionValue::TypeVec4(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Vec4{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          19 => OptionValue::TypeUvec2(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Uvec2{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          20 => OptionValue::TypeUvec3(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Uvec3{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, z:*((base + 28) as *const i32) as u32, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          21 => OptionValue::TypeUvec4(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Uvec4{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, z:*((base + 28) as *const i32) as u32, w:*((base + 32) as *const i32) as u32, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          22 => OptionValue::TypeIvec2(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Ivec2{x:*((base + 20) as *const i32), y:*((base + 24) as *const i32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          23 => OptionValue::TypeIvec3(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Ivec3{x:*((base + 20) as *const i32), y:*((base + 24) as *const i32), z:*((base + 28) as *const i32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          24 => OptionValue::TypeIvec4(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Ivec4{x:*((base + 20) as *const i32), y:*((base + 24) as *const i32), z:*((base + 28) as *const i32), w:*((base + 32) as *const i32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          25 => OptionValue::TypeDuration(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Duration{seconds:*((base + 24) as *const i64) as u64, nanoseconds:*((base + 32) as *const i32) as u32, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          26 => OptionValue::TypeProceduralMeshHandle(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          27 => OptionValue::TypeProceduralTextureHandle(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          28 => OptionValue::TypeProceduralSamplerHandle(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          #[cfg(debug_assertions)]29 => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          #[cfg(not(debug_assertions))]_ => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                        }}}),
                                        #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                      }}});
                                    }
                                    wit_bindgen::rt::dealloc(base34, (len34 as usize) * 88, 8);
                                    
                                    (super::super::super::ambient::bindings::types::EntityId{id0:*((base + 0) as *const i64) as u64, id1:*((base + 8) as *const i64) as u64, }, result34)
                                  });
                                }
                                wit_bindgen::rt::dealloc(base35, (len35 as usize) * 24, 8);
                                result35
                              }
                            }
                            
                          }
                          
                          
                          #[allow(clippy::all)]
                          pub mod entity {
                            #[used]
                            #[doc(hidden)]
                            #[cfg(target_arch = "wasm32")]
                            static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
                            
                            pub type EntityId = super::super::super::ambient::bindings::types::EntityId;
                            pub type Vec3 = super::super::super::ambient::bindings::types::Vec3;
                            pub type Mat4 = super::super::super::ambient::bindings::types::Mat4;
                            pub type EntityData = super::super::super::ambient::bindings::component::Entity;
                            #[allow(clippy::all)]
                            pub fn get_transforms_relative_to(entities: &[EntityId],origin: EntityId,) -> wit_bindgen::rt::vec::Vec::<Mat4>{
                              
                              #[allow(unused_imports)]
                              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                              unsafe {
                                
                                #[repr(align(4))]
                                struct RetArea([u8; 8]);
                                let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                let vec0 = entities;
                                let ptr0 = vec0.as_ptr() as i32;
                                let len0 = vec0.len() as i32;
                                let super::super::super::ambient::bindings::types::EntityId{ id0:id01, id1:id11, } = origin;
                                let ptr2 = ret_area.as_mut_ptr() as i32;
                                #[link(wasm_import_module = "ambient:bindings/entity")]
                                extern "C" {
                                  #[cfg_attr(target_arch = "wasm32", link_name = "get-transforms-relative-to")]
                                  #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/entity_get-transforms-relative-to")]
                                  fn wit_import(
                                  _: i32, _: i32, _: i64, _: i64, _: i32, );
                                }
                                wit_import(ptr0, len0, wit_bindgen::rt::as_i64(id01), wit_bindgen::rt::as_i64(id11), ptr2);
                                let len3 = *((ptr2 + 4) as *const i32) as usize;
                                Vec::from_raw_parts(*((ptr2 + 0) as *const i32) as *mut _, len3, len3)
                              }
                            }
                            #[allow(clippy::all)]
                            pub fn spawn(data: &EntityData,) -> EntityId{
                              
                              #[allow(unused_imports)]
                              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                              unsafe {
                                let mut cleanup_list = Vec::new();
                                
                                #[repr(align(8))]
                                struct RetArea([u8; 16]);
                                let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                let vec86 = data;
                                let len86 = vec86.len() as i32;
                                let layout86 = alloc::Layout::from_size_align_unchecked(vec86.len() * 96, 8);
                                let result86 = if layout86.size() != 0
                                {
                                  let ptr = alloc::alloc(layout86);
                                  if ptr.is_null()
                                  {
                                    alloc::handle_alloc_error(layout86);
                                  }
                                  ptr
                                }else {
                                  ::core::ptr::null_mut()
                                };
                                for (i, e) in vec86.into_iter().enumerate() {
                                  let base = result86 as i32 + (i as i32) * 96;
                                  {
                                    let (t0_0, t0_1, ) = e;
                                    *((base + 0) as *mut i32) = wit_bindgen::rt::as_i32(t0_0);
                                    match t0_1 {
                                      super::super::super::ambient::bindings::component::Value::TypeEmpty(e) => {
                                        *((base + 8) as *mut u8) = (0i32) as u8;
                                        let super::super::super::ambient::bindings::types::Empty{ dummy:dummy1, } = e;
                                        *((base + 16) as *mut u8) = (wit_bindgen::rt::as_i32(dummy1)) as u8;
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeBool(e) => {
                                        *((base + 8) as *mut u8) = (1i32) as u8;
                                        *((base + 16) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeEntityId(e) => {
                                        *((base + 8) as *mut u8) = (2i32) as u8;
                                        let super::super::super::ambient::bindings::types::EntityId{ id0:id02, id1:id12, } = e;
                                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(id02);
                                        *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(id12);
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeF32(e) => {
                                        *((base + 8) as *mut u8) = (3i32) as u8;
                                        *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(e);
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeF64(e) => {
                                        *((base + 8) as *mut u8) = (4i32) as u8;
                                        *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeMat4(e) => {
                                        *((base + 8) as *mut u8) = (5i32) as u8;
                                        let super::super::super::ambient::bindings::types::Mat4{ x:x3, y:y3, z:z3, w:w3, } = e;
                                        let super::super::super::ambient::bindings::types::Vec4{ x:x4, y:y4, z:z4, w:w4, } = x3;
                                        *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x4);
                                        *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y4);
                                        *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z4);
                                        *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w4);
                                        let super::super::super::ambient::bindings::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = y3;
                                        *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(x5);
                                        *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(y5);
                                        *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(z5);
                                        *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(w5);
                                        let super::super::super::ambient::bindings::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = z3;
                                        *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(x6);
                                        *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(y6);
                                        *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(z6);
                                        *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(w6);
                                        let super::super::super::ambient::bindings::types::Vec4{ x:x7, y:y7, z:z7, w:w7, } = w3;
                                        *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(x7);
                                        *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(y7);
                                        *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(z7);
                                        *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(w7);
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeQuat(e) => {
                                        *((base + 8) as *mut u8) = (6i32) as u8;
                                        let super::super::super::ambient::bindings::types::Quat{ x:x8, y:y8, z:z8, w:w8, } = e;
                                        *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x8);
                                        *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y8);
                                        *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z8);
                                        *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w8);
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeString(e) => {
                                        *((base + 8) as *mut u8) = (7i32) as u8;
                                        let vec9 = e;
                                        let ptr9 = vec9.as_ptr() as i32;
                                        let len9 = vec9.len() as i32;
                                        *((base + 20) as *mut i32) = len9;
                                        *((base + 16) as *mut i32) = ptr9;
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeU8(e) => {
                                        *((base + 8) as *mut u8) = (8i32) as u8;
                                        *((base + 16) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeU16(e) => {
                                        *((base + 8) as *mut u8) = (9i32) as u8;
                                        *((base + 16) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeU32(e) => {
                                        *((base + 8) as *mut u8) = (10i32) as u8;
                                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeU64(e) => {
                                        *((base + 8) as *mut u8) = (11i32) as u8;
                                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeI8(e) => {
                                        *((base + 8) as *mut u8) = (12i32) as u8;
                                        *((base + 16) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeI16(e) => {
                                        *((base + 8) as *mut u8) = (13i32) as u8;
                                        *((base + 16) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeI32(e) => {
                                        *((base + 8) as *mut u8) = (14i32) as u8;
                                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeI64(e) => {
                                        *((base + 8) as *mut u8) = (15i32) as u8;
                                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeVec2(e) => {
                                        *((base + 8) as *mut u8) = (16i32) as u8;
                                        let super::super::super::ambient::bindings::types::Vec2{ x:x10, y:y10, } = e;
                                        *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x10);
                                        *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y10);
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeVec3(e) => {
                                        *((base + 8) as *mut u8) = (17i32) as u8;
                                        let super::super::super::ambient::bindings::types::Vec3{ x:x11, y:y11, z:z11, } = e;
                                        *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x11);
                                        *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y11);
                                        *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z11);
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeVec4(e) => {
                                        *((base + 8) as *mut u8) = (18i32) as u8;
                                        let super::super::super::ambient::bindings::types::Vec4{ x:x12, y:y12, z:z12, w:w12, } = e;
                                        *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x12);
                                        *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y12);
                                        *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z12);
                                        *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w12);
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeUvec2(e) => {
                                        *((base + 8) as *mut u8) = (19i32) as u8;
                                        let super::super::super::ambient::bindings::types::Uvec2{ x:x13, y:y13, } = e;
                                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x13);
                                        *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y13);
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeUvec3(e) => {
                                        *((base + 8) as *mut u8) = (20i32) as u8;
                                        let super::super::super::ambient::bindings::types::Uvec3{ x:x14, y:y14, z:z14, } = e;
                                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x14);
                                        *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y14);
                                        *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z14);
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeUvec4(e) => {
                                        *((base + 8) as *mut u8) = (21i32) as u8;
                                        let super::super::super::ambient::bindings::types::Uvec4{ x:x15, y:y15, z:z15, w:w15, } = e;
                                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x15);
                                        *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y15);
                                        *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z15);
                                        *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(w15);
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeIvec2(e) => {
                                        *((base + 8) as *mut u8) = (22i32) as u8;
                                        let super::super::super::ambient::bindings::types::Ivec2{ x:x16, y:y16, } = e;
                                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x16);
                                        *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y16);
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeIvec3(e) => {
                                        *((base + 8) as *mut u8) = (23i32) as u8;
                                        let super::super::super::ambient::bindings::types::Ivec3{ x:x17, y:y17, z:z17, } = e;
                                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x17);
                                        *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y17);
                                        *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z17);
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeIvec4(e) => {
                                        *((base + 8) as *mut u8) = (24i32) as u8;
                                        let super::super::super::ambient::bindings::types::Ivec4{ x:x18, y:y18, z:z18, w:w18, } = e;
                                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x18);
                                        *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y18);
                                        *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z18);
                                        *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(w18);
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeDuration(e) => {
                                        *((base + 8) as *mut u8) = (25i32) as u8;
                                        let super::super::super::ambient::bindings::types::Duration{ seconds:seconds19, nanoseconds:nanoseconds19, } = e;
                                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(seconds19);
                                        *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(nanoseconds19);
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeProceduralMeshHandle(e) => {
                                        *((base + 8) as *mut u8) = (26i32) as u8;
                                        let super::super::super::ambient::bindings::client_mesh::Handle{ ulid:ulid20, } = e;
                                        let (t21_0, t21_1, ) = ulid20;
                                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t21_0);
                                        *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t21_1);
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeProceduralTextureHandle(e) => {
                                        *((base + 8) as *mut u8) = (27i32) as u8;
                                        let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid22, } = e;
                                        let (t23_0, t23_1, ) = ulid22;
                                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t23_0);
                                        *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t23_1);
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeProceduralSamplerHandle(e) => {
                                        *((base + 8) as *mut u8) = (28i32) as u8;
                                        let super::super::super::ambient::bindings::client_sampler::Handle{ ulid:ulid24, } = e;
                                        let (t25_0, t25_1, ) = ulid24;
                                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t25_0);
                                        *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t25_1);
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeProceduralMaterialHandle(e) => {
                                        *((base + 8) as *mut u8) = (29i32) as u8;
                                        let super::super::super::ambient::bindings::client_material::Handle{ ulid:ulid26, } = e;
                                        let (t27_0, t27_1, ) = ulid26;
                                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t27_0);
                                        *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t27_1);
                                        
                                      },
                                      super::super::super::ambient::bindings::component::Value::TypeVec(e) => {
                                        *((base + 8) as *mut u8) = (30i32) as u8;
                                        match e {
                                          super::super::super::ambient::bindings::component::VecValue::TypeEmpty(e) => {
                                            *((base + 16) as *mut u8) = (0i32) as u8;
                                            let vec28 = e;
                                            let ptr28 = vec28.as_ptr() as i32;
                                            let len28 = vec28.len() as i32;
                                            *((base + 24) as *mut i32) = len28;
                                            *((base + 20) as *mut i32) = ptr28;
                                            
                                          },
                                          super::super::super::ambient::bindings::component::VecValue::TypeBool(e) => {
                                            *((base + 16) as *mut u8) = (1i32) as u8;
                                            let vec29 = e;
                                            let len29 = vec29.len() as i32;
                                            let layout29 = alloc::Layout::from_size_align_unchecked(vec29.len() * 1, 1);
                                            let result29 = if layout29.size() != 0
                                            {
                                              let ptr = alloc::alloc(layout29);
                                              if ptr.is_null()
                                              {
                                                alloc::handle_alloc_error(layout29);
                                              }
                                              ptr
                                            }else {
                                              ::core::ptr::null_mut()
                                            };
                                            for (i, e) in vec29.into_iter().enumerate() {
                                              let base = result29 as i32 + (i as i32) * 1;
                                              {
                                                *((base + 0) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                                
                                              }}
                                              *((base + 24) as *mut i32) = len29;
                                              *((base + 20) as *mut i32) = result29 as i32;
                                              cleanup_list.extend_from_slice(&[(result29, layout29),]);
                                              
                                            },
                                            super::super::super::ambient::bindings::component::VecValue::TypeEntityId(e) => {
                                              *((base + 16) as *mut u8) = (2i32) as u8;
                                              let vec30 = e;
                                              let ptr30 = vec30.as_ptr() as i32;
                                              let len30 = vec30.len() as i32;
                                              *((base + 24) as *mut i32) = len30;
                                              *((base + 20) as *mut i32) = ptr30;
                                              
                                            },
                                            super::super::super::ambient::bindings::component::VecValue::TypeF32(e) => {
                                              *((base + 16) as *mut u8) = (3i32) as u8;
                                              let vec31 = e;
                                              let ptr31 = vec31.as_ptr() as i32;
                                              let len31 = vec31.len() as i32;
                                              *((base + 24) as *mut i32) = len31;
                                              *((base + 20) as *mut i32) = ptr31;
                                              
                                            },
                                            super::super::super::ambient::bindings::component::VecValue::TypeF64(e) => {
                                              *((base + 16) as *mut u8) = (4i32) as u8;
                                              let vec32 = e;
                                              let ptr32 = vec32.as_ptr() as i32;
                                              let len32 = vec32.len() as i32;
                                              *((base + 24) as *mut i32) = len32;
                                              *((base + 20) as *mut i32) = ptr32;
                                              
                                            },
                                            super::super::super::ambient::bindings::component::VecValue::TypeMat4(e) => {
                                              *((base + 16) as *mut u8) = (5i32) as u8;
                                              let vec33 = e;
                                              let ptr33 = vec33.as_ptr() as i32;
                                              let len33 = vec33.len() as i32;
                                              *((base + 24) as *mut i32) = len33;
                                              *((base + 20) as *mut i32) = ptr33;
                                              
                                            },
                                            super::super::super::ambient::bindings::component::VecValue::TypeQuat(e) => {
                                              *((base + 16) as *mut u8) = (6i32) as u8;
                                              let vec34 = e;
                                              let ptr34 = vec34.as_ptr() as i32;
                                              let len34 = vec34.len() as i32;
                                              *((base + 24) as *mut i32) = len34;
                                              *((base + 20) as *mut i32) = ptr34;
                                              
                                            },
                                            super::super::super::ambient::bindings::component::VecValue::TypeString(e) => {
                                              *((base + 16) as *mut u8) = (7i32) as u8;
                                              let vec36 = e;
                                              let len36 = vec36.len() as i32;
                                              let layout36 = alloc::Layout::from_size_align_unchecked(vec36.len() * 8, 4);
                                              let result36 = if layout36.size() != 0
                                              {
                                                let ptr = alloc::alloc(layout36);
                                                if ptr.is_null()
                                                {
                                                  alloc::handle_alloc_error(layout36);
                                                }
                                                ptr
                                              }else {
                                                ::core::ptr::null_mut()
                                              };
                                              for (i, e) in vec36.into_iter().enumerate() {
                                                let base = result36 as i32 + (i as i32) * 8;
                                                {
                                                  let vec35 = e;
                                                  let ptr35 = vec35.as_ptr() as i32;
                                                  let len35 = vec35.len() as i32;
                                                  *((base + 4) as *mut i32) = len35;
                                                  *((base + 0) as *mut i32) = ptr35;
                                                  
                                                }}
                                                *((base + 24) as *mut i32) = len36;
                                                *((base + 20) as *mut i32) = result36 as i32;
                                                cleanup_list.extend_from_slice(&[(result36, layout36),]);
                                                
                                              },
                                              super::super::super::ambient::bindings::component::VecValue::TypeU8(e) => {
                                                *((base + 16) as *mut u8) = (8i32) as u8;
                                                let vec37 = e;
                                                let ptr37 = vec37.as_ptr() as i32;
                                                let len37 = vec37.len() as i32;
                                                *((base + 24) as *mut i32) = len37;
                                                *((base + 20) as *mut i32) = ptr37;
                                                
                                              },
                                              super::super::super::ambient::bindings::component::VecValue::TypeU16(e) => {
                                                *((base + 16) as *mut u8) = (9i32) as u8;
                                                let vec38 = e;
                                                let ptr38 = vec38.as_ptr() as i32;
                                                let len38 = vec38.len() as i32;
                                                *((base + 24) as *mut i32) = len38;
                                                *((base + 20) as *mut i32) = ptr38;
                                                
                                              },
                                              super::super::super::ambient::bindings::component::VecValue::TypeU32(e) => {
                                                *((base + 16) as *mut u8) = (10i32) as u8;
                                                let vec39 = e;
                                                let ptr39 = vec39.as_ptr() as i32;
                                                let len39 = vec39.len() as i32;
                                                *((base + 24) as *mut i32) = len39;
                                                *((base + 20) as *mut i32) = ptr39;
                                                
                                              },
                                              super::super::super::ambient::bindings::component::VecValue::TypeU64(e) => {
                                                *((base + 16) as *mut u8) = (11i32) as u8;
                                                let vec40 = e;
                                                let ptr40 = vec40.as_ptr() as i32;
                                                let len40 = vec40.len() as i32;
                                                *((base + 24) as *mut i32) = len40;
                                                *((base + 20) as *mut i32) = ptr40;
                                                
                                              },
                                              super::super::super::ambient::bindings::component::VecValue::TypeI8(e) => {
                                                *((base + 16) as *mut u8) = (12i32) as u8;
                                                let vec41 = e;
                                                let ptr41 = vec41.as_ptr() as i32;
                                                let len41 = vec41.len() as i32;
                                                *((base + 24) as *mut i32) = len41;
                                                *((base + 20) as *mut i32) = ptr41;
                                                
                                              },
                                              super::super::super::ambient::bindings::component::VecValue::TypeI16(e) => {
                                                *((base + 16) as *mut u8) = (13i32) as u8;
                                                let vec42 = e;
                                                let ptr42 = vec42.as_ptr() as i32;
                                                let len42 = vec42.len() as i32;
                                                *((base + 24) as *mut i32) = len42;
                                                *((base + 20) as *mut i32) = ptr42;
                                                
                                              },
                                              super::super::super::ambient::bindings::component::VecValue::TypeI32(e) => {
                                                *((base + 16) as *mut u8) = (14i32) as u8;
                                                let vec43 = e;
                                                let ptr43 = vec43.as_ptr() as i32;
                                                let len43 = vec43.len() as i32;
                                                *((base + 24) as *mut i32) = len43;
                                                *((base + 20) as *mut i32) = ptr43;
                                                
                                              },
                                              super::super::super::ambient::bindings::component::VecValue::TypeI64(e) => {
                                                *((base + 16) as *mut u8) = (15i32) as u8;
                                                let vec44 = e;
                                                let ptr44 = vec44.as_ptr() as i32;
                                                let len44 = vec44.len() as i32;
                                                *((base + 24) as *mut i32) = len44;
                                                *((base + 20) as *mut i32) = ptr44;
                                                
                                              },
                                              super::super::super::ambient::bindings::component::VecValue::TypeVec2(e) => {
                                                *((base + 16) as *mut u8) = (16i32) as u8;
                                                let vec45 = e;
                                                let ptr45 = vec45.as_ptr() as i32;
                                                let len45 = vec45.len() as i32;
                                                *((base + 24) as *mut i32) = len45;
                                                *((base + 20) as *mut i32) = ptr45;
                                                
                                              },
                                              super::super::super::ambient::bindings::component::VecValue::TypeVec3(e) => {
                                                *((base + 16) as *mut u8) = (17i32) as u8;
                                                let vec46 = e;
                                                let ptr46 = vec46.as_ptr() as i32;
                                                let len46 = vec46.len() as i32;
                                                *((base + 24) as *mut i32) = len46;
                                                *((base + 20) as *mut i32) = ptr46;
                                                
                                              },
                                              super::super::super::ambient::bindings::component::VecValue::TypeVec4(e) => {
                                                *((base + 16) as *mut u8) = (18i32) as u8;
                                                let vec47 = e;
                                                let ptr47 = vec47.as_ptr() as i32;
                                                let len47 = vec47.len() as i32;
                                                *((base + 24) as *mut i32) = len47;
                                                *((base + 20) as *mut i32) = ptr47;
                                                
                                              },
                                              super::super::super::ambient::bindings::component::VecValue::TypeUvec2(e) => {
                                                *((base + 16) as *mut u8) = (19i32) as u8;
                                                let vec48 = e;
                                                let ptr48 = vec48.as_ptr() as i32;
                                                let len48 = vec48.len() as i32;
                                                *((base + 24) as *mut i32) = len48;
                                                *((base + 20) as *mut i32) = ptr48;
                                                
                                              },
                                              super::super::super::ambient::bindings::component::VecValue::TypeUvec3(e) => {
                                                *((base + 16) as *mut u8) = (20i32) as u8;
                                                let vec49 = e;
                                                let ptr49 = vec49.as_ptr() as i32;
                                                let len49 = vec49.len() as i32;
                                                *((base + 24) as *mut i32) = len49;
                                                *((base + 20) as *mut i32) = ptr49;
                                                
                                              },
                                              super::super::super::ambient::bindings::component::VecValue::TypeUvec4(e) => {
                                                *((base + 16) as *mut u8) = (21i32) as u8;
                                                let vec50 = e;
                                                let ptr50 = vec50.as_ptr() as i32;
                                                let len50 = vec50.len() as i32;
                                                *((base + 24) as *mut i32) = len50;
                                                *((base + 20) as *mut i32) = ptr50;
                                                
                                              },
                                              super::super::super::ambient::bindings::component::VecValue::TypeIvec2(e) => {
                                                *((base + 16) as *mut u8) = (22i32) as u8;
                                                let vec51 = e;
                                                let ptr51 = vec51.as_ptr() as i32;
                                                let len51 = vec51.len() as i32;
                                                *((base + 24) as *mut i32) = len51;
                                                *((base + 20) as *mut i32) = ptr51;
                                                
                                              },
                                              super::super::super::ambient::bindings::component::VecValue::TypeIvec3(e) => {
                                                *((base + 16) as *mut u8) = (23i32) as u8;
                                                let vec52 = e;
                                                let ptr52 = vec52.as_ptr() as i32;
                                                let len52 = vec52.len() as i32;
                                                *((base + 24) as *mut i32) = len52;
                                                *((base + 20) as *mut i32) = ptr52;
                                                
                                              },
                                              super::super::super::ambient::bindings::component::VecValue::TypeIvec4(e) => {
                                                *((base + 16) as *mut u8) = (24i32) as u8;
                                                let vec53 = e;
                                                let ptr53 = vec53.as_ptr() as i32;
                                                let len53 = vec53.len() as i32;
                                                *((base + 24) as *mut i32) = len53;
                                                *((base + 20) as *mut i32) = ptr53;
                                                
                                              },
                                              super::super::super::ambient::bindings::component::VecValue::TypeDuration(e) => {
                                                *((base + 16) as *mut u8) = (25i32) as u8;
                                                let vec54 = e;
                                                let ptr54 = vec54.as_ptr() as i32;
                                                let len54 = vec54.len() as i32;
                                                *((base + 24) as *mut i32) = len54;
                                                *((base + 20) as *mut i32) = ptr54;
                                                
                                              },
                                              super::super::super::ambient::bindings::component::VecValue::TypeProceduralMeshHandle(e) => {
                                                *((base + 16) as *mut u8) = (26i32) as u8;
                                                let vec55 = e;
                                                let ptr55 = vec55.as_ptr() as i32;
                                                let len55 = vec55.len() as i32;
                                                *((base + 24) as *mut i32) = len55;
                                                *((base + 20) as *mut i32) = ptr55;
                                                
                                              },
                                              super::super::super::ambient::bindings::component::VecValue::TypeProceduralTextureHandle(e) => {
                                                *((base + 16) as *mut u8) = (27i32) as u8;
                                                let vec56 = e;
                                                let ptr56 = vec56.as_ptr() as i32;
                                                let len56 = vec56.len() as i32;
                                                *((base + 24) as *mut i32) = len56;
                                                *((base + 20) as *mut i32) = ptr56;
                                                
                                              },
                                              super::super::super::ambient::bindings::component::VecValue::TypeProceduralSamplerHandle(e) => {
                                                *((base + 16) as *mut u8) = (28i32) as u8;
                                                let vec57 = e;
                                                let ptr57 = vec57.as_ptr() as i32;
                                                let len57 = vec57.len() as i32;
                                                *((base + 24) as *mut i32) = len57;
                                                *((base + 20) as *mut i32) = ptr57;
                                                
                                              },
                                              super::super::super::ambient::bindings::component::VecValue::TypeProceduralMaterialHandle(e) => {
                                                *((base + 16) as *mut u8) = (29i32) as u8;
                                                let vec58 = e;
                                                let ptr58 = vec58.as_ptr() as i32;
                                                let len58 = vec58.len() as i32;
                                                *((base + 24) as *mut i32) = len58;
                                                *((base + 20) as *mut i32) = ptr58;
                                                
                                              },
                                            };
                                            
                                          },
                                          super::super::super::ambient::bindings::component::Value::TypeOption(e) => {
                                            *((base + 8) as *mut u8) = (31i32) as u8;
                                            match e {
                                              super::super::super::ambient::bindings::component::OptionValue::TypeEmpty(e) => {
                                                *((base + 16) as *mut u8) = (0i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    let super::super::super::ambient::bindings::types::Empty{ dummy:dummy59, } = e;
                                                    *((base + 25) as *mut u8) = (wit_bindgen::rt::as_i32(dummy59)) as u8;
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeBool(e) => {
                                                *((base + 16) as *mut u8) = (1i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    *((base + 25) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeEntityId(e) => {
                                                *((base + 16) as *mut u8) = (2i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    let super::super::super::ambient::bindings::types::EntityId{ id0:id060, id1:id160, } = e;
                                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(id060);
                                                    *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(id160);
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeF32(e) => {
                                                *((base + 16) as *mut u8) = (3i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(e);
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeF64(e) => {
                                                *((base + 16) as *mut u8) = (4i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeMat4(e) => {
                                                *((base + 16) as *mut u8) = (5i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    let super::super::super::ambient::bindings::types::Mat4{ x:x61, y:y61, z:z61, w:w61, } = e;
                                                    let super::super::super::ambient::bindings::types::Vec4{ x:x62, y:y62, z:z62, w:w62, } = x61;
                                                    *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x62);
                                                    *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y62);
                                                    *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z62);
                                                    *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w62);
                                                    let super::super::super::ambient::bindings::types::Vec4{ x:x63, y:y63, z:z63, w:w63, } = y61;
                                                    *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(x63);
                                                    *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(y63);
                                                    *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(z63);
                                                    *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(w63);
                                                    let super::super::super::ambient::bindings::types::Vec4{ x:x64, y:y64, z:z64, w:w64, } = z61;
                                                    *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(x64);
                                                    *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(y64);
                                                    *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(z64);
                                                    *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(w64);
                                                    let super::super::super::ambient::bindings::types::Vec4{ x:x65, y:y65, z:z65, w:w65, } = w61;
                                                    *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(x65);
                                                    *((base + 80) as *mut f32) = wit_bindgen::rt::as_f32(y65);
                                                    *((base + 84) as *mut f32) = wit_bindgen::rt::as_f32(z65);
                                                    *((base + 88) as *mut f32) = wit_bindgen::rt::as_f32(w65);
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeQuat(e) => {
                                                *((base + 16) as *mut u8) = (6i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    let super::super::super::ambient::bindings::types::Quat{ x:x66, y:y66, z:z66, w:w66, } = e;
                                                    *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x66);
                                                    *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y66);
                                                    *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z66);
                                                    *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w66);
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeString(e) => {
                                                *((base + 16) as *mut u8) = (7i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    let vec67 = e;
                                                    let ptr67 = vec67.as_ptr() as i32;
                                                    let len67 = vec67.len() as i32;
                                                    *((base + 32) as *mut i32) = len67;
                                                    *((base + 28) as *mut i32) = ptr67;
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeU8(e) => {
                                                *((base + 16) as *mut u8) = (8i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    *((base + 25) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeU16(e) => {
                                                *((base + 16) as *mut u8) = (9i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    *((base + 26) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeU32(e) => {
                                                *((base + 16) as *mut u8) = (10i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeU64(e) => {
                                                *((base + 16) as *mut u8) = (11i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeI8(e) => {
                                                *((base + 16) as *mut u8) = (12i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    *((base + 25) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeI16(e) => {
                                                *((base + 16) as *mut u8) = (13i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    *((base + 26) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeI32(e) => {
                                                *((base + 16) as *mut u8) = (14i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeI64(e) => {
                                                *((base + 16) as *mut u8) = (15i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeVec2(e) => {
                                                *((base + 16) as *mut u8) = (16i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    let super::super::super::ambient::bindings::types::Vec2{ x:x68, y:y68, } = e;
                                                    *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x68);
                                                    *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y68);
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeVec3(e) => {
                                                *((base + 16) as *mut u8) = (17i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    let super::super::super::ambient::bindings::types::Vec3{ x:x69, y:y69, z:z69, } = e;
                                                    *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x69);
                                                    *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y69);
                                                    *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z69);
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeVec4(e) => {
                                                *((base + 16) as *mut u8) = (18i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    let super::super::super::ambient::bindings::types::Vec4{ x:x70, y:y70, z:z70, w:w70, } = e;
                                                    *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x70);
                                                    *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y70);
                                                    *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z70);
                                                    *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w70);
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeUvec2(e) => {
                                                *((base + 16) as *mut u8) = (19i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    let super::super::super::ambient::bindings::types::Uvec2{ x:x71, y:y71, } = e;
                                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x71);
                                                    *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y71);
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeUvec3(e) => {
                                                *((base + 16) as *mut u8) = (20i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    let super::super::super::ambient::bindings::types::Uvec3{ x:x72, y:y72, z:z72, } = e;
                                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x72);
                                                    *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y72);
                                                    *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z72);
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeUvec4(e) => {
                                                *((base + 16) as *mut u8) = (21i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    let super::super::super::ambient::bindings::types::Uvec4{ x:x73, y:y73, z:z73, w:w73, } = e;
                                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x73);
                                                    *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y73);
                                                    *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z73);
                                                    *((base + 40) as *mut i32) = wit_bindgen::rt::as_i32(w73);
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeIvec2(e) => {
                                                *((base + 16) as *mut u8) = (22i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    let super::super::super::ambient::bindings::types::Ivec2{ x:x74, y:y74, } = e;
                                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x74);
                                                    *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y74);
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeIvec3(e) => {
                                                *((base + 16) as *mut u8) = (23i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    let super::super::super::ambient::bindings::types::Ivec3{ x:x75, y:y75, z:z75, } = e;
                                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x75);
                                                    *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y75);
                                                    *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z75);
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeIvec4(e) => {
                                                *((base + 16) as *mut u8) = (24i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    let super::super::super::ambient::bindings::types::Ivec4{ x:x76, y:y76, z:z76, w:w76, } = e;
                                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x76);
                                                    *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y76);
                                                    *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z76);
                                                    *((base + 40) as *mut i32) = wit_bindgen::rt::as_i32(w76);
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeDuration(e) => {
                                                *((base + 16) as *mut u8) = (25i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    let super::super::super::ambient::bindings::types::Duration{ seconds:seconds77, nanoseconds:nanoseconds77, } = e;
                                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(seconds77);
                                                    *((base + 40) as *mut i32) = wit_bindgen::rt::as_i32(nanoseconds77);
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeProceduralMeshHandle(e) => {
                                                *((base + 16) as *mut u8) = (26i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    let super::super::super::ambient::bindings::client_mesh::Handle{ ulid:ulid78, } = e;
                                                    let (t79_0, t79_1, ) = ulid78;
                                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t79_0);
                                                    *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t79_1);
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeProceduralTextureHandle(e) => {
                                                *((base + 16) as *mut u8) = (27i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid80, } = e;
                                                    let (t81_0, t81_1, ) = ulid80;
                                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t81_0);
                                                    *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t81_1);
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeProceduralSamplerHandle(e) => {
                                                *((base + 16) as *mut u8) = (28i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    let super::super::super::ambient::bindings::client_sampler::Handle{ ulid:ulid82, } = e;
                                                    let (t83_0, t83_1, ) = ulid82;
                                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t83_0);
                                                    *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t83_1);
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                              super::super::super::ambient::bindings::component::OptionValue::TypeProceduralMaterialHandle(e) => {
                                                *((base + 16) as *mut u8) = (29i32) as u8;
                                                match e {
                                                  Some(e) => {
                                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                                    let super::super::super::ambient::bindings::client_material::Handle{ ulid:ulid84, } = e;
                                                    let (t85_0, t85_1, ) = ulid84;
                                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t85_0);
                                                    *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t85_1);
                                                    
                                                  },
                                                  None => {
                                                    {
                                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                                      
                                                    }
                                                  },
                                                };
                                              },
                                            };
                                            
                                          },
                                        };
                                        
                                      }}
                                      let ptr87 = ret_area.as_mut_ptr() as i32;
                                      #[link(wasm_import_module = "ambient:bindings/entity")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "spawn")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/entity_spawn")]
                                        fn wit_import(
                                        _: i32, _: i32, _: i32, );
                                      }
                                      wit_import(result86 as i32, len86, ptr87);
                                      if layout86.size() != 0 {
                                        alloc::dealloc(result86, layout86);
                                      }
                                      for (ptr, layout) in cleanup_list {
                                        
                                        if layout.size() != 0 {
                                          
                                          alloc::dealloc(ptr, layout);
                                          
                                        }
                                        
                                      }
                                      super::super::super::ambient::bindings::types::EntityId{id0:*((ptr87 + 0) as *const i64) as u64, id1:*((ptr87 + 8) as *const i64) as u64, }
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn despawn(entity: EntityId,) -> Option<EntityData>{
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[repr(align(4))]
                                      struct RetArea([u8; 12]);
                                      let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                      let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                                      let ptr1 = ret_area.as_mut_ptr() as i32;
                                      #[link(wasm_import_module = "ambient:bindings/entity")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "despawn")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/entity_despawn")]
                                        fn wit_import(
                                        _: i64, _: i64, _: i32, );
                                      }
                                      wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), ptr1);
                                      match i32::from(*((ptr1 + 0) as *const u8)) {
                                        0 => None,
                                        1 => Some({
                                          let base35 = *((ptr1 + 4) as *const i32);
                                          let len35 = *((ptr1 + 8) as *const i32);
                                          let mut result35 = Vec::with_capacity(len35 as usize);
                                          for i in 0..len35 {
                                            let base = base35 + i *96;
                                            result35.push((*((base + 0) as *const i32) as u32, {{match i32::from(*((base + 8) as *const u8)) {
                                              0 => super::super::super::ambient::bindings::component::Value::TypeEmpty(super::super::super::ambient::bindings::types::Empty{dummy:i32::from(*((base + 16) as *const u8)) as u8, }),
                                              1 => super::super::super::ambient::bindings::component::Value::TypeBool({
                                                #[cfg(not(debug_assertions))]
                                                { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 16) as *const u8)) as u8) }
                                                #[cfg(debug_assertions)]
                                                {
                                                  match i32::from(*((base + 16) as *const u8)) {
                                                    0 => false,
                                                    1 => true,
                                                    _ => panic!("invalid bool discriminant"),
                                                  }
                                                }
                                              }),
                                              2 => super::super::super::ambient::bindings::component::Value::TypeEntityId(super::super::super::ambient::bindings::types::EntityId{id0:*((base + 16) as *const i64) as u64, id1:*((base + 24) as *const i64) as u64, }),
                                              3 => super::super::super::ambient::bindings::component::Value::TypeF32(*((base + 16) as *const f32)),
                                              4 => super::super::super::ambient::bindings::component::Value::TypeF64(*((base + 16) as *const f64)),
                                              5 => super::super::super::ambient::bindings::component::Value::TypeMat4(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((base + 32) as *const f32), y:*((base + 36) as *const f32), z:*((base + 40) as *const f32), w:*((base + 44) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((base + 48) as *const f32), y:*((base + 52) as *const f32), z:*((base + 56) as *const f32), w:*((base + 60) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((base + 64) as *const f32), y:*((base + 68) as *const f32), z:*((base + 72) as *const f32), w:*((base + 76) as *const f32), }, }),
                                              6 => super::super::super::ambient::bindings::component::Value::TypeQuat(super::super::super::ambient::bindings::types::Quat{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }),
                                              7 => super::super::super::ambient::bindings::component::Value::TypeString({
                                                let len2 = *((base + 20) as *const i32) as usize;
                                                
                                                {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 16) as *const i32) as *mut _, len2, len2))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 16) as *const i32) as *mut _, len2, len2)).unwrap()}}
                                              }),
                                              8 => super::super::super::ambient::bindings::component::Value::TypeU8(i32::from(*((base + 16) as *const u8)) as u8),
                                              9 => super::super::super::ambient::bindings::component::Value::TypeU16(i32::from(*((base + 16) as *const u16)) as u16),
                                              10 => super::super::super::ambient::bindings::component::Value::TypeU32(*((base + 16) as *const i32) as u32),
                                              11 => super::super::super::ambient::bindings::component::Value::TypeU64(*((base + 16) as *const i64) as u64),
                                              12 => super::super::super::ambient::bindings::component::Value::TypeI8(i32::from(*((base + 16) as *const i8)) as i8),
                                              13 => super::super::super::ambient::bindings::component::Value::TypeI16(i32::from(*((base + 16) as *const i16)) as i16),
                                              14 => super::super::super::ambient::bindings::component::Value::TypeI32(*((base + 16) as *const i32)),
                                              15 => super::super::super::ambient::bindings::component::Value::TypeI64(*((base + 16) as *const i64)),
                                              16 => super::super::super::ambient::bindings::component::Value::TypeVec2(super::super::super::ambient::bindings::types::Vec2{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), }),
                                              17 => super::super::super::ambient::bindings::component::Value::TypeVec3(super::super::super::ambient::bindings::types::Vec3{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), }),
                                              18 => super::super::super::ambient::bindings::component::Value::TypeVec4(super::super::super::ambient::bindings::types::Vec4{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }),
                                              19 => super::super::super::ambient::bindings::component::Value::TypeUvec2(super::super::super::ambient::bindings::types::Uvec2{x:*((base + 16) as *const i32) as u32, y:*((base + 20) as *const i32) as u32, }),
                                              20 => super::super::super::ambient::bindings::component::Value::TypeUvec3(super::super::super::ambient::bindings::types::Uvec3{x:*((base + 16) as *const i32) as u32, y:*((base + 20) as *const i32) as u32, z:*((base + 24) as *const i32) as u32, }),
                                              21 => super::super::super::ambient::bindings::component::Value::TypeUvec4(super::super::super::ambient::bindings::types::Uvec4{x:*((base + 16) as *const i32) as u32, y:*((base + 20) as *const i32) as u32, z:*((base + 24) as *const i32) as u32, w:*((base + 28) as *const i32) as u32, }),
                                              22 => super::super::super::ambient::bindings::component::Value::TypeIvec2(super::super::super::ambient::bindings::types::Ivec2{x:*((base + 16) as *const i32), y:*((base + 20) as *const i32), }),
                                              23 => super::super::super::ambient::bindings::component::Value::TypeIvec3(super::super::super::ambient::bindings::types::Ivec3{x:*((base + 16) as *const i32), y:*((base + 20) as *const i32), z:*((base + 24) as *const i32), }),
                                              24 => super::super::super::ambient::bindings::component::Value::TypeIvec4(super::super::super::ambient::bindings::types::Ivec4{x:*((base + 16) as *const i32), y:*((base + 20) as *const i32), z:*((base + 24) as *const i32), w:*((base + 28) as *const i32), }),
                                              25 => super::super::super::ambient::bindings::component::Value::TypeDuration(super::super::super::ambient::bindings::types::Duration{seconds:*((base + 16) as *const i64) as u64, nanoseconds:*((base + 24) as *const i32) as u32, }),
                                              26 => super::super::super::ambient::bindings::component::Value::TypeProceduralMeshHandle(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                                              27 => super::super::super::ambient::bindings::component::Value::TypeProceduralTextureHandle(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                                              28 => super::super::super::ambient::bindings::component::Value::TypeProceduralSamplerHandle(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                                              29 => super::super::super::ambient::bindings::component::Value::TypeProceduralMaterialHandle(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                                              30 => super::super::super::ambient::bindings::component::Value::TypeVec({{match i32::from(*((base + 16) as *const u8)) {
                                                0 => super::super::super::ambient::bindings::component::VecValue::TypeEmpty({
                                                  let len3 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len3, len3)
                                                }),
                                                1 => super::super::super::ambient::bindings::component::VecValue::TypeBool({
                                                  let base4 = *((base + 20) as *const i32);
                                                  let len4 = *((base + 24) as *const i32);
                                                  let mut result4 = Vec::with_capacity(len4 as usize);
                                                  for i in 0..len4 {
                                                    let base = base4 + i *1;
                                                    result4.push({
                                                      #[cfg(not(debug_assertions))]
                                                      { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 0) as *const u8)) as u8) }
                                                      #[cfg(debug_assertions)]
                                                      {
                                                        match i32::from(*((base + 0) as *const u8)) {
                                                          0 => false,
                                                          1 => true,
                                                          _ => panic!("invalid bool discriminant"),
                                                        }
                                                      }
                                                    });
                                                  }
                                                  wit_bindgen::rt::dealloc(base4, (len4 as usize) * 1, 1);
                                                  
                                                  result4
                                                }),
                                                2 => super::super::super::ambient::bindings::component::VecValue::TypeEntityId({
                                                  let len5 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len5, len5)
                                                }),
                                                3 => super::super::super::ambient::bindings::component::VecValue::TypeF32({
                                                  let len6 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len6, len6)
                                                }),
                                                4 => super::super::super::ambient::bindings::component::VecValue::TypeF64({
                                                  let len7 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len7, len7)
                                                }),
                                                5 => super::super::super::ambient::bindings::component::VecValue::TypeMat4({
                                                  let len8 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len8, len8)
                                                }),
                                                6 => super::super::super::ambient::bindings::component::VecValue::TypeQuat({
                                                  let len9 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len9, len9)
                                                }),
                                                7 => super::super::super::ambient::bindings::component::VecValue::TypeString({
                                                  let base11 = *((base + 20) as *const i32);
                                                  let len11 = *((base + 24) as *const i32);
                                                  let mut result11 = Vec::with_capacity(len11 as usize);
                                                  for i in 0..len11 {
                                                    let base = base11 + i *8;
                                                    result11.push({
                                                      let len10 = *((base + 4) as *const i32) as usize;
                                                      
                                                      {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len10, len10))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len10, len10)).unwrap()}}
                                                    });
                                                  }
                                                  wit_bindgen::rt::dealloc(base11, (len11 as usize) * 8, 4);
                                                  
                                                  result11
                                                }),
                                                8 => super::super::super::ambient::bindings::component::VecValue::TypeU8({
                                                  let len12 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len12, len12)
                                                }),
                                                9 => super::super::super::ambient::bindings::component::VecValue::TypeU16({
                                                  let len13 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len13, len13)
                                                }),
                                                10 => super::super::super::ambient::bindings::component::VecValue::TypeU32({
                                                  let len14 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len14, len14)
                                                }),
                                                11 => super::super::super::ambient::bindings::component::VecValue::TypeU64({
                                                  let len15 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len15, len15)
                                                }),
                                                12 => super::super::super::ambient::bindings::component::VecValue::TypeI8({
                                                  let len16 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len16, len16)
                                                }),
                                                13 => super::super::super::ambient::bindings::component::VecValue::TypeI16({
                                                  let len17 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len17, len17)
                                                }),
                                                14 => super::super::super::ambient::bindings::component::VecValue::TypeI32({
                                                  let len18 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len18, len18)
                                                }),
                                                15 => super::super::super::ambient::bindings::component::VecValue::TypeI64({
                                                  let len19 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len19, len19)
                                                }),
                                                16 => super::super::super::ambient::bindings::component::VecValue::TypeVec2({
                                                  let len20 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len20, len20)
                                                }),
                                                17 => super::super::super::ambient::bindings::component::VecValue::TypeVec3({
                                                  let len21 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len21, len21)
                                                }),
                                                18 => super::super::super::ambient::bindings::component::VecValue::TypeVec4({
                                                  let len22 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len22, len22)
                                                }),
                                                19 => super::super::super::ambient::bindings::component::VecValue::TypeUvec2({
                                                  let len23 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len23, len23)
                                                }),
                                                20 => super::super::super::ambient::bindings::component::VecValue::TypeUvec3({
                                                  let len24 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len24, len24)
                                                }),
                                                21 => super::super::super::ambient::bindings::component::VecValue::TypeUvec4({
                                                  let len25 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len25, len25)
                                                }),
                                                22 => super::super::super::ambient::bindings::component::VecValue::TypeIvec2({
                                                  let len26 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len26, len26)
                                                }),
                                                23 => super::super::super::ambient::bindings::component::VecValue::TypeIvec3({
                                                  let len27 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len27, len27)
                                                }),
                                                24 => super::super::super::ambient::bindings::component::VecValue::TypeIvec4({
                                                  let len28 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len28, len28)
                                                }),
                                                25 => super::super::super::ambient::bindings::component::VecValue::TypeDuration({
                                                  let len29 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len29, len29)
                                                }),
                                                26 => super::super::super::ambient::bindings::component::VecValue::TypeProceduralMeshHandle({
                                                  let len30 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len30, len30)
                                                }),
                                                27 => super::super::super::ambient::bindings::component::VecValue::TypeProceduralTextureHandle({
                                                  let len31 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len31, len31)
                                                }),
                                                28 => super::super::super::ambient::bindings::component::VecValue::TypeProceduralSamplerHandle({
                                                  let len32 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len32, len32)
                                                }),
                                                #[cfg(debug_assertions)]29 => super::super::super::ambient::bindings::component::VecValue::TypeProceduralMaterialHandle({
                                                  let len33 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len33, len33)
                                                }),
                                                #[cfg(not(debug_assertions))]_ => super::super::super::ambient::bindings::component::VecValue::TypeProceduralMaterialHandle({
                                                  let len33 = *((base + 24) as *const i32) as usize;
                                                  
                                                  Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len33, len33)
                                                }),
                                                #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                              }}}),
                                              #[cfg(debug_assertions)]31 => super::super::super::ambient::bindings::component::Value::TypeOption({{match i32::from(*((base + 16) as *const u8)) {
                                                0 => super::super::super::ambient::bindings::component::OptionValue::TypeEmpty(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Empty{dummy:i32::from(*((base + 25) as *const u8)) as u8, }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                1 => super::super::super::ambient::bindings::component::OptionValue::TypeBool(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some({
                                                    #[cfg(not(debug_assertions))]
                                                    { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 25) as *const u8)) as u8) }
                                                    #[cfg(debug_assertions)]
                                                    {
                                                      match i32::from(*((base + 25) as *const u8)) {
                                                        0 => false,
                                                        1 => true,
                                                        _ => panic!("invalid bool discriminant"),
                                                      }
                                                    }
                                                  }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                2 => super::super::super::ambient::bindings::component::OptionValue::TypeEntityId(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::EntityId{id0:*((base + 32) as *const i64) as u64, id1:*((base + 40) as *const i64) as u64, }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                3 => super::super::super::ambient::bindings::component::OptionValue::TypeF32(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(*((base + 28) as *const f32)),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                4 => super::super::super::ambient::bindings::component::OptionValue::TypeF64(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(*((base + 32) as *const f64)),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                5 => super::super::super::ambient::bindings::component::OptionValue::TypeMat4(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((base + 44) as *const f32), y:*((base + 48) as *const f32), z:*((base + 52) as *const f32), w:*((base + 56) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((base + 60) as *const f32), y:*((base + 64) as *const f32), z:*((base + 68) as *const f32), w:*((base + 72) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((base + 76) as *const f32), y:*((base + 80) as *const f32), z:*((base + 84) as *const f32), w:*((base + 88) as *const f32), }, }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                6 => super::super::super::ambient::bindings::component::OptionValue::TypeQuat(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Quat{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                7 => super::super::super::ambient::bindings::component::OptionValue::TypeString(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some({
                                                    let len34 = *((base + 32) as *const i32) as usize;
                                                    
                                                    {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len34, len34))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len34, len34)).unwrap()}}
                                                  }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                8 => super::super::super::ambient::bindings::component::OptionValue::TypeU8(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(i32::from(*((base + 25) as *const u8)) as u8),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                9 => super::super::super::ambient::bindings::component::OptionValue::TypeU16(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(i32::from(*((base + 26) as *const u16)) as u16),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                10 => super::super::super::ambient::bindings::component::OptionValue::TypeU32(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(*((base + 28) as *const i32) as u32),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                11 => super::super::super::ambient::bindings::component::OptionValue::TypeU64(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(*((base + 32) as *const i64) as u64),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                12 => super::super::super::ambient::bindings::component::OptionValue::TypeI8(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(i32::from(*((base + 25) as *const i8)) as i8),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                13 => super::super::super::ambient::bindings::component::OptionValue::TypeI16(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(i32::from(*((base + 26) as *const i16)) as i16),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                14 => super::super::super::ambient::bindings::component::OptionValue::TypeI32(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(*((base + 28) as *const i32)),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                15 => super::super::super::ambient::bindings::component::OptionValue::TypeI64(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(*((base + 32) as *const i64)),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                16 => super::super::super::ambient::bindings::component::OptionValue::TypeVec2(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Vec2{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                17 => super::super::super::ambient::bindings::component::OptionValue::TypeVec3(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Vec3{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                18 => super::super::super::ambient::bindings::component::OptionValue::TypeVec4(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                19 => super::super::super::ambient::bindings::component::OptionValue::TypeUvec2(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Uvec2{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                20 => super::super::super::ambient::bindings::component::OptionValue::TypeUvec3(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Uvec3{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                21 => super::super::super::ambient::bindings::component::OptionValue::TypeUvec4(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Uvec4{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, w:*((base + 40) as *const i32) as u32, }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                22 => super::super::super::ambient::bindings::component::OptionValue::TypeIvec2(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Ivec2{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                23 => super::super::super::ambient::bindings::component::OptionValue::TypeIvec3(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Ivec3{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), z:*((base + 36) as *const i32), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                24 => super::super::super::ambient::bindings::component::OptionValue::TypeIvec4(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Ivec4{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), z:*((base + 36) as *const i32), w:*((base + 40) as *const i32), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                25 => super::super::super::ambient::bindings::component::OptionValue::TypeDuration(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Duration{seconds:*((base + 32) as *const i64) as u64, nanoseconds:*((base + 40) as *const i32) as u32, }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                26 => super::super::super::ambient::bindings::component::OptionValue::TypeProceduralMeshHandle(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                27 => super::super::super::ambient::bindings::component::OptionValue::TypeProceduralTextureHandle(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                28 => super::super::super::ambient::bindings::component::OptionValue::TypeProceduralSamplerHandle(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                #[cfg(debug_assertions)]29 => super::super::super::ambient::bindings::component::OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                #[cfg(not(debug_assertions))]_ => super::super::super::ambient::bindings::component::OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                              }}}),
                                              #[cfg(not(debug_assertions))]_ => super::super::super::ambient::bindings::component::Value::TypeOption({{match i32::from(*((base + 16) as *const u8)) {
                                                0 => super::super::super::ambient::bindings::component::OptionValue::TypeEmpty(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Empty{dummy:i32::from(*((base + 25) as *const u8)) as u8, }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                1 => super::super::super::ambient::bindings::component::OptionValue::TypeBool(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some({
                                                    #[cfg(not(debug_assertions))]
                                                    { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 25) as *const u8)) as u8) }
                                                    #[cfg(debug_assertions)]
                                                    {
                                                      match i32::from(*((base + 25) as *const u8)) {
                                                        0 => false,
                                                        1 => true,
                                                        _ => panic!("invalid bool discriminant"),
                                                      }
                                                    }
                                                  }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                2 => super::super::super::ambient::bindings::component::OptionValue::TypeEntityId(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::EntityId{id0:*((base + 32) as *const i64) as u64, id1:*((base + 40) as *const i64) as u64, }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                3 => super::super::super::ambient::bindings::component::OptionValue::TypeF32(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(*((base + 28) as *const f32)),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                4 => super::super::super::ambient::bindings::component::OptionValue::TypeF64(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(*((base + 32) as *const f64)),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                5 => super::super::super::ambient::bindings::component::OptionValue::TypeMat4(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((base + 44) as *const f32), y:*((base + 48) as *const f32), z:*((base + 52) as *const f32), w:*((base + 56) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((base + 60) as *const f32), y:*((base + 64) as *const f32), z:*((base + 68) as *const f32), w:*((base + 72) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((base + 76) as *const f32), y:*((base + 80) as *const f32), z:*((base + 84) as *const f32), w:*((base + 88) as *const f32), }, }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                6 => super::super::super::ambient::bindings::component::OptionValue::TypeQuat(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Quat{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                7 => super::super::super::ambient::bindings::component::OptionValue::TypeString(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some({
                                                    let len34 = *((base + 32) as *const i32) as usize;
                                                    
                                                    {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len34, len34))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len34, len34)).unwrap()}}
                                                  }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                8 => super::super::super::ambient::bindings::component::OptionValue::TypeU8(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(i32::from(*((base + 25) as *const u8)) as u8),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                9 => super::super::super::ambient::bindings::component::OptionValue::TypeU16(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(i32::from(*((base + 26) as *const u16)) as u16),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                10 => super::super::super::ambient::bindings::component::OptionValue::TypeU32(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(*((base + 28) as *const i32) as u32),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                11 => super::super::super::ambient::bindings::component::OptionValue::TypeU64(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(*((base + 32) as *const i64) as u64),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                12 => super::super::super::ambient::bindings::component::OptionValue::TypeI8(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(i32::from(*((base + 25) as *const i8)) as i8),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                13 => super::super::super::ambient::bindings::component::OptionValue::TypeI16(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(i32::from(*((base + 26) as *const i16)) as i16),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                14 => super::super::super::ambient::bindings::component::OptionValue::TypeI32(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(*((base + 28) as *const i32)),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                15 => super::super::super::ambient::bindings::component::OptionValue::TypeI64(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(*((base + 32) as *const i64)),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                16 => super::super::super::ambient::bindings::component::OptionValue::TypeVec2(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Vec2{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                17 => super::super::super::ambient::bindings::component::OptionValue::TypeVec3(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Vec3{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                18 => super::super::super::ambient::bindings::component::OptionValue::TypeVec4(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                19 => super::super::super::ambient::bindings::component::OptionValue::TypeUvec2(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Uvec2{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                20 => super::super::super::ambient::bindings::component::OptionValue::TypeUvec3(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Uvec3{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                21 => super::super::super::ambient::bindings::component::OptionValue::TypeUvec4(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Uvec4{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, w:*((base + 40) as *const i32) as u32, }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                22 => super::super::super::ambient::bindings::component::OptionValue::TypeIvec2(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Ivec2{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                23 => super::super::super::ambient::bindings::component::OptionValue::TypeIvec3(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Ivec3{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), z:*((base + 36) as *const i32), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                24 => super::super::super::ambient::bindings::component::OptionValue::TypeIvec4(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Ivec4{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), z:*((base + 36) as *const i32), w:*((base + 40) as *const i32), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                25 => super::super::super::ambient::bindings::component::OptionValue::TypeDuration(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::types::Duration{seconds:*((base + 32) as *const i64) as u64, nanoseconds:*((base + 40) as *const i32) as u32, }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                26 => super::super::super::ambient::bindings::component::OptionValue::TypeProceduralMeshHandle(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                27 => super::super::super::ambient::bindings::component::OptionValue::TypeProceduralTextureHandle(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                28 => super::super::super::ambient::bindings::component::OptionValue::TypeProceduralSamplerHandle(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                #[cfg(debug_assertions)]29 => super::super::super::ambient::bindings::component::OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                #[cfg(not(debug_assertions))]_ => super::super::super::ambient::bindings::component::OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                                                  0 => None,
                                                  1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                                                  #[cfg(not(debug_assertions))]
                                                  _ => ::core::hint::unreachable_unchecked(),
                                                  #[cfg(debug_assertions)]
                                                  _ => panic!("invalid enum discriminant"),
                                                }),
                                                #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                              }}}),
                                              #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                            }}}));
                                          }
                                          wit_bindgen::rt::dealloc(base35, (len35 as usize) * 96, 8);
                                          
                                          result35
                                        }),
                                        #[cfg(not(debug_assertions))]
                                        _ => ::core::hint::unreachable_unchecked(),
                                        #[cfg(debug_assertions)]
                                        _ => panic!("invalid enum discriminant"),
                                      }
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn in_area(position: Vec3,radius: f32,) -> wit_bindgen::rt::vec::Vec::<EntityId>{
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[repr(align(4))]
                                      struct RetArea([u8; 8]);
                                      let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                      let super::super::super::ambient::bindings::types::Vec3{ x:x0, y:y0, z:z0, } = position;
                                      let ptr1 = ret_area.as_mut_ptr() as i32;
                                      #[link(wasm_import_module = "ambient:bindings/entity")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "in-area")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/entity_in-area")]
                                        fn wit_import(
                                        _: f32, _: f32, _: f32, _: f32, _: i32, );
                                      }
                                      wit_import(wit_bindgen::rt::as_f32(x0), wit_bindgen::rt::as_f32(y0), wit_bindgen::rt::as_f32(z0), wit_bindgen::rt::as_f32(radius), ptr1);
                                      let len2 = *((ptr1 + 4) as *const i32) as usize;
                                      Vec::from_raw_parts(*((ptr1 + 0) as *const i32) as *mut _, len2, len2)
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn exists(entity: EntityId,) -> bool{
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                                      
                                      #[link(wasm_import_module = "ambient:bindings/entity")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "exists")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/entity_exists")]
                                        fn wit_import(
                                        _: i64, _: i64, ) -> i32;
                                      }
                                      let ret = wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10));
                                      {
                                        #[cfg(not(debug_assertions))]
                                        { ::core::mem::transmute::<u8, bool>(ret as u8) }
                                        #[cfg(debug_assertions)]
                                        {
                                          match ret {
                                            0 => false,
                                            1 => true,
                                            _ => panic!("invalid bool discriminant"),
                                          }
                                        }
                                      }
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn get_all(index: u32,) -> wit_bindgen::rt::vec::Vec::<EntityId>{
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[repr(align(4))]
                                      struct RetArea([u8; 8]);
                                      let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                      let ptr0 = ret_area.as_mut_ptr() as i32;
                                      #[link(wasm_import_module = "ambient:bindings/entity")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "get-all")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/entity_get-all")]
                                        fn wit_import(
                                        _: i32, _: i32, );
                                      }
                                      wit_import(wit_bindgen::rt::as_i32(index), ptr0);
                                      let len1 = *((ptr0 + 4) as *const i32) as usize;
                                      Vec::from_raw_parts(*((ptr0 + 0) as *const i32) as *mut _, len1, len1)
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn resources() -> EntityId{
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[repr(align(8))]
                                      struct RetArea([u8; 16]);
                                      let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                      let ptr0 = ret_area.as_mut_ptr() as i32;
                                      #[link(wasm_import_module = "ambient:bindings/entity")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "resources")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/entity_resources")]
                                        fn wit_import(
                                        _: i32, );
                                      }
                                      wit_import(ptr0);
                                      super::super::super::ambient::bindings::types::EntityId{id0:*((ptr0 + 0) as *const i64) as u64, id1:*((ptr0 + 8) as *const i64) as u64, }
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn synchronized_resources() -> EntityId{
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[repr(align(8))]
                                      struct RetArea([u8; 16]);
                                      let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                      let ptr0 = ret_area.as_mut_ptr() as i32;
                                      #[link(wasm_import_module = "ambient:bindings/entity")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "synchronized-resources")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/entity_synchronized-resources")]
                                        fn wit_import(
                                        _: i32, );
                                      }
                                      wit_import(ptr0);
                                      super::super::super::ambient::bindings::types::EntityId{id0:*((ptr0 + 0) as *const i64) as u64, id1:*((ptr0 + 8) as *const i64) as u64, }
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn persisted_resources() -> EntityId{
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[repr(align(8))]
                                      struct RetArea([u8; 16]);
                                      let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                      let ptr0 = ret_area.as_mut_ptr() as i32;
                                      #[link(wasm_import_module = "ambient:bindings/entity")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "persisted-resources")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/entity_persisted-resources")]
                                        fn wit_import(
                                        _: i32, );
                                      }
                                      wit_import(ptr0);
                                      super::super::super::ambient::bindings::types::EntityId{id0:*((ptr0 + 0) as *const i64) as u64, id1:*((ptr0 + 8) as *const i64) as u64, }
                                    }
                                  }
                                  
                                }
                                
                                
                                #[allow(clippy::all)]
                                pub mod message {
                                  #[used]
                                  #[doc(hidden)]
                                  #[cfg(target_arch = "wasm32")]
                                  static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
                                  
                                  #[allow(clippy::all)]
                                  pub fn subscribe(name: &str,){
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      let vec0 = name;
                                      let ptr0 = vec0.as_ptr() as i32;
                                      let len0 = vec0.len() as i32;
                                      
                                      #[link(wasm_import_module = "ambient:bindings/message")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "subscribe")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/message_subscribe")]
                                        fn wit_import(
                                        _: i32, _: i32, );
                                      }
                                      wit_import(ptr0, len0);
                                    }
                                  }
                                  
                                }
                                
                                
                                #[allow(clippy::all)]
                                pub mod player {
                                  #[used]
                                  #[doc(hidden)]
                                  #[cfg(target_arch = "wasm32")]
                                  static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
                                  
                                  pub type EntityId = super::super::super::ambient::bindings::types::EntityId;
                                  #[allow(clippy::all)]
                                  pub fn get_by_user_id(user_id: &str,) -> Option<EntityId>{
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[repr(align(8))]
                                      struct RetArea([u8; 24]);
                                      let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                      let vec0 = user_id;
                                      let ptr0 = vec0.as_ptr() as i32;
                                      let len0 = vec0.len() as i32;
                                      let ptr1 = ret_area.as_mut_ptr() as i32;
                                      #[link(wasm_import_module = "ambient:bindings/player")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "get-by-user-id")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/player_get-by-user-id")]
                                        fn wit_import(
                                        _: i32, _: i32, _: i32, );
                                      }
                                      wit_import(ptr0, len0, ptr1);
                                      match i32::from(*((ptr1 + 0) as *const u8)) {
                                        0 => None,
                                        1 => Some(super::super::super::ambient::bindings::types::EntityId{id0:*((ptr1 + 8) as *const i64) as u64, id1:*((ptr1 + 16) as *const i64) as u64, }),
                                        #[cfg(not(debug_assertions))]
                                        _ => ::core::hint::unreachable_unchecked(),
                                        #[cfg(debug_assertions)]
                                        _ => panic!("invalid enum discriminant"),
                                      }
                                    }
                                  }
                                  
                                }
                                
                                
                                #[allow(clippy::all)]
                                pub mod client_message {
                                  #[used]
                                  #[doc(hidden)]
                                  #[cfg(target_arch = "wasm32")]
                                  static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
                                  
                                  pub type EntityId = super::super::super::ambient::bindings::types::EntityId;
                                  #[derive(Clone, Copy)]
                                  pub enum Target{
                                    ServerUnreliable,
                                    ServerReliable,
                                    LocalBroadcast(bool),
                                    Local(EntityId),
                                  }
                                  impl ::core::fmt::Debug for Target {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                                      match self {
                                        Target::ServerUnreliable => {
                                          f.debug_tuple("Target::ServerUnreliable").finish()
                                        }
                                        Target::ServerReliable => {
                                          f.debug_tuple("Target::ServerReliable").finish()
                                        }
                                        Target::LocalBroadcast(e) => {
                                          f.debug_tuple("Target::LocalBroadcast").field(e).finish()
                                        }
                                        Target::Local(e) => {
                                          f.debug_tuple("Target::Local").field(e).finish()
                                        }
                                      }
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn send(target_id: Target,name: &str,data: &[u8],){
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      let (result1_0,result1_1,result1_2,) = match target_id {
                                        Target::ServerUnreliable=> {
                                          (0i32, 0i64, 0i64)
                                        }
                                        Target::ServerReliable=> {
                                          (1i32, 0i64, 0i64)
                                        }
                                        Target::LocalBroadcast(e) => (2i32, i64::from(match e { true => 1, false => 0 }), 0i64),
                                        Target::Local(e) => {
                                          let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = e;
                                          
                                          (3i32, wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10))
                                        },
                                      };
                                      let vec2 = name;
                                      let ptr2 = vec2.as_ptr() as i32;
                                      let len2 = vec2.len() as i32;
                                      let vec3 = data;
                                      let ptr3 = vec3.as_ptr() as i32;
                                      let len3 = vec3.len() as i32;
                                      
                                      #[link(wasm_import_module = "ambient:bindings/client-message")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "send")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-message_send")]
                                        fn wit_import(
                                        _: i32, _: i64, _: i64, _: i32, _: i32, _: i32, _: i32, );
                                      }
                                      wit_import(result1_0, result1_1, result1_2, ptr2, len2, ptr3, len3);
                                    }
                                  }
                                  
                                }
                                
                                
                                #[allow(clippy::all)]
                                pub mod client_player {
                                  #[used]
                                  #[doc(hidden)]
                                  #[cfg(target_arch = "wasm32")]
                                  static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
                                  
                                  pub type EntityId = super::super::super::ambient::bindings::types::EntityId;
                                  #[allow(clippy::all)]
                                  pub fn get_local() -> EntityId{
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[repr(align(8))]
                                      struct RetArea([u8; 16]);
                                      let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                      let ptr0 = ret_area.as_mut_ptr() as i32;
                                      #[link(wasm_import_module = "ambient:bindings/client-player")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "get-local")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-player_get-local")]
                                        fn wit_import(
                                        _: i32, );
                                      }
                                      wit_import(ptr0);
                                      super::super::super::ambient::bindings::types::EntityId{id0:*((ptr0 + 0) as *const i64) as u64, id1:*((ptr0 + 8) as *const i64) as u64, }
                                    }
                                  }
                                  
                                }
                                
                                
                                #[allow(clippy::all)]
                                pub mod client_input {
                                  #[used]
                                  #[doc(hidden)]
                                  #[cfg(target_arch = "wasm32")]
                                  static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
                                  
                                  pub type Vec2 = super::super::super::ambient::bindings::types::Vec2;
                                  #[repr(u8)]
                                  #[derive(Clone, Copy, PartialEq, Eq)]
                                  pub enum VirtualKeyCode {
                                    /// The '1' key over the letters.
                                    Key1,
                                    /// The '2' key over the letters.
                                    Key2,
                                    /// The '3' key over the letters.
                                    Key3,
                                    /// The '4' key over the letters.
                                    Key4,
                                    /// The '5' key over the letters.
                                    Key5,
                                    /// The '6' key over the letters.
                                    Key6,
                                    /// The '7' key over the letters.
                                    Key7,
                                    /// The '8' key over the letters.
                                    Key8,
                                    /// The '9' key over the letters.
                                    Key9,
                                    /// The '0' key over the 'O' and 'P' keys.
                                    Key0,
                                    A,
                                    B,
                                    C,
                                    D,
                                    E,
                                    F,
                                    G,
                                    H,
                                    I,
                                    J,
                                    K,
                                    L,
                                    M,
                                    N,
                                    O,
                                    P,
                                    Q,
                                    R,
                                    S,
                                    T,
                                    U,
                                    V,
                                    W,
                                    X,
                                    Y,
                                    Z,
                                    /// The Escape key, next to F1.
                                    Escape,
                                    F1,
                                    F2,
                                    F3,
                                    F4,
                                    F5,
                                    F6,
                                    F7,
                                    F8,
                                    F9,
                                    F10,
                                    F11,
                                    F12,
                                    F13,
                                    F14,
                                    F15,
                                    F16,
                                    F17,
                                    F18,
                                    F19,
                                    F20,
                                    F21,
                                    F22,
                                    F23,
                                    F24,
                                    /// Print Screen/SysRq.
                                    Snapshot,
                                    /// Scroll Lock.
                                    Scroll,
                                    /// Pause/Break key, next to Scroll lock.
                                    Pause,
                                    /// `Insert`, next to Backspace.
                                    Insert,
                                    Home,
                                    Delete,
                                    End,
                                    PageDown,
                                    PageUp,
                                    Left,
                                    Up,
                                    Right,
                                    Down,
                                    /// The Backspace key, right over Enter.
                                    Back,
                                    /// The Enter key.
                                    Return,
                                    /// The space bar.
                                    Space,
                                    /// The "Compose" key on Linux.
                                    Compose,
                                    Caret,
                                    Numlock,
                                    Numpad0,
                                    Numpad1,
                                    Numpad2,
                                    Numpad3,
                                    Numpad4,
                                    Numpad5,
                                    Numpad6,
                                    Numpad7,
                                    Numpad8,
                                    Numpad9,
                                    NumpadAdd,
                                    NumpadDivide,
                                    NumpadDecimal,
                                    NumpadComma,
                                    NumpadEnter,
                                    NumpadEquals,
                                    NumpadMultiply,
                                    NumpadSubtract,
                                    AbntC1,
                                    AbntC2,
                                    Apostrophe,
                                    Apps,
                                    Asterisk,
                                    At,
                                    Ax,
                                    Backslash,
                                    Calculator,
                                    Capital,
                                    Colon,
                                    Comma,
                                    Convert,
                                    Equals,
                                    Grave,
                                    Kana,
                                    Kanji,
                                    LAlt,
                                    LBracket,
                                    LControl,
                                    LShift,
                                    LWin,
                                    Mail,
                                    MediaSelect,
                                    MediaStop,
                                    Minus,
                                    Mute,
                                    MyComputer,
                                    NavigateForward,
                                    NavigateBackward,
                                    NextTrack,
                                    NoConvert,
                                    Oem102,
                                    Period,
                                    PlayPause,
                                    Plus,
                                    Power,
                                    PrevTrack,
                                    RAlt,
                                    RBracket,
                                    RControl,
                                    RShift,
                                    RWin,
                                    Semicolon,
                                    Slash,
                                    Sleep,
                                    Stop,
                                    Sysrq,
                                    Tab,
                                    Underline,
                                    Unlabeled,
                                    VolumeDown,
                                    VolumeUp,
                                    Wake,
                                    WebBack,
                                    WebFavorites,
                                    WebForward,
                                    WebHome,
                                    WebRefresh,
                                    WebSearch,
                                    WebStop,
                                    Yen,
                                    Copy,
                                    Paste,
                                    Cut,
                                  }
                                  impl ::core::fmt::Debug for VirtualKeyCode {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                                      match self {
                                        VirtualKeyCode::Key1 => {
                                          f.debug_tuple("VirtualKeyCode::Key1").finish()
                                        }
                                        VirtualKeyCode::Key2 => {
                                          f.debug_tuple("VirtualKeyCode::Key2").finish()
                                        }
                                        VirtualKeyCode::Key3 => {
                                          f.debug_tuple("VirtualKeyCode::Key3").finish()
                                        }
                                        VirtualKeyCode::Key4 => {
                                          f.debug_tuple("VirtualKeyCode::Key4").finish()
                                        }
                                        VirtualKeyCode::Key5 => {
                                          f.debug_tuple("VirtualKeyCode::Key5").finish()
                                        }
                                        VirtualKeyCode::Key6 => {
                                          f.debug_tuple("VirtualKeyCode::Key6").finish()
                                        }
                                        VirtualKeyCode::Key7 => {
                                          f.debug_tuple("VirtualKeyCode::Key7").finish()
                                        }
                                        VirtualKeyCode::Key8 => {
                                          f.debug_tuple("VirtualKeyCode::Key8").finish()
                                        }
                                        VirtualKeyCode::Key9 => {
                                          f.debug_tuple("VirtualKeyCode::Key9").finish()
                                        }
                                        VirtualKeyCode::Key0 => {
                                          f.debug_tuple("VirtualKeyCode::Key0").finish()
                                        }
                                        VirtualKeyCode::A => {
                                          f.debug_tuple("VirtualKeyCode::A").finish()
                                        }
                                        VirtualKeyCode::B => {
                                          f.debug_tuple("VirtualKeyCode::B").finish()
                                        }
                                        VirtualKeyCode::C => {
                                          f.debug_tuple("VirtualKeyCode::C").finish()
                                        }
                                        VirtualKeyCode::D => {
                                          f.debug_tuple("VirtualKeyCode::D").finish()
                                        }
                                        VirtualKeyCode::E => {
                                          f.debug_tuple("VirtualKeyCode::E").finish()
                                        }
                                        VirtualKeyCode::F => {
                                          f.debug_tuple("VirtualKeyCode::F").finish()
                                        }
                                        VirtualKeyCode::G => {
                                          f.debug_tuple("VirtualKeyCode::G").finish()
                                        }
                                        VirtualKeyCode::H => {
                                          f.debug_tuple("VirtualKeyCode::H").finish()
                                        }
                                        VirtualKeyCode::I => {
                                          f.debug_tuple("VirtualKeyCode::I").finish()
                                        }
                                        VirtualKeyCode::J => {
                                          f.debug_tuple("VirtualKeyCode::J").finish()
                                        }
                                        VirtualKeyCode::K => {
                                          f.debug_tuple("VirtualKeyCode::K").finish()
                                        }
                                        VirtualKeyCode::L => {
                                          f.debug_tuple("VirtualKeyCode::L").finish()
                                        }
                                        VirtualKeyCode::M => {
                                          f.debug_tuple("VirtualKeyCode::M").finish()
                                        }
                                        VirtualKeyCode::N => {
                                          f.debug_tuple("VirtualKeyCode::N").finish()
                                        }
                                        VirtualKeyCode::O => {
                                          f.debug_tuple("VirtualKeyCode::O").finish()
                                        }
                                        VirtualKeyCode::P => {
                                          f.debug_tuple("VirtualKeyCode::P").finish()
                                        }
                                        VirtualKeyCode::Q => {
                                          f.debug_tuple("VirtualKeyCode::Q").finish()
                                        }
                                        VirtualKeyCode::R => {
                                          f.debug_tuple("VirtualKeyCode::R").finish()
                                        }
                                        VirtualKeyCode::S => {
                                          f.debug_tuple("VirtualKeyCode::S").finish()
                                        }
                                        VirtualKeyCode::T => {
                                          f.debug_tuple("VirtualKeyCode::T").finish()
                                        }
                                        VirtualKeyCode::U => {
                                          f.debug_tuple("VirtualKeyCode::U").finish()
                                        }
                                        VirtualKeyCode::V => {
                                          f.debug_tuple("VirtualKeyCode::V").finish()
                                        }
                                        VirtualKeyCode::W => {
                                          f.debug_tuple("VirtualKeyCode::W").finish()
                                        }
                                        VirtualKeyCode::X => {
                                          f.debug_tuple("VirtualKeyCode::X").finish()
                                        }
                                        VirtualKeyCode::Y => {
                                          f.debug_tuple("VirtualKeyCode::Y").finish()
                                        }
                                        VirtualKeyCode::Z => {
                                          f.debug_tuple("VirtualKeyCode::Z").finish()
                                        }
                                        VirtualKeyCode::Escape => {
                                          f.debug_tuple("VirtualKeyCode::Escape").finish()
                                        }
                                        VirtualKeyCode::F1 => {
                                          f.debug_tuple("VirtualKeyCode::F1").finish()
                                        }
                                        VirtualKeyCode::F2 => {
                                          f.debug_tuple("VirtualKeyCode::F2").finish()
                                        }
                                        VirtualKeyCode::F3 => {
                                          f.debug_tuple("VirtualKeyCode::F3").finish()
                                        }
                                        VirtualKeyCode::F4 => {
                                          f.debug_tuple("VirtualKeyCode::F4").finish()
                                        }
                                        VirtualKeyCode::F5 => {
                                          f.debug_tuple("VirtualKeyCode::F5").finish()
                                        }
                                        VirtualKeyCode::F6 => {
                                          f.debug_tuple("VirtualKeyCode::F6").finish()
                                        }
                                        VirtualKeyCode::F7 => {
                                          f.debug_tuple("VirtualKeyCode::F7").finish()
                                        }
                                        VirtualKeyCode::F8 => {
                                          f.debug_tuple("VirtualKeyCode::F8").finish()
                                        }
                                        VirtualKeyCode::F9 => {
                                          f.debug_tuple("VirtualKeyCode::F9").finish()
                                        }
                                        VirtualKeyCode::F10 => {
                                          f.debug_tuple("VirtualKeyCode::F10").finish()
                                        }
                                        VirtualKeyCode::F11 => {
                                          f.debug_tuple("VirtualKeyCode::F11").finish()
                                        }
                                        VirtualKeyCode::F12 => {
                                          f.debug_tuple("VirtualKeyCode::F12").finish()
                                        }
                                        VirtualKeyCode::F13 => {
                                          f.debug_tuple("VirtualKeyCode::F13").finish()
                                        }
                                        VirtualKeyCode::F14 => {
                                          f.debug_tuple("VirtualKeyCode::F14").finish()
                                        }
                                        VirtualKeyCode::F15 => {
                                          f.debug_tuple("VirtualKeyCode::F15").finish()
                                        }
                                        VirtualKeyCode::F16 => {
                                          f.debug_tuple("VirtualKeyCode::F16").finish()
                                        }
                                        VirtualKeyCode::F17 => {
                                          f.debug_tuple("VirtualKeyCode::F17").finish()
                                        }
                                        VirtualKeyCode::F18 => {
                                          f.debug_tuple("VirtualKeyCode::F18").finish()
                                        }
                                        VirtualKeyCode::F19 => {
                                          f.debug_tuple("VirtualKeyCode::F19").finish()
                                        }
                                        VirtualKeyCode::F20 => {
                                          f.debug_tuple("VirtualKeyCode::F20").finish()
                                        }
                                        VirtualKeyCode::F21 => {
                                          f.debug_tuple("VirtualKeyCode::F21").finish()
                                        }
                                        VirtualKeyCode::F22 => {
                                          f.debug_tuple("VirtualKeyCode::F22").finish()
                                        }
                                        VirtualKeyCode::F23 => {
                                          f.debug_tuple("VirtualKeyCode::F23").finish()
                                        }
                                        VirtualKeyCode::F24 => {
                                          f.debug_tuple("VirtualKeyCode::F24").finish()
                                        }
                                        VirtualKeyCode::Snapshot => {
                                          f.debug_tuple("VirtualKeyCode::Snapshot").finish()
                                        }
                                        VirtualKeyCode::Scroll => {
                                          f.debug_tuple("VirtualKeyCode::Scroll").finish()
                                        }
                                        VirtualKeyCode::Pause => {
                                          f.debug_tuple("VirtualKeyCode::Pause").finish()
                                        }
                                        VirtualKeyCode::Insert => {
                                          f.debug_tuple("VirtualKeyCode::Insert").finish()
                                        }
                                        VirtualKeyCode::Home => {
                                          f.debug_tuple("VirtualKeyCode::Home").finish()
                                        }
                                        VirtualKeyCode::Delete => {
                                          f.debug_tuple("VirtualKeyCode::Delete").finish()
                                        }
                                        VirtualKeyCode::End => {
                                          f.debug_tuple("VirtualKeyCode::End").finish()
                                        }
                                        VirtualKeyCode::PageDown => {
                                          f.debug_tuple("VirtualKeyCode::PageDown").finish()
                                        }
                                        VirtualKeyCode::PageUp => {
                                          f.debug_tuple("VirtualKeyCode::PageUp").finish()
                                        }
                                        VirtualKeyCode::Left => {
                                          f.debug_tuple("VirtualKeyCode::Left").finish()
                                        }
                                        VirtualKeyCode::Up => {
                                          f.debug_tuple("VirtualKeyCode::Up").finish()
                                        }
                                        VirtualKeyCode::Right => {
                                          f.debug_tuple("VirtualKeyCode::Right").finish()
                                        }
                                        VirtualKeyCode::Down => {
                                          f.debug_tuple("VirtualKeyCode::Down").finish()
                                        }
                                        VirtualKeyCode::Back => {
                                          f.debug_tuple("VirtualKeyCode::Back").finish()
                                        }
                                        VirtualKeyCode::Return => {
                                          f.debug_tuple("VirtualKeyCode::Return").finish()
                                        }
                                        VirtualKeyCode::Space => {
                                          f.debug_tuple("VirtualKeyCode::Space").finish()
                                        }
                                        VirtualKeyCode::Compose => {
                                          f.debug_tuple("VirtualKeyCode::Compose").finish()
                                        }
                                        VirtualKeyCode::Caret => {
                                          f.debug_tuple("VirtualKeyCode::Caret").finish()
                                        }
                                        VirtualKeyCode::Numlock => {
                                          f.debug_tuple("VirtualKeyCode::Numlock").finish()
                                        }
                                        VirtualKeyCode::Numpad0 => {
                                          f.debug_tuple("VirtualKeyCode::Numpad0").finish()
                                        }
                                        VirtualKeyCode::Numpad1 => {
                                          f.debug_tuple("VirtualKeyCode::Numpad1").finish()
                                        }
                                        VirtualKeyCode::Numpad2 => {
                                          f.debug_tuple("VirtualKeyCode::Numpad2").finish()
                                        }
                                        VirtualKeyCode::Numpad3 => {
                                          f.debug_tuple("VirtualKeyCode::Numpad3").finish()
                                        }
                                        VirtualKeyCode::Numpad4 => {
                                          f.debug_tuple("VirtualKeyCode::Numpad4").finish()
                                        }
                                        VirtualKeyCode::Numpad5 => {
                                          f.debug_tuple("VirtualKeyCode::Numpad5").finish()
                                        }
                                        VirtualKeyCode::Numpad6 => {
                                          f.debug_tuple("VirtualKeyCode::Numpad6").finish()
                                        }
                                        VirtualKeyCode::Numpad7 => {
                                          f.debug_tuple("VirtualKeyCode::Numpad7").finish()
                                        }
                                        VirtualKeyCode::Numpad8 => {
                                          f.debug_tuple("VirtualKeyCode::Numpad8").finish()
                                        }
                                        VirtualKeyCode::Numpad9 => {
                                          f.debug_tuple("VirtualKeyCode::Numpad9").finish()
                                        }
                                        VirtualKeyCode::NumpadAdd => {
                                          f.debug_tuple("VirtualKeyCode::NumpadAdd").finish()
                                        }
                                        VirtualKeyCode::NumpadDivide => {
                                          f.debug_tuple("VirtualKeyCode::NumpadDivide").finish()
                                        }
                                        VirtualKeyCode::NumpadDecimal => {
                                          f.debug_tuple("VirtualKeyCode::NumpadDecimal").finish()
                                        }
                                        VirtualKeyCode::NumpadComma => {
                                          f.debug_tuple("VirtualKeyCode::NumpadComma").finish()
                                        }
                                        VirtualKeyCode::NumpadEnter => {
                                          f.debug_tuple("VirtualKeyCode::NumpadEnter").finish()
                                        }
                                        VirtualKeyCode::NumpadEquals => {
                                          f.debug_tuple("VirtualKeyCode::NumpadEquals").finish()
                                        }
                                        VirtualKeyCode::NumpadMultiply => {
                                          f.debug_tuple("VirtualKeyCode::NumpadMultiply").finish()
                                        }
                                        VirtualKeyCode::NumpadSubtract => {
                                          f.debug_tuple("VirtualKeyCode::NumpadSubtract").finish()
                                        }
                                        VirtualKeyCode::AbntC1 => {
                                          f.debug_tuple("VirtualKeyCode::AbntC1").finish()
                                        }
                                        VirtualKeyCode::AbntC2 => {
                                          f.debug_tuple("VirtualKeyCode::AbntC2").finish()
                                        }
                                        VirtualKeyCode::Apostrophe => {
                                          f.debug_tuple("VirtualKeyCode::Apostrophe").finish()
                                        }
                                        VirtualKeyCode::Apps => {
                                          f.debug_tuple("VirtualKeyCode::Apps").finish()
                                        }
                                        VirtualKeyCode::Asterisk => {
                                          f.debug_tuple("VirtualKeyCode::Asterisk").finish()
                                        }
                                        VirtualKeyCode::At => {
                                          f.debug_tuple("VirtualKeyCode::At").finish()
                                        }
                                        VirtualKeyCode::Ax => {
                                          f.debug_tuple("VirtualKeyCode::Ax").finish()
                                        }
                                        VirtualKeyCode::Backslash => {
                                          f.debug_tuple("VirtualKeyCode::Backslash").finish()
                                        }
                                        VirtualKeyCode::Calculator => {
                                          f.debug_tuple("VirtualKeyCode::Calculator").finish()
                                        }
                                        VirtualKeyCode::Capital => {
                                          f.debug_tuple("VirtualKeyCode::Capital").finish()
                                        }
                                        VirtualKeyCode::Colon => {
                                          f.debug_tuple("VirtualKeyCode::Colon").finish()
                                        }
                                        VirtualKeyCode::Comma => {
                                          f.debug_tuple("VirtualKeyCode::Comma").finish()
                                        }
                                        VirtualKeyCode::Convert => {
                                          f.debug_tuple("VirtualKeyCode::Convert").finish()
                                        }
                                        VirtualKeyCode::Equals => {
                                          f.debug_tuple("VirtualKeyCode::Equals").finish()
                                        }
                                        VirtualKeyCode::Grave => {
                                          f.debug_tuple("VirtualKeyCode::Grave").finish()
                                        }
                                        VirtualKeyCode::Kana => {
                                          f.debug_tuple("VirtualKeyCode::Kana").finish()
                                        }
                                        VirtualKeyCode::Kanji => {
                                          f.debug_tuple("VirtualKeyCode::Kanji").finish()
                                        }
                                        VirtualKeyCode::LAlt => {
                                          f.debug_tuple("VirtualKeyCode::LAlt").finish()
                                        }
                                        VirtualKeyCode::LBracket => {
                                          f.debug_tuple("VirtualKeyCode::LBracket").finish()
                                        }
                                        VirtualKeyCode::LControl => {
                                          f.debug_tuple("VirtualKeyCode::LControl").finish()
                                        }
                                        VirtualKeyCode::LShift => {
                                          f.debug_tuple("VirtualKeyCode::LShift").finish()
                                        }
                                        VirtualKeyCode::LWin => {
                                          f.debug_tuple("VirtualKeyCode::LWin").finish()
                                        }
                                        VirtualKeyCode::Mail => {
                                          f.debug_tuple("VirtualKeyCode::Mail").finish()
                                        }
                                        VirtualKeyCode::MediaSelect => {
                                          f.debug_tuple("VirtualKeyCode::MediaSelect").finish()
                                        }
                                        VirtualKeyCode::MediaStop => {
                                          f.debug_tuple("VirtualKeyCode::MediaStop").finish()
                                        }
                                        VirtualKeyCode::Minus => {
                                          f.debug_tuple("VirtualKeyCode::Minus").finish()
                                        }
                                        VirtualKeyCode::Mute => {
                                          f.debug_tuple("VirtualKeyCode::Mute").finish()
                                        }
                                        VirtualKeyCode::MyComputer => {
                                          f.debug_tuple("VirtualKeyCode::MyComputer").finish()
                                        }
                                        VirtualKeyCode::NavigateForward => {
                                          f.debug_tuple("VirtualKeyCode::NavigateForward").finish()
                                        }
                                        VirtualKeyCode::NavigateBackward => {
                                          f.debug_tuple("VirtualKeyCode::NavigateBackward").finish()
                                        }
                                        VirtualKeyCode::NextTrack => {
                                          f.debug_tuple("VirtualKeyCode::NextTrack").finish()
                                        }
                                        VirtualKeyCode::NoConvert => {
                                          f.debug_tuple("VirtualKeyCode::NoConvert").finish()
                                        }
                                        VirtualKeyCode::Oem102 => {
                                          f.debug_tuple("VirtualKeyCode::Oem102").finish()
                                        }
                                        VirtualKeyCode::Period => {
                                          f.debug_tuple("VirtualKeyCode::Period").finish()
                                        }
                                        VirtualKeyCode::PlayPause => {
                                          f.debug_tuple("VirtualKeyCode::PlayPause").finish()
                                        }
                                        VirtualKeyCode::Plus => {
                                          f.debug_tuple("VirtualKeyCode::Plus").finish()
                                        }
                                        VirtualKeyCode::Power => {
                                          f.debug_tuple("VirtualKeyCode::Power").finish()
                                        }
                                        VirtualKeyCode::PrevTrack => {
                                          f.debug_tuple("VirtualKeyCode::PrevTrack").finish()
                                        }
                                        VirtualKeyCode::RAlt => {
                                          f.debug_tuple("VirtualKeyCode::RAlt").finish()
                                        }
                                        VirtualKeyCode::RBracket => {
                                          f.debug_tuple("VirtualKeyCode::RBracket").finish()
                                        }
                                        VirtualKeyCode::RControl => {
                                          f.debug_tuple("VirtualKeyCode::RControl").finish()
                                        }
                                        VirtualKeyCode::RShift => {
                                          f.debug_tuple("VirtualKeyCode::RShift").finish()
                                        }
                                        VirtualKeyCode::RWin => {
                                          f.debug_tuple("VirtualKeyCode::RWin").finish()
                                        }
                                        VirtualKeyCode::Semicolon => {
                                          f.debug_tuple("VirtualKeyCode::Semicolon").finish()
                                        }
                                        VirtualKeyCode::Slash => {
                                          f.debug_tuple("VirtualKeyCode::Slash").finish()
                                        }
                                        VirtualKeyCode::Sleep => {
                                          f.debug_tuple("VirtualKeyCode::Sleep").finish()
                                        }
                                        VirtualKeyCode::Stop => {
                                          f.debug_tuple("VirtualKeyCode::Stop").finish()
                                        }
                                        VirtualKeyCode::Sysrq => {
                                          f.debug_tuple("VirtualKeyCode::Sysrq").finish()
                                        }
                                        VirtualKeyCode::Tab => {
                                          f.debug_tuple("VirtualKeyCode::Tab").finish()
                                        }
                                        VirtualKeyCode::Underline => {
                                          f.debug_tuple("VirtualKeyCode::Underline").finish()
                                        }
                                        VirtualKeyCode::Unlabeled => {
                                          f.debug_tuple("VirtualKeyCode::Unlabeled").finish()
                                        }
                                        VirtualKeyCode::VolumeDown => {
                                          f.debug_tuple("VirtualKeyCode::VolumeDown").finish()
                                        }
                                        VirtualKeyCode::VolumeUp => {
                                          f.debug_tuple("VirtualKeyCode::VolumeUp").finish()
                                        }
                                        VirtualKeyCode::Wake => {
                                          f.debug_tuple("VirtualKeyCode::Wake").finish()
                                        }
                                        VirtualKeyCode::WebBack => {
                                          f.debug_tuple("VirtualKeyCode::WebBack").finish()
                                        }
                                        VirtualKeyCode::WebFavorites => {
                                          f.debug_tuple("VirtualKeyCode::WebFavorites").finish()
                                        }
                                        VirtualKeyCode::WebForward => {
                                          f.debug_tuple("VirtualKeyCode::WebForward").finish()
                                        }
                                        VirtualKeyCode::WebHome => {
                                          f.debug_tuple("VirtualKeyCode::WebHome").finish()
                                        }
                                        VirtualKeyCode::WebRefresh => {
                                          f.debug_tuple("VirtualKeyCode::WebRefresh").finish()
                                        }
                                        VirtualKeyCode::WebSearch => {
                                          f.debug_tuple("VirtualKeyCode::WebSearch").finish()
                                        }
                                        VirtualKeyCode::WebStop => {
                                          f.debug_tuple("VirtualKeyCode::WebStop").finish()
                                        }
                                        VirtualKeyCode::Yen => {
                                          f.debug_tuple("VirtualKeyCode::Yen").finish()
                                        }
                                        VirtualKeyCode::Copy => {
                                          f.debug_tuple("VirtualKeyCode::Copy").finish()
                                        }
                                        VirtualKeyCode::Paste => {
                                          f.debug_tuple("VirtualKeyCode::Paste").finish()
                                        }
                                        VirtualKeyCode::Cut => {
                                          f.debug_tuple("VirtualKeyCode::Cut").finish()
                                        }
                                      }
                                    }
                                  }
                                  #[derive(Clone, Copy)]
                                  pub enum MouseButton{
                                    Left,
                                    Right,
                                    Middle,
                                    Other(u16),
                                  }
                                  impl ::core::fmt::Debug for MouseButton {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                                      match self {
                                        MouseButton::Left => {
                                          f.debug_tuple("MouseButton::Left").finish()
                                        }
                                        MouseButton::Right => {
                                          f.debug_tuple("MouseButton::Right").finish()
                                        }
                                        MouseButton::Middle => {
                                          f.debug_tuple("MouseButton::Middle").finish()
                                        }
                                        MouseButton::Other(e) => {
                                          f.debug_tuple("MouseButton::Other").field(e).finish()
                                        }
                                      }
                                    }
                                  }
                                  #[derive(Clone)]
                                  pub struct Input {
                                    pub keys: wit_bindgen::rt::vec::Vec::<VirtualKeyCode>,
                                    pub mouse_position: Vec2,
                                    pub mouse_delta: Vec2,
                                    pub mouse_wheel: f32,
                                    pub mouse_buttons: wit_bindgen::rt::vec::Vec::<MouseButton>,
                                  }
                                  impl ::core::fmt::Debug for Input {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                                      f.debug_struct("Input").field("keys", &self.keys).field("mouse-position", &self.mouse_position).field("mouse-delta", &self.mouse_delta).field("mouse-wheel", &self.mouse_wheel).field("mouse-buttons", &self.mouse_buttons).finish()
                                    }
                                  }
                                  #[derive(Clone, Copy)]
                                  pub enum CursorIcon{
                                    /// The platform-dependent default cursor.
                                    DefaultIcon,
                                    /// A simple crosshair.
                                    Crosshair,
                                    /// A hand (often used to indicate links in web browsers).
                                    Hand,
                                    /// Self explanatory.
                                    Arrow,
                                    /// Indicates something is to be moved.
                                    Move,
                                    /// Indicates text that may be selected or edited.
                                    Text,
                                    /// Program busy indicator.
                                    Wait,
                                    /// Help indicator (often rendered as a "?")
                                    Help,
                                    /// Progress indicator. Shows that processing is being done. But in contrast
                                    /// with "Wait" the user may still interact with the program. Often rendered
                                    /// as a spinning beach ball, or an arrow with a watch or hourglass.
                                    Progress,
                                    /// Cursor showing that something cannot be done.
                                    NotAllowed,
                                    ContextMenu,
                                    Cell,
                                    VerticalText,
                                    Alias,
                                    Copy,
                                    NoDrop,
                                    /// Indicates something can be grabbed.
                                    Grab,
                                    /// Indicates something is grabbed.
                                    Grabbing,
                                    AllScroll,
                                    ZoomIn,
                                    ZoomOut,
                                    /// Indicate that some edge is to be moved. For example, the 'SeResize' cursor
                                    /// is used when the movement starts from the south-east corner of the box.
                                    EResize,
                                    NResize,
                                    NeResize,
                                    NwResize,
                                    SResize,
                                    SeResize,
                                    SwResize,
                                    WResize,
                                    EwResize,
                                    NsResize,
                                    NeswResize,
                                    NwseResize,
                                    ColResize,
                                    RowResize,
                                  }
                                  impl ::core::fmt::Debug for CursorIcon {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                                      match self {
                                        CursorIcon::DefaultIcon => {
                                          f.debug_tuple("CursorIcon::DefaultIcon").finish()
                                        }
                                        CursorIcon::Crosshair => {
                                          f.debug_tuple("CursorIcon::Crosshair").finish()
                                        }
                                        CursorIcon::Hand => {
                                          f.debug_tuple("CursorIcon::Hand").finish()
                                        }
                                        CursorIcon::Arrow => {
                                          f.debug_tuple("CursorIcon::Arrow").finish()
                                        }
                                        CursorIcon::Move => {
                                          f.debug_tuple("CursorIcon::Move").finish()
                                        }
                                        CursorIcon::Text => {
                                          f.debug_tuple("CursorIcon::Text").finish()
                                        }
                                        CursorIcon::Wait => {
                                          f.debug_tuple("CursorIcon::Wait").finish()
                                        }
                                        CursorIcon::Help => {
                                          f.debug_tuple("CursorIcon::Help").finish()
                                        }
                                        CursorIcon::Progress => {
                                          f.debug_tuple("CursorIcon::Progress").finish()
                                        }
                                        CursorIcon::NotAllowed => {
                                          f.debug_tuple("CursorIcon::NotAllowed").finish()
                                        }
                                        CursorIcon::ContextMenu => {
                                          f.debug_tuple("CursorIcon::ContextMenu").finish()
                                        }
                                        CursorIcon::Cell => {
                                          f.debug_tuple("CursorIcon::Cell").finish()
                                        }
                                        CursorIcon::VerticalText => {
                                          f.debug_tuple("CursorIcon::VerticalText").finish()
                                        }
                                        CursorIcon::Alias => {
                                          f.debug_tuple("CursorIcon::Alias").finish()
                                        }
                                        CursorIcon::Copy => {
                                          f.debug_tuple("CursorIcon::Copy").finish()
                                        }
                                        CursorIcon::NoDrop => {
                                          f.debug_tuple("CursorIcon::NoDrop").finish()
                                        }
                                        CursorIcon::Grab => {
                                          f.debug_tuple("CursorIcon::Grab").finish()
                                        }
                                        CursorIcon::Grabbing => {
                                          f.debug_tuple("CursorIcon::Grabbing").finish()
                                        }
                                        CursorIcon::AllScroll => {
                                          f.debug_tuple("CursorIcon::AllScroll").finish()
                                        }
                                        CursorIcon::ZoomIn => {
                                          f.debug_tuple("CursorIcon::ZoomIn").finish()
                                        }
                                        CursorIcon::ZoomOut => {
                                          f.debug_tuple("CursorIcon::ZoomOut").finish()
                                        }
                                        CursorIcon::EResize => {
                                          f.debug_tuple("CursorIcon::EResize").finish()
                                        }
                                        CursorIcon::NResize => {
                                          f.debug_tuple("CursorIcon::NResize").finish()
                                        }
                                        CursorIcon::NeResize => {
                                          f.debug_tuple("CursorIcon::NeResize").finish()
                                        }
                                        CursorIcon::NwResize => {
                                          f.debug_tuple("CursorIcon::NwResize").finish()
                                        }
                                        CursorIcon::SResize => {
                                          f.debug_tuple("CursorIcon::SResize").finish()
                                        }
                                        CursorIcon::SeResize => {
                                          f.debug_tuple("CursorIcon::SeResize").finish()
                                        }
                                        CursorIcon::SwResize => {
                                          f.debug_tuple("CursorIcon::SwResize").finish()
                                        }
                                        CursorIcon::WResize => {
                                          f.debug_tuple("CursorIcon::WResize").finish()
                                        }
                                        CursorIcon::EwResize => {
                                          f.debug_tuple("CursorIcon::EwResize").finish()
                                        }
                                        CursorIcon::NsResize => {
                                          f.debug_tuple("CursorIcon::NsResize").finish()
                                        }
                                        CursorIcon::NeswResize => {
                                          f.debug_tuple("CursorIcon::NeswResize").finish()
                                        }
                                        CursorIcon::NwseResize => {
                                          f.debug_tuple("CursorIcon::NwseResize").finish()
                                        }
                                        CursorIcon::ColResize => {
                                          f.debug_tuple("CursorIcon::ColResize").finish()
                                        }
                                        CursorIcon::RowResize => {
                                          f.debug_tuple("CursorIcon::RowResize").finish()
                                        }
                                      }
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn get() -> Input{
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[repr(align(4))]
                                      struct RetArea([u8; 36]);
                                      let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                      let ptr0 = ret_area.as_mut_ptr() as i32;
                                      #[link(wasm_import_module = "ambient:bindings/client-input")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "get")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-input_get")]
                                        fn wit_import(
                                        _: i32, );
                                      }
                                      wit_import(ptr0);
                                      let base1 = *((ptr0 + 0) as *const i32);
                                      let len1 = *((ptr0 + 4) as *const i32);
                                      let mut result1 = Vec::with_capacity(len1 as usize);
                                      for i in 0..len1 {
                                        let base = base1 + i *1;
                                        result1.push({#[cfg(debug_assertions)]{match i32::from(*((base + 0) as *const u8)) {
                                          0 => VirtualKeyCode::Key1,
                                          1 => VirtualKeyCode::Key2,
                                          2 => VirtualKeyCode::Key3,
                                          3 => VirtualKeyCode::Key4,
                                          4 => VirtualKeyCode::Key5,
                                          5 => VirtualKeyCode::Key6,
                                          6 => VirtualKeyCode::Key7,
                                          7 => VirtualKeyCode::Key8,
                                          8 => VirtualKeyCode::Key9,
                                          9 => VirtualKeyCode::Key0,
                                          10 => VirtualKeyCode::A,
                                          11 => VirtualKeyCode::B,
                                          12 => VirtualKeyCode::C,
                                          13 => VirtualKeyCode::D,
                                          14 => VirtualKeyCode::E,
                                          15 => VirtualKeyCode::F,
                                          16 => VirtualKeyCode::G,
                                          17 => VirtualKeyCode::H,
                                          18 => VirtualKeyCode::I,
                                          19 => VirtualKeyCode::J,
                                          20 => VirtualKeyCode::K,
                                          21 => VirtualKeyCode::L,
                                          22 => VirtualKeyCode::M,
                                          23 => VirtualKeyCode::N,
                                          24 => VirtualKeyCode::O,
                                          25 => VirtualKeyCode::P,
                                          26 => VirtualKeyCode::Q,
                                          27 => VirtualKeyCode::R,
                                          28 => VirtualKeyCode::S,
                                          29 => VirtualKeyCode::T,
                                          30 => VirtualKeyCode::U,
                                          31 => VirtualKeyCode::V,
                                          32 => VirtualKeyCode::W,
                                          33 => VirtualKeyCode::X,
                                          34 => VirtualKeyCode::Y,
                                          35 => VirtualKeyCode::Z,
                                          36 => VirtualKeyCode::Escape,
                                          37 => VirtualKeyCode::F1,
                                          38 => VirtualKeyCode::F2,
                                          39 => VirtualKeyCode::F3,
                                          40 => VirtualKeyCode::F4,
                                          41 => VirtualKeyCode::F5,
                                          42 => VirtualKeyCode::F6,
                                          43 => VirtualKeyCode::F7,
                                          44 => VirtualKeyCode::F8,
                                          45 => VirtualKeyCode::F9,
                                          46 => VirtualKeyCode::F10,
                                          47 => VirtualKeyCode::F11,
                                          48 => VirtualKeyCode::F12,
                                          49 => VirtualKeyCode::F13,
                                          50 => VirtualKeyCode::F14,
                                          51 => VirtualKeyCode::F15,
                                          52 => VirtualKeyCode::F16,
                                          53 => VirtualKeyCode::F17,
                                          54 => VirtualKeyCode::F18,
                                          55 => VirtualKeyCode::F19,
                                          56 => VirtualKeyCode::F20,
                                          57 => VirtualKeyCode::F21,
                                          58 => VirtualKeyCode::F22,
                                          59 => VirtualKeyCode::F23,
                                          60 => VirtualKeyCode::F24,
                                          61 => VirtualKeyCode::Snapshot,
                                          62 => VirtualKeyCode::Scroll,
                                          63 => VirtualKeyCode::Pause,
                                          64 => VirtualKeyCode::Insert,
                                          65 => VirtualKeyCode::Home,
                                          66 => VirtualKeyCode::Delete,
                                          67 => VirtualKeyCode::End,
                                          68 => VirtualKeyCode::PageDown,
                                          69 => VirtualKeyCode::PageUp,
                                          70 => VirtualKeyCode::Left,
                                          71 => VirtualKeyCode::Up,
                                          72 => VirtualKeyCode::Right,
                                          73 => VirtualKeyCode::Down,
                                          74 => VirtualKeyCode::Back,
                                          75 => VirtualKeyCode::Return,
                                          76 => VirtualKeyCode::Space,
                                          77 => VirtualKeyCode::Compose,
                                          78 => VirtualKeyCode::Caret,
                                          79 => VirtualKeyCode::Numlock,
                                          80 => VirtualKeyCode::Numpad0,
                                          81 => VirtualKeyCode::Numpad1,
                                          82 => VirtualKeyCode::Numpad2,
                                          83 => VirtualKeyCode::Numpad3,
                                          84 => VirtualKeyCode::Numpad4,
                                          85 => VirtualKeyCode::Numpad5,
                                          86 => VirtualKeyCode::Numpad6,
                                          87 => VirtualKeyCode::Numpad7,
                                          88 => VirtualKeyCode::Numpad8,
                                          89 => VirtualKeyCode::Numpad9,
                                          90 => VirtualKeyCode::NumpadAdd,
                                          91 => VirtualKeyCode::NumpadDivide,
                                          92 => VirtualKeyCode::NumpadDecimal,
                                          93 => VirtualKeyCode::NumpadComma,
                                          94 => VirtualKeyCode::NumpadEnter,
                                          95 => VirtualKeyCode::NumpadEquals,
                                          96 => VirtualKeyCode::NumpadMultiply,
                                          97 => VirtualKeyCode::NumpadSubtract,
                                          98 => VirtualKeyCode::AbntC1,
                                          99 => VirtualKeyCode::AbntC2,
                                          100 => VirtualKeyCode::Apostrophe,
                                          101 => VirtualKeyCode::Apps,
                                          102 => VirtualKeyCode::Asterisk,
                                          103 => VirtualKeyCode::At,
                                          104 => VirtualKeyCode::Ax,
                                          105 => VirtualKeyCode::Backslash,
                                          106 => VirtualKeyCode::Calculator,
                                          107 => VirtualKeyCode::Capital,
                                          108 => VirtualKeyCode::Colon,
                                          109 => VirtualKeyCode::Comma,
                                          110 => VirtualKeyCode::Convert,
                                          111 => VirtualKeyCode::Equals,
                                          112 => VirtualKeyCode::Grave,
                                          113 => VirtualKeyCode::Kana,
                                          114 => VirtualKeyCode::Kanji,
                                          115 => VirtualKeyCode::LAlt,
                                          116 => VirtualKeyCode::LBracket,
                                          117 => VirtualKeyCode::LControl,
                                          118 => VirtualKeyCode::LShift,
                                          119 => VirtualKeyCode::LWin,
                                          120 => VirtualKeyCode::Mail,
                                          121 => VirtualKeyCode::MediaSelect,
                                          122 => VirtualKeyCode::MediaStop,
                                          123 => VirtualKeyCode::Minus,
                                          124 => VirtualKeyCode::Mute,
                                          125 => VirtualKeyCode::MyComputer,
                                          126 => VirtualKeyCode::NavigateForward,
                                          127 => VirtualKeyCode::NavigateBackward,
                                          128 => VirtualKeyCode::NextTrack,
                                          129 => VirtualKeyCode::NoConvert,
                                          130 => VirtualKeyCode::Oem102,
                                          131 => VirtualKeyCode::Period,
                                          132 => VirtualKeyCode::PlayPause,
                                          133 => VirtualKeyCode::Plus,
                                          134 => VirtualKeyCode::Power,
                                          135 => VirtualKeyCode::PrevTrack,
                                          136 => VirtualKeyCode::RAlt,
                                          137 => VirtualKeyCode::RBracket,
                                          138 => VirtualKeyCode::RControl,
                                          139 => VirtualKeyCode::RShift,
                                          140 => VirtualKeyCode::RWin,
                                          141 => VirtualKeyCode::Semicolon,
                                          142 => VirtualKeyCode::Slash,
                                          143 => VirtualKeyCode::Sleep,
                                          144 => VirtualKeyCode::Stop,
                                          145 => VirtualKeyCode::Sysrq,
                                          146 => VirtualKeyCode::Tab,
                                          147 => VirtualKeyCode::Underline,
                                          148 => VirtualKeyCode::Unlabeled,
                                          149 => VirtualKeyCode::VolumeDown,
                                          150 => VirtualKeyCode::VolumeUp,
                                          151 => VirtualKeyCode::Wake,
                                          152 => VirtualKeyCode::WebBack,
                                          153 => VirtualKeyCode::WebFavorites,
                                          154 => VirtualKeyCode::WebForward,
                                          155 => VirtualKeyCode::WebHome,
                                          156 => VirtualKeyCode::WebRefresh,
                                          157 => VirtualKeyCode::WebSearch,
                                          158 => VirtualKeyCode::WebStop,
                                          159 => VirtualKeyCode::Yen,
                                          160 => VirtualKeyCode::Copy,
                                          161 => VirtualKeyCode::Paste,
                                          162 => VirtualKeyCode::Cut,
                                          _ => panic!("invalid enum discriminant"),
                                        }}#[cfg(not(debug_assertions))]{::core::mem::transmute::<_, VirtualKeyCode>(i32::from(*((base + 0) as *const u8)) as u8)}});
                                      }
                                      wit_bindgen::rt::dealloc(base1, (len1 as usize) * 1, 1);
                                      let base2 = *((ptr0 + 28) as *const i32);
                                      let len2 = *((ptr0 + 32) as *const i32);
                                      let mut result2 = Vec::with_capacity(len2 as usize);
                                      for i in 0..len2 {
                                        let base = base2 + i *4;
                                        result2.push({{match i32::from(*((base + 0) as *const u8)) {
                                          0 => MouseButton::Left,
                                          1 => MouseButton::Right,
                                          2 => MouseButton::Middle,
                                          #[cfg(debug_assertions)]3 => MouseButton::Other(i32::from(*((base + 2) as *const u16)) as u16),
                                          #[cfg(not(debug_assertions))]_ => MouseButton::Other(i32::from(*((base + 2) as *const u16)) as u16),
                                          #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                        }}});
                                      }
                                      wit_bindgen::rt::dealloc(base2, (len2 as usize) * 4, 2);
                                      Input{keys:result1, mouse_position:super::super::super::ambient::bindings::types::Vec2{x:*((ptr0 + 8) as *const f32), y:*((ptr0 + 12) as *const f32), }, mouse_delta:super::super::super::ambient::bindings::types::Vec2{x:*((ptr0 + 16) as *const f32), y:*((ptr0 + 20) as *const f32), }, mouse_wheel:*((ptr0 + 24) as *const f32), mouse_buttons:result2, }
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn get_previous() -> Input{
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[repr(align(4))]
                                      struct RetArea([u8; 36]);
                                      let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                      let ptr0 = ret_area.as_mut_ptr() as i32;
                                      #[link(wasm_import_module = "ambient:bindings/client-input")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "get-previous")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-input_get-previous")]
                                        fn wit_import(
                                        _: i32, );
                                      }
                                      wit_import(ptr0);
                                      let base1 = *((ptr0 + 0) as *const i32);
                                      let len1 = *((ptr0 + 4) as *const i32);
                                      let mut result1 = Vec::with_capacity(len1 as usize);
                                      for i in 0..len1 {
                                        let base = base1 + i *1;
                                        result1.push({#[cfg(debug_assertions)]{match i32::from(*((base + 0) as *const u8)) {
                                          0 => VirtualKeyCode::Key1,
                                          1 => VirtualKeyCode::Key2,
                                          2 => VirtualKeyCode::Key3,
                                          3 => VirtualKeyCode::Key4,
                                          4 => VirtualKeyCode::Key5,
                                          5 => VirtualKeyCode::Key6,
                                          6 => VirtualKeyCode::Key7,
                                          7 => VirtualKeyCode::Key8,
                                          8 => VirtualKeyCode::Key9,
                                          9 => VirtualKeyCode::Key0,
                                          10 => VirtualKeyCode::A,
                                          11 => VirtualKeyCode::B,
                                          12 => VirtualKeyCode::C,
                                          13 => VirtualKeyCode::D,
                                          14 => VirtualKeyCode::E,
                                          15 => VirtualKeyCode::F,
                                          16 => VirtualKeyCode::G,
                                          17 => VirtualKeyCode::H,
                                          18 => VirtualKeyCode::I,
                                          19 => VirtualKeyCode::J,
                                          20 => VirtualKeyCode::K,
                                          21 => VirtualKeyCode::L,
                                          22 => VirtualKeyCode::M,
                                          23 => VirtualKeyCode::N,
                                          24 => VirtualKeyCode::O,
                                          25 => VirtualKeyCode::P,
                                          26 => VirtualKeyCode::Q,
                                          27 => VirtualKeyCode::R,
                                          28 => VirtualKeyCode::S,
                                          29 => VirtualKeyCode::T,
                                          30 => VirtualKeyCode::U,
                                          31 => VirtualKeyCode::V,
                                          32 => VirtualKeyCode::W,
                                          33 => VirtualKeyCode::X,
                                          34 => VirtualKeyCode::Y,
                                          35 => VirtualKeyCode::Z,
                                          36 => VirtualKeyCode::Escape,
                                          37 => VirtualKeyCode::F1,
                                          38 => VirtualKeyCode::F2,
                                          39 => VirtualKeyCode::F3,
                                          40 => VirtualKeyCode::F4,
                                          41 => VirtualKeyCode::F5,
                                          42 => VirtualKeyCode::F6,
                                          43 => VirtualKeyCode::F7,
                                          44 => VirtualKeyCode::F8,
                                          45 => VirtualKeyCode::F9,
                                          46 => VirtualKeyCode::F10,
                                          47 => VirtualKeyCode::F11,
                                          48 => VirtualKeyCode::F12,
                                          49 => VirtualKeyCode::F13,
                                          50 => VirtualKeyCode::F14,
                                          51 => VirtualKeyCode::F15,
                                          52 => VirtualKeyCode::F16,
                                          53 => VirtualKeyCode::F17,
                                          54 => VirtualKeyCode::F18,
                                          55 => VirtualKeyCode::F19,
                                          56 => VirtualKeyCode::F20,
                                          57 => VirtualKeyCode::F21,
                                          58 => VirtualKeyCode::F22,
                                          59 => VirtualKeyCode::F23,
                                          60 => VirtualKeyCode::F24,
                                          61 => VirtualKeyCode::Snapshot,
                                          62 => VirtualKeyCode::Scroll,
                                          63 => VirtualKeyCode::Pause,
                                          64 => VirtualKeyCode::Insert,
                                          65 => VirtualKeyCode::Home,
                                          66 => VirtualKeyCode::Delete,
                                          67 => VirtualKeyCode::End,
                                          68 => VirtualKeyCode::PageDown,
                                          69 => VirtualKeyCode::PageUp,
                                          70 => VirtualKeyCode::Left,
                                          71 => VirtualKeyCode::Up,
                                          72 => VirtualKeyCode::Right,
                                          73 => VirtualKeyCode::Down,
                                          74 => VirtualKeyCode::Back,
                                          75 => VirtualKeyCode::Return,
                                          76 => VirtualKeyCode::Space,
                                          77 => VirtualKeyCode::Compose,
                                          78 => VirtualKeyCode::Caret,
                                          79 => VirtualKeyCode::Numlock,
                                          80 => VirtualKeyCode::Numpad0,
                                          81 => VirtualKeyCode::Numpad1,
                                          82 => VirtualKeyCode::Numpad2,
                                          83 => VirtualKeyCode::Numpad3,
                                          84 => VirtualKeyCode::Numpad4,
                                          85 => VirtualKeyCode::Numpad5,
                                          86 => VirtualKeyCode::Numpad6,
                                          87 => VirtualKeyCode::Numpad7,
                                          88 => VirtualKeyCode::Numpad8,
                                          89 => VirtualKeyCode::Numpad9,
                                          90 => VirtualKeyCode::NumpadAdd,
                                          91 => VirtualKeyCode::NumpadDivide,
                                          92 => VirtualKeyCode::NumpadDecimal,
                                          93 => VirtualKeyCode::NumpadComma,
                                          94 => VirtualKeyCode::NumpadEnter,
                                          95 => VirtualKeyCode::NumpadEquals,
                                          96 => VirtualKeyCode::NumpadMultiply,
                                          97 => VirtualKeyCode::NumpadSubtract,
                                          98 => VirtualKeyCode::AbntC1,
                                          99 => VirtualKeyCode::AbntC2,
                                          100 => VirtualKeyCode::Apostrophe,
                                          101 => VirtualKeyCode::Apps,
                                          102 => VirtualKeyCode::Asterisk,
                                          103 => VirtualKeyCode::At,
                                          104 => VirtualKeyCode::Ax,
                                          105 => VirtualKeyCode::Backslash,
                                          106 => VirtualKeyCode::Calculator,
                                          107 => VirtualKeyCode::Capital,
                                          108 => VirtualKeyCode::Colon,
                                          109 => VirtualKeyCode::Comma,
                                          110 => VirtualKeyCode::Convert,
                                          111 => VirtualKeyCode::Equals,
                                          112 => VirtualKeyCode::Grave,
                                          113 => VirtualKeyCode::Kana,
                                          114 => VirtualKeyCode::Kanji,
                                          115 => VirtualKeyCode::LAlt,
                                          116 => VirtualKeyCode::LBracket,
                                          117 => VirtualKeyCode::LControl,
                                          118 => VirtualKeyCode::LShift,
                                          119 => VirtualKeyCode::LWin,
                                          120 => VirtualKeyCode::Mail,
                                          121 => VirtualKeyCode::MediaSelect,
                                          122 => VirtualKeyCode::MediaStop,
                                          123 => VirtualKeyCode::Minus,
                                          124 => VirtualKeyCode::Mute,
                                          125 => VirtualKeyCode::MyComputer,
                                          126 => VirtualKeyCode::NavigateForward,
                                          127 => VirtualKeyCode::NavigateBackward,
                                          128 => VirtualKeyCode::NextTrack,
                                          129 => VirtualKeyCode::NoConvert,
                                          130 => VirtualKeyCode::Oem102,
                                          131 => VirtualKeyCode::Period,
                                          132 => VirtualKeyCode::PlayPause,
                                          133 => VirtualKeyCode::Plus,
                                          134 => VirtualKeyCode::Power,
                                          135 => VirtualKeyCode::PrevTrack,
                                          136 => VirtualKeyCode::RAlt,
                                          137 => VirtualKeyCode::RBracket,
                                          138 => VirtualKeyCode::RControl,
                                          139 => VirtualKeyCode::RShift,
                                          140 => VirtualKeyCode::RWin,
                                          141 => VirtualKeyCode::Semicolon,
                                          142 => VirtualKeyCode::Slash,
                                          143 => VirtualKeyCode::Sleep,
                                          144 => VirtualKeyCode::Stop,
                                          145 => VirtualKeyCode::Sysrq,
                                          146 => VirtualKeyCode::Tab,
                                          147 => VirtualKeyCode::Underline,
                                          148 => VirtualKeyCode::Unlabeled,
                                          149 => VirtualKeyCode::VolumeDown,
                                          150 => VirtualKeyCode::VolumeUp,
                                          151 => VirtualKeyCode::Wake,
                                          152 => VirtualKeyCode::WebBack,
                                          153 => VirtualKeyCode::WebFavorites,
                                          154 => VirtualKeyCode::WebForward,
                                          155 => VirtualKeyCode::WebHome,
                                          156 => VirtualKeyCode::WebRefresh,
                                          157 => VirtualKeyCode::WebSearch,
                                          158 => VirtualKeyCode::WebStop,
                                          159 => VirtualKeyCode::Yen,
                                          160 => VirtualKeyCode::Copy,
                                          161 => VirtualKeyCode::Paste,
                                          162 => VirtualKeyCode::Cut,
                                          _ => panic!("invalid enum discriminant"),
                                        }}#[cfg(not(debug_assertions))]{::core::mem::transmute::<_, VirtualKeyCode>(i32::from(*((base + 0) as *const u8)) as u8)}});
                                      }
                                      wit_bindgen::rt::dealloc(base1, (len1 as usize) * 1, 1);
                                      let base2 = *((ptr0 + 28) as *const i32);
                                      let len2 = *((ptr0 + 32) as *const i32);
                                      let mut result2 = Vec::with_capacity(len2 as usize);
                                      for i in 0..len2 {
                                        let base = base2 + i *4;
                                        result2.push({{match i32::from(*((base + 0) as *const u8)) {
                                          0 => MouseButton::Left,
                                          1 => MouseButton::Right,
                                          2 => MouseButton::Middle,
                                          #[cfg(debug_assertions)]3 => MouseButton::Other(i32::from(*((base + 2) as *const u16)) as u16),
                                          #[cfg(not(debug_assertions))]_ => MouseButton::Other(i32::from(*((base + 2) as *const u16)) as u16),
                                          #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                        }}});
                                      }
                                      wit_bindgen::rt::dealloc(base2, (len2 as usize) * 4, 2);
                                      Input{keys:result1, mouse_position:super::super::super::ambient::bindings::types::Vec2{x:*((ptr0 + 8) as *const f32), y:*((ptr0 + 12) as *const f32), }, mouse_delta:super::super::super::ambient::bindings::types::Vec2{x:*((ptr0 + 16) as *const f32), y:*((ptr0 + 20) as *const f32), }, mouse_wheel:*((ptr0 + 24) as *const f32), mouse_buttons:result2, }
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn set_cursor(icon: CursorIcon,){
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      let result0 = match icon {
                                        CursorIcon::DefaultIcon=> {
                                          0i32
                                        }
                                        CursorIcon::Crosshair=> {
                                          1i32
                                        }
                                        CursorIcon::Hand=> {
                                          2i32
                                        }
                                        CursorIcon::Arrow=> {
                                          3i32
                                        }
                                        CursorIcon::Move=> {
                                          4i32
                                        }
                                        CursorIcon::Text=> {
                                          5i32
                                        }
                                        CursorIcon::Wait=> {
                                          6i32
                                        }
                                        CursorIcon::Help=> {
                                          7i32
                                        }
                                        CursorIcon::Progress=> {
                                          8i32
                                        }
                                        CursorIcon::NotAllowed=> {
                                          9i32
                                        }
                                        CursorIcon::ContextMenu=> {
                                          10i32
                                        }
                                        CursorIcon::Cell=> {
                                          11i32
                                        }
                                        CursorIcon::VerticalText=> {
                                          12i32
                                        }
                                        CursorIcon::Alias=> {
                                          13i32
                                        }
                                        CursorIcon::Copy=> {
                                          14i32
                                        }
                                        CursorIcon::NoDrop=> {
                                          15i32
                                        }
                                        CursorIcon::Grab=> {
                                          16i32
                                        }
                                        CursorIcon::Grabbing=> {
                                          17i32
                                        }
                                        CursorIcon::AllScroll=> {
                                          18i32
                                        }
                                        CursorIcon::ZoomIn=> {
                                          19i32
                                        }
                                        CursorIcon::ZoomOut=> {
                                          20i32
                                        }
                                        CursorIcon::EResize=> {
                                          21i32
                                        }
                                        CursorIcon::NResize=> {
                                          22i32
                                        }
                                        CursorIcon::NeResize=> {
                                          23i32
                                        }
                                        CursorIcon::NwResize=> {
                                          24i32
                                        }
                                        CursorIcon::SResize=> {
                                          25i32
                                        }
                                        CursorIcon::SeResize=> {
                                          26i32
                                        }
                                        CursorIcon::SwResize=> {
                                          27i32
                                        }
                                        CursorIcon::WResize=> {
                                          28i32
                                        }
                                        CursorIcon::EwResize=> {
                                          29i32
                                        }
                                        CursorIcon::NsResize=> {
                                          30i32
                                        }
                                        CursorIcon::NeswResize=> {
                                          31i32
                                        }
                                        CursorIcon::NwseResize=> {
                                          32i32
                                        }
                                        CursorIcon::ColResize=> {
                                          33i32
                                        }
                                        CursorIcon::RowResize=> {
                                          34i32
                                        }
                                      };
                                      
                                      #[link(wasm_import_module = "ambient:bindings/client-input")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "set-cursor")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-input_set-cursor")]
                                        fn wit_import(
                                        _: i32, );
                                      }
                                      wit_import(result0);
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn set_cursor_visible(visible: bool,){
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[link(wasm_import_module = "ambient:bindings/client-input")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "set-cursor-visible")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-input_set-cursor-visible")]
                                        fn wit_import(
                                        _: i32, );
                                      }
                                      wit_import(match visible { true => 1, false => 0 });
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn set_cursor_lock(locked: bool,){
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[link(wasm_import_module = "ambient:bindings/client-input")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "set-cursor-lock")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-input_set-cursor-lock")]
                                        fn wit_import(
                                        _: i32, );
                                      }
                                      wit_import(match locked { true => 1, false => 0 });
                                    }
                                  }
                                  
                                }
                                
                                
                                #[allow(clippy::all)]
                                pub mod client_camera {
                                  #[used]
                                  #[doc(hidden)]
                                  #[cfg(target_arch = "wasm32")]
                                  static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
                                  
                                  pub type Vec3 = super::super::super::ambient::bindings::types::Vec3;
                                  pub type Vec2 = super::super::super::ambient::bindings::types::Vec2;
                                  pub type Ray = super::super::super::ambient::bindings::types::Ray;
                                  pub type EntityId = super::super::super::ambient::bindings::types::EntityId;
                                  #[allow(clippy::all)]
                                  pub fn clip_position_to_world_ray(camera: EntityId,clip_space_pos: Vec2,) -> Ray{
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[repr(align(4))]
                                      struct RetArea([u8; 24]);
                                      let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                      let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = camera;
                                      let super::super::super::ambient::bindings::types::Vec2{ x:x1, y:y1, } = clip_space_pos;
                                      let ptr2 = ret_area.as_mut_ptr() as i32;
                                      #[link(wasm_import_module = "ambient:bindings/client-camera")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "clip-position-to-world-ray")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-camera_clip-position-to-world-ray")]
                                        fn wit_import(
                                        _: i64, _: i64, _: f32, _: f32, _: i32, );
                                      }
                                      wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), ptr2);
                                      super::super::super::ambient::bindings::types::Ray{origin:super::super::super::ambient::bindings::types::Vec3{x:*((ptr2 + 0) as *const f32), y:*((ptr2 + 4) as *const f32), z:*((ptr2 + 8) as *const f32), }, dir:super::super::super::ambient::bindings::types::Vec3{x:*((ptr2 + 12) as *const f32), y:*((ptr2 + 16) as *const f32), z:*((ptr2 + 20) as *const f32), }, }
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn screen_to_clip_space(screen_pos: Vec2,) -> Vec2{
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[repr(align(4))]
                                      struct RetArea([u8; 8]);
                                      let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                      let super::super::super::ambient::bindings::types::Vec2{ x:x0, y:y0, } = screen_pos;
                                      let ptr1 = ret_area.as_mut_ptr() as i32;
                                      #[link(wasm_import_module = "ambient:bindings/client-camera")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "screen-to-clip-space")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-camera_screen-to-clip-space")]
                                        fn wit_import(
                                        _: f32, _: f32, _: i32, );
                                      }
                                      wit_import(wit_bindgen::rt::as_f32(x0), wit_bindgen::rt::as_f32(y0), ptr1);
                                      super::super::super::ambient::bindings::types::Vec2{x:*((ptr1 + 0) as *const f32), y:*((ptr1 + 4) as *const f32), }
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn screen_position_to_world_ray(camera: EntityId,screen_pos: Vec2,) -> Ray{
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[repr(align(4))]
                                      struct RetArea([u8; 24]);
                                      let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                      let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = camera;
                                      let super::super::super::ambient::bindings::types::Vec2{ x:x1, y:y1, } = screen_pos;
                                      let ptr2 = ret_area.as_mut_ptr() as i32;
                                      #[link(wasm_import_module = "ambient:bindings/client-camera")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "screen-position-to-world-ray")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-camera_screen-position-to-world-ray")]
                                        fn wit_import(
                                        _: i64, _: i64, _: f32, _: f32, _: i32, );
                                      }
                                      wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), ptr2);
                                      super::super::super::ambient::bindings::types::Ray{origin:super::super::super::ambient::bindings::types::Vec3{x:*((ptr2 + 0) as *const f32), y:*((ptr2 + 4) as *const f32), z:*((ptr2 + 8) as *const f32), }, dir:super::super::super::ambient::bindings::types::Vec3{x:*((ptr2 + 12) as *const f32), y:*((ptr2 + 16) as *const f32), z:*((ptr2 + 20) as *const f32), }, }
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn world_to_screen(camera: EntityId,screen_pos: Vec3,) -> Vec2{
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[repr(align(4))]
                                      struct RetArea([u8; 8]);
                                      let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                      let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = camera;
                                      let super::super::super::ambient::bindings::types::Vec3{ x:x1, y:y1, z:z1, } = screen_pos;
                                      let ptr2 = ret_area.as_mut_ptr() as i32;
                                      #[link(wasm_import_module = "ambient:bindings/client-camera")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "world-to-screen")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-camera_world-to-screen")]
                                        fn wit_import(
                                        _: i64, _: i64, _: f32, _: f32, _: f32, _: i32, );
                                      }
                                      wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1), ptr2);
                                      super::super::super::ambient::bindings::types::Vec2{x:*((ptr2 + 0) as *const f32), y:*((ptr2 + 4) as *const f32), }
                                    }
                                  }
                                  
                                }
                                
                                
                                #[allow(clippy::all)]
                                pub mod client_clipboard {
                                  #[used]
                                  #[doc(hidden)]
                                  #[cfg(target_arch = "wasm32")]
                                  static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
                                  
                                  #[allow(clippy::all)]
                                  pub fn get() -> Option<wit_bindgen::rt::string::String>{
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[repr(align(4))]
                                      struct RetArea([u8; 12]);
                                      let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                      let ptr0 = ret_area.as_mut_ptr() as i32;
                                      #[link(wasm_import_module = "ambient:bindings/client-clipboard")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "get")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-clipboard_get")]
                                        fn wit_import(
                                        _: i32, );
                                      }
                                      wit_import(ptr0);
                                      match i32::from(*((ptr0 + 0) as *const u8)) {
                                        0 => None,
                                        1 => Some({
                                          let len1 = *((ptr0 + 8) as *const i32) as usize;
                                          
                                          {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr0 + 4) as *const i32) as *mut _, len1, len1))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr0 + 4) as *const i32) as *mut _, len1, len1)).unwrap()}}
                                        }),
                                        #[cfg(not(debug_assertions))]
                                        _ => ::core::hint::unreachable_unchecked(),
                                        #[cfg(debug_assertions)]
                                        _ => panic!("invalid enum discriminant"),
                                      }
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn set(text: &str,){
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      let vec0 = text;
                                      let ptr0 = vec0.as_ptr() as i32;
                                      let len0 = vec0.len() as i32;
                                      
                                      #[link(wasm_import_module = "ambient:bindings/client-clipboard")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "set")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-clipboard_set")]
                                        fn wit_import(
                                        _: i32, _: i32, );
                                      }
                                      wit_import(ptr0, len0);
                                    }
                                  }
                                  
                                }
                                
                                
                                #[allow(clippy::all)]
                                pub mod client_window {
                                  #[used]
                                  #[doc(hidden)]
                                  #[cfg(target_arch = "wasm32")]
                                  static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
                                  
                                  #[allow(clippy::all)]
                                  pub fn set_fullscreen(fullscreen: bool,){
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[link(wasm_import_module = "ambient:bindings/client-window")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "set-fullscreen")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-window_set-fullscreen")]
                                        fn wit_import(
                                        _: i32, );
                                      }
                                      wit_import(match fullscreen { true => 1, false => 0 });
                                    }
                                  }
                                  
                                }
                                
                                
                                #[allow(clippy::all)]
                                pub mod server_asset {
                                  #[used]
                                  #[doc(hidden)]
                                  #[cfg(target_arch = "wasm32")]
                                  static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
                                  
                                  #[allow(clippy::all)]
                                  pub fn build_wasm(){
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[link(wasm_import_module = "ambient:bindings/server-asset")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "build-wasm")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/server-asset_build-wasm")]
                                        fn wit_import(
                                        );
                                      }
                                      wit_import();
                                    }
                                  }
                                  
                                }
                                
                                
                                #[allow(clippy::all)]
                                pub mod server_physics {
                                  #[used]
                                  #[doc(hidden)]
                                  #[cfg(target_arch = "wasm32")]
                                  static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
                                  
                                  pub type EntityId = super::super::super::ambient::bindings::types::EntityId;
                                  pub type Vec3 = super::super::super::ambient::bindings::types::Vec3;
                                  pub type Mat4 = super::super::super::ambient::bindings::types::Mat4;
                                  #[repr(C)]
                                  #[derive(Copy, Clone)]
                                  pub struct CharacterCollision {
                                    pub side: bool,
                                    pub up: bool,
                                    pub down: bool,
                                  }
                                  impl ::core::fmt::Debug for CharacterCollision {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                                      f.debug_struct("CharacterCollision").field("side", &self.side).field("up", &self.up).field("down", &self.down).finish()
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn add_force(entity: EntityId,force: Vec3,){
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                                      let super::super::super::ambient::bindings::types::Vec3{ x:x1, y:y1, z:z1, } = force;
                                      
                                      #[link(wasm_import_module = "ambient:bindings/server-physics")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "add-force")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/server-physics_add-force")]
                                        fn wit_import(
                                        _: i64, _: i64, _: f32, _: f32, _: f32, );
                                      }
                                      wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1));
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn add_impulse(entity: EntityId,impulse: Vec3,){
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                                      let super::super::super::ambient::bindings::types::Vec3{ x:x1, y:y1, z:z1, } = impulse;
                                      
                                      #[link(wasm_import_module = "ambient:bindings/server-physics")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "add-impulse")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/server-physics_add-impulse")]
                                        fn wit_import(
                                        _: i64, _: i64, _: f32, _: f32, _: f32, );
                                      }
                                      wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1));
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn add_radial_impulse(position: Vec3,impulse: f32,radius: f32,falloff_radius: Option<f32>,){
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      let super::super::super::ambient::bindings::types::Vec3{ x:x0, y:y0, z:z0, } = position;
                                      let (result1_0,result1_1,) = match falloff_radius {
                                        Some(e) => (1i32, wit_bindgen::rt::as_f32(e)),
                                        None => {
                                          (0i32, 0.0f32)
                                        },
                                      };
                                      #[link(wasm_import_module = "ambient:bindings/server-physics")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "add-radial-impulse")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/server-physics_add-radial-impulse")]
                                        fn wit_import(
                                        _: f32, _: f32, _: f32, _: f32, _: f32, _: i32, _: f32, );
                                      }
                                      wit_import(wit_bindgen::rt::as_f32(x0), wit_bindgen::rt::as_f32(y0), wit_bindgen::rt::as_f32(z0), wit_bindgen::rt::as_f32(impulse), wit_bindgen::rt::as_f32(radius), result1_0, result1_1);
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn add_force_at_position(entity: EntityId,force: Vec3,position: Vec3,){
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                                      let super::super::super::ambient::bindings::types::Vec3{ x:x1, y:y1, z:z1, } = force;
                                      let super::super::super::ambient::bindings::types::Vec3{ x:x2, y:y2, z:z2, } = position;
                                      
                                      #[link(wasm_import_module = "ambient:bindings/server-physics")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "add-force-at-position")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/server-physics_add-force-at-position")]
                                        fn wit_import(
                                        _: i64, _: i64, _: f32, _: f32, _: f32, _: f32, _: f32, _: f32, );
                                      }
                                      wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1), wit_bindgen::rt::as_f32(x2), wit_bindgen::rt::as_f32(y2), wit_bindgen::rt::as_f32(z2));
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn add_impulse_at_position(entity: EntityId,impulse: Vec3,position: Vec3,){
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                                      let super::super::super::ambient::bindings::types::Vec3{ x:x1, y:y1, z:z1, } = impulse;
                                      let super::super::super::ambient::bindings::types::Vec3{ x:x2, y:y2, z:z2, } = position;
                                      
                                      #[link(wasm_import_module = "ambient:bindings/server-physics")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "add-impulse-at-position")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/server-physics_add-impulse-at-position")]
                                        fn wit_import(
                                        _: i64, _: i64, _: f32, _: f32, _: f32, _: f32, _: f32, _: f32, );
                                      }
                                      wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1), wit_bindgen::rt::as_f32(x2), wit_bindgen::rt::as_f32(y2), wit_bindgen::rt::as_f32(z2));
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn get_velocity_at_position(entity: EntityId,position: Vec3,) -> Vec3{
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[repr(align(4))]
                                      struct RetArea([u8; 12]);
                                      let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                      let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                                      let super::super::super::ambient::bindings::types::Vec3{ x:x1, y:y1, z:z1, } = position;
                                      let ptr2 = ret_area.as_mut_ptr() as i32;
                                      #[link(wasm_import_module = "ambient:bindings/server-physics")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "get-velocity-at-position")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/server-physics_get-velocity-at-position")]
                                        fn wit_import(
                                        _: i64, _: i64, _: f32, _: f32, _: f32, _: i32, );
                                      }
                                      wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1), ptr2);
                                      super::super::super::ambient::bindings::types::Vec3{x:*((ptr2 + 0) as *const f32), y:*((ptr2 + 4) as *const f32), z:*((ptr2 + 8) as *const f32), }
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn set_gravity(gravity: Vec3,){
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      let super::super::super::ambient::bindings::types::Vec3{ x:x0, y:y0, z:z0, } = gravity;
                                      
                                      #[link(wasm_import_module = "ambient:bindings/server-physics")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "set-gravity")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/server-physics_set-gravity")]
                                        fn wit_import(
                                        _: f32, _: f32, _: f32, );
                                      }
                                      wit_import(wit_bindgen::rt::as_f32(x0), wit_bindgen::rt::as_f32(y0), wit_bindgen::rt::as_f32(z0));
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn unfreeze(entity: EntityId,){
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                                      
                                      #[link(wasm_import_module = "ambient:bindings/server-physics")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "unfreeze")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/server-physics_unfreeze")]
                                        fn wit_import(
                                        _: i64, _: i64, );
                                      }
                                      wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10));
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn freeze(entity: EntityId,){
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                                      
                                      #[link(wasm_import_module = "ambient:bindings/server-physics")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "freeze")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/server-physics_freeze")]
                                        fn wit_import(
                                        _: i64, _: i64, );
                                      }
                                      wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10));
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn start_motor(entity: EntityId,velocity: f32,){
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                                      
                                      #[link(wasm_import_module = "ambient:bindings/server-physics")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "start-motor")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/server-physics_start-motor")]
                                        fn wit_import(
                                        _: i64, _: i64, _: f32, );
                                      }
                                      wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(velocity));
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn stop_motor(entity: EntityId,){
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                                      
                                      #[link(wasm_import_module = "ambient:bindings/server-physics")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "stop-motor")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/server-physics_stop-motor")]
                                        fn wit_import(
                                        _: i64, _: i64, );
                                      }
                                      wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10));
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn create_revolute_joint(actor0: EntityId,transform0: Mat4,actor1: EntityId,transform1: Mat4,){
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[repr(align(8))]
                                      struct RetArea([u8; 160]);
                                      let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                      let ptr0 = ret_area.as_mut_ptr() as i32;let super::super::super::ambient::bindings::types::EntityId{ id0:id01, id1:id11, } = actor0;
                                      *((ptr0 + 0) as *mut i64) = wit_bindgen::rt::as_i64(id01);
                                      *((ptr0 + 8) as *mut i64) = wit_bindgen::rt::as_i64(id11);
                                      let super::super::super::ambient::bindings::types::Mat4{ x:x2, y:y2, z:z2, w:w2, } = transform0;
                                      let super::super::super::ambient::bindings::types::Vec4{ x:x3, y:y3, z:z3, w:w3, } = x2;
                                      *((ptr0 + 16) as *mut f32) = wit_bindgen::rt::as_f32(x3);
                                      *((ptr0 + 20) as *mut f32) = wit_bindgen::rt::as_f32(y3);
                                      *((ptr0 + 24) as *mut f32) = wit_bindgen::rt::as_f32(z3);
                                      *((ptr0 + 28) as *mut f32) = wit_bindgen::rt::as_f32(w3);
                                      let super::super::super::ambient::bindings::types::Vec4{ x:x4, y:y4, z:z4, w:w4, } = y2;
                                      *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x4);
                                      *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y4);
                                      *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z4);
                                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w4);
                                      let super::super::super::ambient::bindings::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = z2;
                                      *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(x5);
                                      *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(y5);
                                      *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(z5);
                                      *((ptr0 + 60) as *mut f32) = wit_bindgen::rt::as_f32(w5);
                                      let super::super::super::ambient::bindings::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = w2;
                                      *((ptr0 + 64) as *mut f32) = wit_bindgen::rt::as_f32(x6);
                                      *((ptr0 + 68) as *mut f32) = wit_bindgen::rt::as_f32(y6);
                                      *((ptr0 + 72) as *mut f32) = wit_bindgen::rt::as_f32(z6);
                                      *((ptr0 + 76) as *mut f32) = wit_bindgen::rt::as_f32(w6);
                                      let super::super::super::ambient::bindings::types::EntityId{ id0:id07, id1:id17, } = actor1;
                                      *((ptr0 + 80) as *mut i64) = wit_bindgen::rt::as_i64(id07);
                                      *((ptr0 + 88) as *mut i64) = wit_bindgen::rt::as_i64(id17);
                                      let super::super::super::ambient::bindings::types::Mat4{ x:x8, y:y8, z:z8, w:w8, } = transform1;
                                      let super::super::super::ambient::bindings::types::Vec4{ x:x9, y:y9, z:z9, w:w9, } = x8;
                                      *((ptr0 + 96) as *mut f32) = wit_bindgen::rt::as_f32(x9);
                                      *((ptr0 + 100) as *mut f32) = wit_bindgen::rt::as_f32(y9);
                                      *((ptr0 + 104) as *mut f32) = wit_bindgen::rt::as_f32(z9);
                                      *((ptr0 + 108) as *mut f32) = wit_bindgen::rt::as_f32(w9);
                                      let super::super::super::ambient::bindings::types::Vec4{ x:x10, y:y10, z:z10, w:w10, } = y8;
                                      *((ptr0 + 112) as *mut f32) = wit_bindgen::rt::as_f32(x10);
                                      *((ptr0 + 116) as *mut f32) = wit_bindgen::rt::as_f32(y10);
                                      *((ptr0 + 120) as *mut f32) = wit_bindgen::rt::as_f32(z10);
                                      *((ptr0 + 124) as *mut f32) = wit_bindgen::rt::as_f32(w10);
                                      let super::super::super::ambient::bindings::types::Vec4{ x:x11, y:y11, z:z11, w:w11, } = z8;
                                      *((ptr0 + 128) as *mut f32) = wit_bindgen::rt::as_f32(x11);
                                      *((ptr0 + 132) as *mut f32) = wit_bindgen::rt::as_f32(y11);
                                      *((ptr0 + 136) as *mut f32) = wit_bindgen::rt::as_f32(z11);
                                      *((ptr0 + 140) as *mut f32) = wit_bindgen::rt::as_f32(w11);
                                      let super::super::super::ambient::bindings::types::Vec4{ x:x12, y:y12, z:z12, w:w12, } = w8;
                                      *((ptr0 + 144) as *mut f32) = wit_bindgen::rt::as_f32(x12);
                                      *((ptr0 + 148) as *mut f32) = wit_bindgen::rt::as_f32(y12);
                                      *((ptr0 + 152) as *mut f32) = wit_bindgen::rt::as_f32(z12);
                                      *((ptr0 + 156) as *mut f32) = wit_bindgen::rt::as_f32(w12);
                                      
                                      #[link(wasm_import_module = "ambient:bindings/server-physics")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "create-revolute-joint")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/server-physics_create-revolute-joint")]
                                        fn wit_import(
                                        _: i32, );
                                      }
                                      wit_import(ptr0);
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn raycast_first(origin: Vec3,direction: Vec3,) -> Option<(EntityId,f32,)>{
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[repr(align(8))]
                                      struct RetArea([u8; 32]);
                                      let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                      let super::super::super::ambient::bindings::types::Vec3{ x:x0, y:y0, z:z0, } = origin;
                                      let super::super::super::ambient::bindings::types::Vec3{ x:x1, y:y1, z:z1, } = direction;
                                      let ptr2 = ret_area.as_mut_ptr() as i32;
                                      #[link(wasm_import_module = "ambient:bindings/server-physics")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "raycast-first")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/server-physics_raycast-first")]
                                        fn wit_import(
                                        _: f32, _: f32, _: f32, _: f32, _: f32, _: f32, _: i32, );
                                      }
                                      wit_import(wit_bindgen::rt::as_f32(x0), wit_bindgen::rt::as_f32(y0), wit_bindgen::rt::as_f32(z0), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1), ptr2);
                                      match i32::from(*((ptr2 + 0) as *const u8)) {
                                        0 => None,
                                        1 => Some((super::super::super::ambient::bindings::types::EntityId{id0:*((ptr2 + 8) as *const i64) as u64, id1:*((ptr2 + 16) as *const i64) as u64, }, *((ptr2 + 24) as *const f32))),
                                        #[cfg(not(debug_assertions))]
                                        _ => ::core::hint::unreachable_unchecked(),
                                        #[cfg(debug_assertions)]
                                        _ => panic!("invalid enum discriminant"),
                                      }
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn raycast(origin: Vec3,direction: Vec3,) -> wit_bindgen::rt::vec::Vec::<(EntityId,f32,)>{
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[repr(align(4))]
                                      struct RetArea([u8; 8]);
                                      let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                      let super::super::super::ambient::bindings::types::Vec3{ x:x0, y:y0, z:z0, } = origin;
                                      let super::super::super::ambient::bindings::types::Vec3{ x:x1, y:y1, z:z1, } = direction;
                                      let ptr2 = ret_area.as_mut_ptr() as i32;
                                      #[link(wasm_import_module = "ambient:bindings/server-physics")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "raycast")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/server-physics_raycast")]
                                        fn wit_import(
                                        _: f32, _: f32, _: f32, _: f32, _: f32, _: f32, _: i32, );
                                      }
                                      wit_import(wit_bindgen::rt::as_f32(x0), wit_bindgen::rt::as_f32(y0), wit_bindgen::rt::as_f32(z0), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1), ptr2);
                                      let len3 = *((ptr2 + 4) as *const i32) as usize;
                                      Vec::from_raw_parts(*((ptr2 + 0) as *const i32) as *mut _, len3, len3)
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn move_character(entity: EntityId,displacement: Vec3,min_dist: f32,elapsed_time: f32,) -> CharacterCollision{
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      
                                      #[repr(align(1))]
                                      struct RetArea([u8; 3]);
                                      let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                      let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                                      let super::super::super::ambient::bindings::types::Vec3{ x:x1, y:y1, z:z1, } = displacement;
                                      let ptr2 = ret_area.as_mut_ptr() as i32;
                                      #[link(wasm_import_module = "ambient:bindings/server-physics")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "move-character")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/server-physics_move-character")]
                                        fn wit_import(
                                        _: i64, _: i64, _: f32, _: f32, _: f32, _: f32, _: f32, _: i32, );
                                      }
                                      wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1), wit_bindgen::rt::as_f32(min_dist), wit_bindgen::rt::as_f32(elapsed_time), ptr2);
                                      CharacterCollision{side:{
                                        #[cfg(not(debug_assertions))]
                                        { ::core::mem::transmute::<u8, bool>(i32::from(*((ptr2 + 0) as *const u8)) as u8) }
                                        #[cfg(debug_assertions)]
                                        {
                                          match i32::from(*((ptr2 + 0) as *const u8)) {
                                            0 => false,
                                            1 => true,
                                            _ => panic!("invalid bool discriminant"),
                                          }
                                        }
                                      }, up:{
                                        #[cfg(not(debug_assertions))]
                                        { ::core::mem::transmute::<u8, bool>(i32::from(*((ptr2 + 1) as *const u8)) as u8) }
                                        #[cfg(debug_assertions)]
                                        {
                                          match i32::from(*((ptr2 + 1) as *const u8)) {
                                            0 => false,
                                            1 => true,
                                            _ => panic!("invalid bool discriminant"),
                                          }
                                        }
                                      }, down:{
                                        #[cfg(not(debug_assertions))]
                                        { ::core::mem::transmute::<u8, bool>(i32::from(*((ptr2 + 2) as *const u8)) as u8) }
                                        #[cfg(debug_assertions)]
                                        {
                                          match i32::from(*((ptr2 + 2) as *const u8)) {
                                            0 => false,
                                            1 => true,
                                            _ => panic!("invalid bool discriminant"),
                                          }
                                        }
                                      }, }
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn set_character_position(entity: EntityId,position: Vec3,){
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                                      let super::super::super::ambient::bindings::types::Vec3{ x:x1, y:y1, z:z1, } = position;
                                      
                                      #[link(wasm_import_module = "ambient:bindings/server-physics")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "set-character-position")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/server-physics_set-character-position")]
                                        fn wit_import(
                                        _: i64, _: i64, _: f32, _: f32, _: f32, );
                                      }
                                      wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1));
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn set_character_foot_position(entity: EntityId,position: Vec3,){
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                                      let super::super::super::ambient::bindings::types::Vec3{ x:x1, y:y1, z:z1, } = position;
                                      
                                      #[link(wasm_import_module = "ambient:bindings/server-physics")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "set-character-foot-position")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/server-physics_set-character-foot-position")]
                                        fn wit_import(
                                        _: i64, _: i64, _: f32, _: f32, _: f32, );
                                      }
                                      wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1));
                                    }
                                  }
                                  
                                }
                                
                                
                                #[allow(clippy::all)]
                                pub mod server_message {
                                  #[used]
                                  #[doc(hidden)]
                                  #[cfg(target_arch = "wasm32")]
                                  static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
                                  
                                  pub type EntityId = super::super::super::ambient::bindings::types::EntityId;
                                  #[derive(Clone)]
                                  pub enum Target{
                                    ClientBroadcastUnreliable,
                                    ClientBroadcastReliable,
                                    ClientTargetedUnreliable(wit_bindgen::rt::string::String),
                                    ClientTargetedReliable(wit_bindgen::rt::string::String),
                                    LocalBroadcast(bool),
                                    Local(EntityId),
                                  }
                                  impl ::core::fmt::Debug for Target {
                                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                                      match self {
                                        Target::ClientBroadcastUnreliable => {
                                          f.debug_tuple("Target::ClientBroadcastUnreliable").finish()
                                        }
                                        Target::ClientBroadcastReliable => {
                                          f.debug_tuple("Target::ClientBroadcastReliable").finish()
                                        }
                                        Target::ClientTargetedUnreliable(e) => {
                                          f.debug_tuple("Target::ClientTargetedUnreliable").field(e).finish()
                                        }
                                        Target::ClientTargetedReliable(e) => {
                                          f.debug_tuple("Target::ClientTargetedReliable").field(e).finish()
                                        }
                                        Target::LocalBroadcast(e) => {
                                          f.debug_tuple("Target::LocalBroadcast").field(e).finish()
                                        }
                                        Target::Local(e) => {
                                          f.debug_tuple("Target::Local").field(e).finish()
                                        }
                                      }
                                    }
                                  }
                                  #[allow(clippy::all)]
                                  pub fn send(target_id: &Target,name: &str,data: &[u8],){
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      let (result3_0,result3_1,result3_2,) = match target_id {
                                        Target::ClientBroadcastUnreliable=> {
                                          (0i32, 0i64, 0i64)
                                        }
                                        Target::ClientBroadcastReliable=> {
                                          (1i32, 0i64, 0i64)
                                        }
                                        Target::ClientTargetedUnreliable(e) => {
                                          let vec0 = e;
                                          let ptr0 = vec0.as_ptr() as i32;
                                          let len0 = vec0.len() as i32;
                                          
                                          (2i32, i64::from(ptr0), i64::from(len0))
                                        },
                                        Target::ClientTargetedReliable(e) => {
                                          let vec1 = e;
                                          let ptr1 = vec1.as_ptr() as i32;
                                          let len1 = vec1.len() as i32;
                                          
                                          (3i32, i64::from(ptr1), i64::from(len1))
                                        },
                                        Target::LocalBroadcast(e) => (4i32, i64::from(match e { true => 1, false => 0 }), 0i64),
                                        Target::Local(e) => {
                                          let super::super::super::ambient::bindings::types::EntityId{ id0:id02, id1:id12, } = e;
                                          
                                          (5i32, wit_bindgen::rt::as_i64(id02), wit_bindgen::rt::as_i64(id12))
                                        },
                                      };
                                      let vec4 = name;
                                      let ptr4 = vec4.as_ptr() as i32;
                                      let len4 = vec4.len() as i32;
                                      let vec5 = data;
                                      let ptr5 = vec5.as_ptr() as i32;
                                      let len5 = vec5.len() as i32;
                                      
                                      #[link(wasm_import_module = "ambient:bindings/server-message")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "send")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/server-message_send")]
                                        fn wit_import(
                                        _: i32, _: i64, _: i64, _: i32, _: i32, _: i32, _: i32, );
                                      }
                                      wit_import(result3_0, result3_1, result3_2, ptr4, len4, ptr5, len5);
                                    }
                                  }
                                  
                                }
                                
                                
                                #[allow(clippy::all)]
                                pub mod server_http {
                                  #[used]
                                  #[doc(hidden)]
                                  #[cfg(target_arch = "wasm32")]
                                  static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
                                  
                                  #[allow(clippy::all)]
                                  pub fn get(url: &str,){
                                    
                                    #[allow(unused_imports)]
                                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                    unsafe {
                                      let vec0 = url;
                                      let ptr0 = vec0.as_ptr() as i32;
                                      let len0 = vec0.len() as i32;
                                      
                                      #[link(wasm_import_module = "ambient:bindings/server-http")]
                                      extern "C" {
                                        #[cfg_attr(target_arch = "wasm32", link_name = "get")]
                                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/server-http_get")]
                                        fn wit_import(
                                        _: i32, _: i32, );
                                      }
                                      wit_import(ptr0, len0);
                                    }
                                  }
                                  
                                }
                                
                              }
                            }
                            pub mod exports {
                              pub mod ambient {
                                pub mod bindings {
                                  
                                  #[allow(clippy::all)]
                                  pub mod guest {
                                    #[used]
                                    #[doc(hidden)]
                                    #[cfg(target_arch = "wasm32")]
                                    static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_section;
                                    
                                    pub type EntityId = super::super::super::super::ambient::bindings::types::EntityId;
                                    #[derive(Clone)]
                                    pub enum Source{
                                      Runtime,
                                      Local(EntityId),
                                      Server,
                                      Client(wit_bindgen::rt::string::String),
                                    }
                                    impl ::core::fmt::Debug for Source {
                                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                                        match self {
                                          Source::Runtime => {
                                            f.debug_tuple("Source::Runtime").finish()
                                          }
                                          Source::Local(e) => {
                                            f.debug_tuple("Source::Local").field(e).finish()
                                          }
                                          Source::Server => {
                                            f.debug_tuple("Source::Server").finish()
                                          }
                                          Source::Client(e) => {
                                            f.debug_tuple("Source::Client").field(e).finish()
                                          }
                                        }
                                      }
                                    }
                                    pub trait Guest {
                                      fn init();
                                      fn exec(message_source: Source,message_name: wit_bindgen::rt::string::String,message_data: wit_bindgen::rt::vec::Vec::<u8>,);
                                    }
                                    
                                    #[doc(hidden)]
                                    pub unsafe fn call_init<T: Guest>() {
                                      
                                      #[allow(unused_imports)]
                                      use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                      
                                      // Before executing any other code, use this function to run all static
                                      // constructors, if they have not yet been run. This is a hack required
                                      // to work around wasi-libc ctors calling import functions to initialize
                                      // the environment.
                                      //
                                      // This functionality will be removed once rust 1.69.0 is stable, at which
                                      // point wasi-libc will no longer have this behavior.
                                      //
                                      // See
                                      // https://github.com/bytecodealliance/preview2-prototyping/issues/99
                                      // for more details.
                                      #[cfg(target_arch="wasm32")]
                                      wit_bindgen::rt::run_ctors_once();
                                      
                                      T::init();
                                    }
                                    
                                    #[doc(hidden)]
                                    pub unsafe fn call_exec<T: Guest>(arg0: i32,arg1: i64,arg2: i64,arg3: i32,arg4: i32,arg5: i32,arg6: i32,) {
                                      
                                      #[allow(unused_imports)]
                                      use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                      
                                      // Before executing any other code, use this function to run all static
                                      // constructors, if they have not yet been run. This is a hack required
                                      // to work around wasi-libc ctors calling import functions to initialize
                                      // the environment.
                                      //
                                      // This functionality will be removed once rust 1.69.0 is stable, at which
                                      // point wasi-libc will no longer have this behavior.
                                      //
                                      // See
                                      // https://github.com/bytecodealliance/preview2-prototyping/issues/99
                                      // for more details.
                                      #[cfg(target_arch="wasm32")]
                                      wit_bindgen::rt::run_ctors_once();
                                      
                                      let len1 = arg4 as usize;
                                      let len2 = arg6 as usize;
                                      T::exec({{match arg0 {
                                        0 => Source::Runtime,
                                        1 => Source::Local(super::super::super::super::ambient::bindings::types::EntityId{id0:arg1 as u64, id1:arg2 as u64, }),
                                        2 => Source::Server,
                                        #[cfg(debug_assertions)]3 => Source::Client({
                                          let len0 = arg2 as i32 as usize;
                                          
                                          {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(arg1 as i32 as *mut _, len0, len0))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(arg1 as i32 as *mut _, len0, len0)).unwrap()}}
                                        }),
                                        #[cfg(not(debug_assertions))]_ => Source::Client({
                                          let len0 = arg2 as i32 as usize;
                                          
                                          {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(arg1 as i32 as *mut _, len0, len0))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(arg1 as i32 as *mut _, len0, len0)).unwrap()}}
                                        }),
                                        #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                      }}}, {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(arg3 as *mut _, len1, len1))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(arg3 as *mut _, len1, len1)).unwrap()}}, Vec::from_raw_parts(arg5 as *mut _, len2, len2));
                                    }
                                    
                                  }
                                  
                                }
                              }
                            }
                            
                            #[cfg(target_arch = "wasm32")]
                            #[link_section = "component-type:bindings"]
                            #[doc(hidden)]
                            pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 19270] = [3, 0, 8, 98, 105, 110, 100, 105, 110, 103, 115, 0, 97, 115, 109, 13, 0, 1, 0, 7, 204, 149, 1, 1, 65, 65, 1, 66, 5, 1, 113, 1, 11, 105, 110, 118, 97, 108, 105, 100, 45, 117, 114, 108, 1, 115, 0, 4, 0, 9, 117, 114, 108, 45, 101, 114, 114, 111, 114, 3, 0, 0, 1, 106, 1, 115, 1, 1, 1, 64, 1, 4, 112, 97, 116, 104, 115, 0, 2, 4, 0, 3, 117, 114, 108, 1, 3, 4, 1, 22, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 97, 115, 115, 101, 116, 5, 0, 1, 66, 5, 1, 107, 115, 1, 64, 0, 0, 0, 4, 0, 3, 103, 101, 116, 1, 1, 1, 64, 1, 4, 116, 101, 120, 116, 115, 1, 0, 4, 0, 3, 115, 101, 116, 1, 2, 4, 1, 33, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 99, 108, 105, 112, 98, 111, 97, 114, 100, 5, 1, 1, 66, 2, 1, 64, 1, 10, 102, 117, 108, 108, 115, 99, 114, 101, 101, 110, 127, 1, 0, 4, 0, 14, 115, 101, 116, 45, 102, 117, 108, 108, 115, 99, 114, 101, 101, 110, 1, 0, 4, 1, 30, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 119, 105, 110, 100, 111, 119, 5, 2, 1, 66, 2, 1, 64, 0, 1, 0, 4, 0, 10, 98, 117, 105, 108, 100, 45, 119, 97, 115, 109, 1, 0, 4, 1, 29, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 115, 101, 114, 118, 101, 114, 45, 97, 115, 115, 101, 116, 5, 3, 1, 66, 2, 1, 64, 1, 3, 117, 114, 108, 115, 1, 0, 4, 0, 3, 103, 101, 116, 1, 0, 4, 1, 28, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 115, 101, 114, 118, 101, 114, 45, 104, 116, 116, 112, 5, 4, 1, 66, 32, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 0, 4, 118, 101, 99, 50, 3, 0, 2, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 0, 4, 118, 101, 99, 51, 3, 0, 4, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 0, 4, 118, 101, 99, 52, 3, 0, 6, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 0, 5, 117, 118, 101, 99, 50, 3, 0, 8, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 0, 5, 117, 118, 101, 99, 51, 3, 0, 10, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 0, 5, 117, 118, 101, 99, 52, 3, 0, 12, 1, 114, 2, 1, 120, 122, 1, 121, 122, 4, 0, 5, 105, 118, 101, 99, 50, 3, 0, 14, 1, 114, 3, 1, 120, 122, 1, 121, 122, 1, 122, 122, 4, 0, 5, 105, 118, 101, 99, 51, 3, 0, 16, 1, 114, 4, 1, 120, 122, 1, 121, 122, 1, 122, 122, 1, 119, 122, 4, 0, 5, 105, 118, 101, 99, 52, 3, 0, 18, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 0, 4, 113, 117, 97, 116, 3, 0, 20, 1, 114, 4, 1, 120, 7, 1, 121, 7, 1, 122, 7, 1, 119, 7, 4, 0, 4, 109, 97, 116, 52, 3, 0, 22, 1, 114, 2, 7, 115, 101, 99, 111, 110, 100, 115, 119, 11, 110, 97, 110, 111, 115, 101, 99, 111, 110, 100, 115, 121, 4, 0, 8, 100, 117, 114, 97, 116, 105, 111, 110, 3, 0, 24, 1, 114, 2, 6, 111, 114, 105, 103, 105, 110, 5, 3, 100, 105, 114, 5, 4, 0, 3, 114, 97, 121, 3, 0, 26, 1, 114, 1, 5, 100, 117, 109, 109, 121, 125, 4, 0, 5, 101, 109, 112, 116, 121, 3, 0, 28, 1, 111, 2, 119, 119, 4, 0, 4, 117, 108, 105, 100, 3, 0, 30, 4, 1, 22, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 116, 121, 112, 101, 115, 5, 5, 2, 3, 0, 5, 4, 118, 101, 99, 51, 2, 3, 0, 5, 4, 118, 101, 99, 50, 2, 3, 0, 5, 3, 114, 97, 121, 2, 3, 0, 5, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 66, 16, 2, 3, 2, 1, 6, 4, 0, 4, 118, 101, 99, 51, 3, 0, 0, 2, 3, 2, 1, 7, 4, 0, 4, 118, 101, 99, 50, 3, 0, 2, 2, 3, 2, 1, 8, 4, 0, 3, 114, 97, 121, 3, 0, 4, 2, 3, 2, 1, 9, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 6, 1, 64, 2, 6, 99, 97, 109, 101, 114, 97, 7, 14, 99, 108, 105, 112, 45, 115, 112, 97, 99, 101, 45, 112, 111, 115, 3, 0, 5, 4, 0, 26, 99, 108, 105, 112, 45, 112, 111, 115, 105, 116, 105, 111, 110, 45, 116, 111, 45, 119, 111, 114, 108, 100, 45, 114, 97, 121, 1, 8, 1, 64, 1, 10, 115, 99, 114, 101, 101, 110, 45, 112, 111, 115, 3, 0, 3, 4, 0, 20, 115, 99, 114, 101, 101, 110, 45, 116, 111, 45, 99, 108, 105, 112, 45, 115, 112, 97, 99, 101, 1, 9, 1, 64, 2, 6, 99, 97, 109, 101, 114, 97, 7, 10, 115, 99, 114, 101, 101, 110, 45, 112, 111, 115, 3, 0, 5, 4, 0, 28, 115, 99, 114, 101, 101, 110, 45, 112, 111, 115, 105, 116, 105, 111, 110, 45, 116, 111, 45, 119, 111, 114, 108, 100, 45, 114, 97, 121, 1, 10, 1, 64, 2, 6, 99, 97, 109, 101, 114, 97, 7, 10, 115, 99, 114, 101, 101, 110, 45, 112, 111, 115, 1, 0, 3, 4, 0, 15, 119, 111, 114, 108, 100, 45, 116, 111, 45, 115, 99, 114, 101, 101, 110, 1, 11, 4, 1, 30, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 99, 97, 109, 101, 114, 97, 5, 10, 1, 66, 23, 2, 3, 2, 1, 7, 4, 0, 4, 118, 101, 99, 50, 3, 0, 0, 2, 3, 2, 1, 9, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 2, 1, 109, 163, 1, 4, 107, 101, 121, 49, 4, 107, 101, 121, 50, 4, 107, 101, 121, 51, 4, 107, 101, 121, 52, 4, 107, 101, 121, 53, 4, 107, 101, 121, 54, 4, 107, 101, 121, 55, 4, 107, 101, 121, 56, 4, 107, 101, 121, 57, 4, 107, 101, 121, 48, 1, 97, 1, 98, 1, 99, 1, 100, 1, 101, 1, 102, 1, 103, 1, 104, 1, 105, 1, 106, 1, 107, 1, 108, 1, 109, 1, 110, 1, 111, 1, 112, 1, 113, 1, 114, 1, 115, 1, 116, 1, 117, 1, 118, 1, 119, 1, 120, 1, 121, 1, 122, 6, 101, 115, 99, 97, 112, 101, 2, 102, 49, 2, 102, 50, 2, 102, 51, 2, 102, 52, 2, 102, 53, 2, 102, 54, 2, 102, 55, 2, 102, 56, 2, 102, 57, 3, 102, 49, 48, 3, 102, 49, 49, 3, 102, 49, 50, 3, 102, 49, 51, 3, 102, 49, 52, 3, 102, 49, 53, 3, 102, 49, 54, 3, 102, 49, 55, 3, 102, 49, 56, 3, 102, 49, 57, 3, 102, 50, 48, 3, 102, 50, 49, 3, 102, 50, 50, 3, 102, 50, 51, 3, 102, 50, 52, 8, 115, 110, 97, 112, 115, 104, 111, 116, 6, 115, 99, 114, 111, 108, 108, 5, 112, 97, 117, 115, 101, 6, 105, 110, 115, 101, 114, 116, 4, 104, 111, 109, 101, 6, 100, 101, 108, 101, 116, 101, 3, 101, 110, 100, 9, 112, 97, 103, 101, 45, 100, 111, 119, 110, 7, 112, 97, 103, 101, 45, 117, 112, 4, 108, 101, 102, 116, 2, 117, 112, 5, 114, 105, 103, 104, 116, 4, 100, 111, 119, 110, 4, 98, 97, 99, 107, 6, 114, 101, 116, 117, 114, 110, 5, 115, 112, 97, 99, 101, 7, 99, 111, 109, 112, 111, 115, 101, 5, 99, 97, 114, 101, 116, 7, 110, 117, 109, 108, 111, 99, 107, 7, 110, 117, 109, 112, 97, 100, 48, 7, 110, 117, 109, 112, 97, 100, 49, 7, 110, 117, 109, 112, 97, 100, 50, 7, 110, 117, 109, 112, 97, 100, 51, 7, 110, 117, 109, 112, 97, 100, 52, 7, 110, 117, 109, 112, 97, 100, 53, 7, 110, 117, 109, 112, 97, 100, 54, 7, 110, 117, 109, 112, 97, 100, 55, 7, 110, 117, 109, 112, 97, 100, 56, 7, 110, 117, 109, 112, 97, 100, 57, 10, 110, 117, 109, 112, 97, 100, 45, 97, 100, 100, 13, 110, 117, 109, 112, 97, 100, 45, 100, 105, 118, 105, 100, 101, 14, 110, 117, 109, 112, 97, 100, 45, 100, 101, 99, 105, 109, 97, 108, 12, 110, 117, 109, 112, 97, 100, 45, 99, 111, 109, 109, 97, 12, 110, 117, 109, 112, 97, 100, 45, 101, 110, 116, 101, 114, 13, 110, 117, 109, 112, 97, 100, 45, 101, 113, 117, 97, 108, 115, 15, 110, 117, 109, 112, 97, 100, 45, 109, 117, 108, 116, 105, 112, 108, 121, 15, 110, 117, 109, 112, 97, 100, 45, 115, 117, 98, 116, 114, 97, 99, 116, 7, 97, 98, 110, 116, 45, 99, 49, 7, 97, 98, 110, 116, 45, 99, 50, 10, 97, 112, 111, 115, 116, 114, 111, 112, 104, 101, 4, 97, 112, 112, 115, 8, 97, 115, 116, 101, 114, 105, 115, 107, 2, 97, 116, 2, 97, 120, 9, 98, 97, 99, 107, 115, 108, 97, 115, 104, 10, 99, 97, 108, 99, 117, 108, 97, 116, 111, 114, 7, 99, 97, 112, 105, 116, 97, 108, 5, 99, 111, 108, 111, 110, 5, 99, 111, 109, 109, 97, 7, 99, 111, 110, 118, 101, 114, 116, 6, 101, 113, 117, 97, 108, 115, 5, 103, 114, 97, 118, 101, 4, 107, 97, 110, 97, 5, 107, 97, 110, 106, 105, 5, 108, 45, 97, 108, 116, 9, 108, 45, 98, 114, 97, 99, 107, 101, 116, 9, 108, 45, 99, 111, 110, 116, 114, 111, 108, 7, 108, 45, 115, 104, 105, 102, 116, 5, 108, 45, 119, 105, 110, 4, 109, 97, 105, 108, 12, 109, 101, 100, 105, 97, 45, 115, 101, 108, 101, 99, 116, 10, 109, 101, 100, 105, 97, 45, 115, 116, 111, 112, 5, 109, 105, 110, 117, 115, 4, 109, 117, 116, 101, 11, 109, 121, 45, 99, 111, 109, 112, 117, 116, 101, 114, 16, 110, 97, 118, 105, 103, 97, 116, 101, 45, 102, 111, 114, 119, 97, 114, 100, 17, 110, 97, 118, 105, 103, 97, 116, 101, 45, 98, 97, 99, 107, 119, 97, 114, 100, 10, 110, 101, 120, 116, 45, 116, 114, 97, 99, 107, 10, 110, 111, 45, 99, 111, 110, 118, 101, 114, 116, 6, 111, 101, 109, 49, 48, 50, 6, 112, 101, 114, 105, 111, 100, 10, 112, 108, 97, 121, 45, 112, 97, 117, 115, 101, 4, 112, 108, 117, 115, 5, 112, 111, 119, 101, 114, 10, 112, 114, 101, 118, 45, 116, 114, 97, 99, 107, 5, 114, 45, 97, 108, 116, 9, 114, 45, 98, 114, 97, 99, 107, 101, 116, 9, 114, 45, 99, 111, 110, 116, 114, 111, 108, 7, 114, 45, 115, 104, 105, 102, 116, 5, 114, 45, 119, 105, 110, 9, 115, 101, 109, 105, 99, 111, 108, 111, 110, 5, 115, 108, 97, 115, 104, 5, 115, 108, 101, 101, 112, 4, 115, 116, 111, 112, 5, 115, 121, 115, 114, 113, 3, 116, 97, 98, 9, 117, 110, 100, 101, 114, 108, 105, 110, 101, 9, 117, 110, 108, 97, 98, 101, 108, 101, 100, 11, 118, 111, 108, 117, 109, 101, 45, 100, 111, 119, 110, 9, 118, 111, 108, 117, 109, 101, 45, 117, 112, 4, 119, 97, 107, 101, 8, 119, 101, 98, 45, 98, 97, 99, 107, 13, 119, 101, 98, 45, 102, 97, 118, 111, 114, 105, 116, 101, 115, 11, 119, 101, 98, 45, 102, 111, 114, 119, 97, 114, 100, 8, 119, 101, 98, 45, 104, 111, 109, 101, 11, 119, 101, 98, 45, 114, 101, 102, 114, 101, 115, 104, 10, 119, 101, 98, 45, 115, 101, 97, 114, 99, 104, 8, 119, 101, 98, 45, 115, 116, 111, 112, 3, 121, 101, 110, 4, 99, 111, 112, 121, 5, 112, 97, 115, 116, 101, 3, 99, 117, 116, 4, 0, 16, 118, 105, 114, 116, 117, 97, 108, 45, 107, 101, 121, 45, 99, 111, 100, 101, 3, 0, 4, 1, 113, 4, 4, 108, 101, 102, 116, 0, 0, 5, 114, 105, 103, 104, 116, 0, 0, 6, 109, 105, 100, 100, 108, 101, 0, 0, 5, 111, 116, 104, 101, 114, 1, 123, 0, 4, 0, 12, 109, 111, 117, 115, 101, 45, 98, 117, 116, 116, 111, 110, 3, 0, 6, 1, 112, 5, 1, 112, 7, 1, 114, 5, 4, 107, 101, 121, 115, 8, 14, 109, 111, 117, 115, 101, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 11, 109, 111, 117, 115, 101, 45, 100, 101, 108, 116, 97, 1, 11, 109, 111, 117, 115, 101, 45, 119, 104, 101, 101, 108, 118, 13, 109, 111, 117, 115, 101, 45, 98, 117, 116, 116, 111, 110, 115, 9, 4, 0, 5, 105, 110, 112, 117, 116, 3, 0, 10, 1, 113, 35, 12, 100, 101, 102, 97, 117, 108, 116, 45, 105, 99, 111, 110, 0, 0, 9, 99, 114, 111, 115, 115, 104, 97, 105, 114, 0, 0, 4, 104, 97, 110, 100, 0, 0, 5, 97, 114, 114, 111, 119, 0, 0, 4, 109, 111, 118, 101, 0, 0, 4, 116, 101, 120, 116, 0, 0, 4, 119, 97, 105, 116, 0, 0, 4, 104, 101, 108, 112, 0, 0, 8, 112, 114, 111, 103, 114, 101, 115, 115, 0, 0, 11, 110, 111, 116, 45, 97, 108, 108, 111, 119, 101, 100, 0, 0, 12, 99, 111, 110, 116, 101, 120, 116, 45, 109, 101, 110, 117, 0, 0, 4, 99, 101, 108, 108, 0, 0, 13, 118, 101, 114, 116, 105, 99, 97, 108, 45, 116, 101, 120, 116, 0, 0, 5, 97, 108, 105, 97, 115, 0, 0, 4, 99, 111, 112, 121, 0, 0, 7, 110, 111, 45, 100, 114, 111, 112, 0, 0, 4, 103, 114, 97, 98, 0, 0, 8, 103, 114, 97, 98, 98, 105, 110, 103, 0, 0, 10, 97, 108, 108, 45, 115, 99, 114, 111, 108, 108, 0, 0, 7, 122, 111, 111, 109, 45, 105, 110, 0, 0, 8, 122, 111, 111, 109, 45, 111, 117, 116, 0, 0, 8, 101, 45, 114, 101, 115, 105, 122, 101, 0, 0, 8, 110, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 110, 101, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 110, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 8, 115, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 115, 101, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 115, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 8, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 101, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 110, 115, 45, 114, 101, 115, 105, 122, 101, 0, 0, 11, 110, 101, 115, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 11, 110, 119, 115, 101, 45, 114, 101, 115, 105, 122, 101, 0, 0, 10, 99, 111, 108, 45, 114, 101, 115, 105, 122, 101, 0, 0, 10, 114, 111, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 4, 0, 11, 99, 117, 114, 115, 111, 114, 45, 105, 99, 111, 110, 3, 0, 12, 1, 64, 0, 0, 11, 4, 0, 3, 103, 101, 116, 1, 14, 4, 0, 12, 103, 101, 116, 45, 112, 114, 101, 118, 105, 111, 117, 115, 1, 14, 1, 64, 1, 4, 105, 99, 111, 110, 13, 1, 0, 4, 0, 10, 115, 101, 116, 45, 99, 117, 114, 115, 111, 114, 1, 15, 1, 64, 1, 7, 118, 105, 115, 105, 98, 108, 101, 127, 1, 0, 4, 0, 18, 115, 101, 116, 45, 99, 117, 114, 115, 111, 114, 45, 118, 105, 115, 105, 98, 108, 101, 1, 16, 1, 64, 1, 6, 108, 111, 99, 107, 101, 100, 127, 1, 0, 4, 0, 15, 115, 101, 116, 45, 99, 117, 114, 115, 111, 114, 45, 108, 111, 99, 107, 1, 17, 4, 1, 29, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 105, 110, 112, 117, 116, 5, 11, 2, 3, 0, 5, 4, 117, 108, 105, 100, 1, 66, 18, 2, 3, 2, 1, 7, 4, 0, 4, 118, 101, 99, 50, 3, 0, 0, 2, 3, 2, 1, 6, 4, 0, 4, 118, 101, 99, 51, 3, 0, 2, 2, 3, 2, 1, 12, 4, 0, 4, 117, 108, 105, 100, 3, 0, 4, 1, 114, 4, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 6, 110, 111, 114, 109, 97, 108, 3, 7, 116, 97, 110, 103, 101, 110, 116, 3, 9, 116, 101, 120, 99, 111, 111, 114, 100, 48, 1, 4, 0, 6, 118, 101, 114, 116, 101, 120, 3, 0, 6, 1, 112, 7, 1, 112, 121, 1, 114, 2, 8, 118, 101, 114, 116, 105, 99, 101, 115, 8, 7, 105, 110, 100, 105, 99, 101, 115, 9, 4, 0, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 3, 0, 10, 1, 114, 1, 4, 117, 108, 105, 100, 5, 4, 0, 6, 104, 97, 110, 100, 108, 101, 3, 0, 12, 1, 64, 1, 4, 100, 101, 115, 99, 11, 0, 13, 4, 0, 6, 99, 114, 101, 97, 116, 101, 1, 14, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 13, 1, 0, 4, 0, 7, 100, 101, 115, 116, 114, 111, 121, 1, 15, 4, 1, 28, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 104, 5, 13, 1, 66, 7, 2, 3, 2, 1, 9, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 1, 113, 4, 17, 115, 101, 114, 118, 101, 114, 45, 117, 110, 114, 101, 108, 105, 97, 98, 108, 101, 0, 0, 15, 115, 101, 114, 118, 101, 114, 45, 114, 101, 108, 105, 97, 98, 108, 101, 0, 0, 15, 108, 111, 99, 97, 108, 45, 98, 114, 111, 97, 100, 99, 97, 115, 116, 1, 127, 0, 5, 108, 111, 99, 97, 108, 1, 1, 0, 4, 0, 6, 116, 97, 114, 103, 101, 116, 3, 0, 2, 1, 112, 125, 1, 64, 3, 9, 116, 97, 114, 103, 101, 116, 45, 105, 100, 3, 4, 110, 97, 109, 101, 115, 4, 100, 97, 116, 97, 4, 1, 0, 4, 0, 4, 115, 101, 110, 100, 1, 5, 4, 1, 31, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 115, 97, 103, 101, 5, 14, 1, 66, 4, 2, 3, 2, 1, 9, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 1, 64, 0, 0, 1, 4, 0, 9, 103, 101, 116, 45, 108, 111, 99, 97, 108, 1, 2, 4, 1, 30, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 112, 108, 97, 121, 101, 114, 5, 15, 1, 66, 14, 2, 3, 2, 1, 12, 4, 0, 4, 117, 108, 105, 100, 3, 0, 0, 1, 113, 3, 13, 99, 108, 97, 109, 112, 45, 116, 111, 45, 101, 100, 103, 101, 0, 0, 6, 114, 101, 112, 101, 97, 116, 0, 0, 13, 109, 105, 114, 114, 111, 114, 45, 114, 101, 112, 101, 97, 116, 0, 0, 4, 0, 12, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 3, 0, 2, 1, 113, 2, 7, 110, 101, 97, 114, 101, 115, 116, 0, 0, 6, 108, 105, 110, 101, 97, 114, 0, 0, 4, 0, 11, 102, 105, 108, 116, 101, 114, 45, 109, 111, 100, 101, 3, 0, 4, 1, 114, 6, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 117, 3, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 118, 3, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 119, 3, 10, 109, 97, 103, 45, 102, 105, 108, 116, 101, 114, 5, 10, 109, 105, 110, 45, 102, 105, 108, 116, 101, 114, 5, 13, 109, 105, 112, 109, 97, 112, 45, 102, 105, 108, 116, 101, 114, 5, 4, 0, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 3, 0, 6, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 0, 6, 104, 97, 110, 100, 108, 101, 3, 0, 8, 1, 64, 1, 4, 100, 101, 115, 99, 7, 0, 9, 4, 0, 6, 99, 114, 101, 97, 116, 101, 1, 10, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 9, 1, 0, 4, 0, 7, 100, 101, 115, 116, 114, 111, 121, 1, 11, 4, 1, 31, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 5, 16, 1, 66, 13, 2, 3, 2, 1, 12, 4, 0, 4, 117, 108, 105, 100, 3, 0, 0, 1, 113, 42, 8, 114, 56, 45, 117, 110, 111, 114, 109, 0, 0, 8, 114, 56, 45, 115, 110, 111, 114, 109, 0, 0, 7, 114, 56, 45, 117, 105, 110, 116, 0, 0, 7, 114, 56, 45, 115, 105, 110, 116, 0, 0, 8, 114, 49, 54, 45, 117, 105, 110, 116, 0, 0, 8, 114, 49, 54, 45, 115, 105, 110, 116, 0, 0, 9, 114, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 9, 114, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 9, 114, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 56, 45, 117, 110, 111, 114, 109, 0, 0, 9, 114, 103, 56, 45, 115, 110, 111, 114, 109, 0, 0, 8, 114, 103, 56, 45, 117, 105, 110, 116, 0, 0, 8, 114, 103, 56, 45, 115, 105, 110, 116, 0, 0, 8, 114, 51, 50, 45, 117, 105, 110, 116, 0, 0, 8, 114, 51, 50, 45, 115, 105, 110, 116, 0, 0, 9, 114, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 49, 54, 45, 117, 105, 110, 116, 0, 0, 9, 114, 103, 49, 54, 45, 115, 105, 110, 116, 0, 0, 10, 114, 103, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 10, 114, 103, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 10, 114, 103, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 56, 45, 117, 110, 111, 114, 109, 0, 0, 16, 114, 103, 98, 97, 56, 45, 117, 110, 111, 114, 109, 45, 115, 114, 103, 98, 0, 0, 11, 114, 103, 98, 97, 56, 45, 115, 110, 111, 114, 109, 0, 0, 10, 114, 103, 98, 97, 56, 45, 117, 105, 110, 116, 0, 0, 10, 114, 103, 98, 97, 56, 45, 115, 105, 110, 116, 0, 0, 11, 98, 103, 114, 97, 56, 45, 117, 110, 111, 114, 109, 0, 0, 16, 98, 103, 114, 97, 56, 45, 117, 110, 111, 114, 109, 45, 115, 114, 103, 98, 0, 0, 13, 114, 103, 98, 57, 101, 53, 45, 117, 102, 108, 111, 97, 116, 0, 0, 13, 114, 103, 98, 49, 48, 97, 50, 45, 117, 110, 111, 114, 109, 0, 0, 13, 114, 103, 49, 49, 98, 49, 48, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 51, 50, 45, 117, 105, 110, 116, 0, 0, 9, 114, 103, 51, 50, 45, 115, 105, 110, 116, 0, 0, 10, 114, 103, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 49, 54, 45, 117, 105, 110, 116, 0, 0, 11, 114, 103, 98, 97, 49, 54, 45, 115, 105, 110, 116, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 51, 50, 45, 117, 105, 110, 116, 0, 0, 11, 114, 103, 98, 97, 51, 50, 45, 115, 105, 110, 116, 0, 0, 12, 114, 103, 98, 97, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 4, 0, 6, 102, 111, 114, 109, 97, 116, 3, 0, 2, 1, 112, 125, 1, 114, 4, 5, 119, 105, 100, 116, 104, 121, 6, 104, 101, 105, 103, 104, 116, 121, 6, 102, 111, 114, 109, 97, 116, 3, 4, 100, 97, 116, 97, 4, 4, 0, 12, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 50, 100, 3, 0, 5, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 0, 6, 104, 97, 110, 100, 108, 101, 3, 0, 7, 1, 64, 1, 4, 100, 101, 115, 99, 6, 0, 8, 4, 0, 8, 99, 114, 101, 97, 116, 101, 50, 100, 1, 9, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 8, 1, 0, 4, 0, 7, 100, 101, 115, 116, 114, 111, 121, 1, 10, 4, 1, 31, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 5, 17, 2, 3, 0, 12, 6, 104, 97, 110, 100, 108, 101, 2, 3, 0, 11, 6, 104, 97, 110, 100, 108, 101, 1, 66, 14, 2, 3, 2, 1, 12, 4, 0, 4, 117, 108, 105, 100, 3, 0, 0, 2, 3, 2, 1, 18, 4, 0, 14, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 3, 0, 2, 2, 3, 2, 1, 19, 4, 0, 14, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 3, 0, 4, 1, 114, 5, 14, 98, 97, 115, 101, 45, 99, 111, 108, 111, 114, 45, 109, 97, 112, 3, 10, 110, 111, 114, 109, 97, 108, 45, 109, 97, 112, 3, 22, 109, 101, 116, 97, 108, 108, 105, 99, 45, 114, 111, 117, 103, 104, 110, 101, 115, 115, 45, 109, 97, 112, 3, 7, 115, 97, 109, 112, 108, 101, 114, 5, 11, 116, 114, 97, 110, 115, 112, 97, 114, 101, 110, 116, 127, 4, 0, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 3, 0, 6, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 0, 6, 104, 97, 110, 100, 108, 101, 3, 0, 8, 1, 64, 1, 4, 100, 101, 115, 99, 7, 0, 9, 4, 0, 6, 99, 114, 101, 97, 116, 101, 1, 10, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 9, 1, 0, 4, 0, 7, 100, 101, 115, 116, 114, 111, 121, 1, 11, 4, 1, 32, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 109, 97, 116, 101, 114, 105, 97, 108, 5, 20, 2, 3, 0, 5, 4, 109, 97, 116, 52, 2, 3, 0, 5, 4, 113, 117, 97, 116, 2, 3, 0, 5, 4, 118, 101, 99, 52, 2, 3, 0, 5, 5, 117, 118, 101, 99, 50, 2, 3, 0, 5, 5, 117, 118, 101, 99, 51, 2, 3, 0, 5, 5, 117, 118, 101, 99, 52, 2, 3, 0, 5, 5, 105, 118, 101, 99, 50, 2, 3, 0, 5, 5, 105, 118, 101, 99, 51, 2, 3, 0, 5, 5, 105, 118, 101, 99, 52, 2, 3, 0, 5, 8, 100, 117, 114, 97, 116, 105, 111, 110, 2, 3, 0, 5, 5, 101, 109, 112, 116, 121, 2, 3, 0, 8, 6, 104, 97, 110, 100, 108, 101, 2, 3, 0, 13, 6, 104, 97, 110, 100, 108, 101, 1, 66, 141, 1, 2, 3, 2, 1, 9, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 2, 3, 2, 1, 21, 4, 0, 4, 109, 97, 116, 52, 3, 0, 2, 2, 3, 2, 1, 22, 4, 0, 4, 113, 117, 97, 116, 3, 0, 4, 2, 3, 2, 1, 7, 4, 0, 4, 118, 101, 99, 50, 3, 0, 6, 2, 3, 2, 1, 6, 4, 0, 4, 118, 101, 99, 51, 3, 0, 8, 2, 3, 2, 1, 23, 4, 0, 4, 118, 101, 99, 52, 3, 0, 10, 2, 3, 2, 1, 24, 4, 0, 5, 117, 118, 101, 99, 50, 3, 0, 12, 2, 3, 2, 1, 25, 4, 0, 5, 117, 118, 101, 99, 51, 3, 0, 14, 2, 3, 2, 1, 26, 4, 0, 5, 117, 118, 101, 99, 52, 3, 0, 16, 2, 3, 2, 1, 27, 4, 0, 5, 105, 118, 101, 99, 50, 3, 0, 18, 2, 3, 2, 1, 28, 4, 0, 5, 105, 118, 101, 99, 51, 3, 0, 20, 2, 3, 2, 1, 29, 4, 0, 5, 105, 118, 101, 99, 52, 3, 0, 22, 2, 3, 2, 1, 30, 4, 0, 8, 100, 117, 114, 97, 116, 105, 111, 110, 3, 0, 24, 2, 3, 2, 1, 31, 4, 0, 5, 101, 109, 112, 116, 121, 3, 0, 26, 2, 3, 2, 1, 32, 4, 0, 22, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 3, 0, 28, 2, 3, 2, 1, 18, 4, 0, 25, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 3, 0, 30, 2, 3, 2, 1, 19, 4, 0, 25, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 3, 0, 32, 2, 3, 2, 1, 33, 4, 0, 26, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 3, 0, 34, 1, 112, 27, 1, 112, 127, 1, 112, 1, 1, 112, 118, 1, 112, 117, 1, 112, 3, 1, 112, 5, 1, 112, 115, 1, 112, 125, 1, 112, 123, 1, 112, 121, 1, 112, 119, 1, 112, 126, 1, 112, 124, 1, 112, 122, 1, 112, 120, 1, 112, 7, 1, 112, 9, 1, 112, 11, 1, 112, 13, 1, 112, 15, 1, 112, 17, 1, 112, 19, 1, 112, 21, 1, 112, 23, 1, 112, 25, 1, 112, 29, 1, 112, 31, 1, 112, 33, 1, 112, 35, 1, 113, 30, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 36, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 37, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 38, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 39, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 40, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 41, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 42, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 43, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 44, 0, 8, 116, 121, 112, 101, 45, 117, 49, 54, 1, 45, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 46, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 47, 0, 7, 116, 121, 112, 101, 45, 105, 56, 1, 48, 0, 8, 116, 121, 112, 101, 45, 105, 49, 54, 1, 49, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 50, 0, 8, 116, 121, 112, 101, 45, 105, 54, 52, 1, 51, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 52, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 53, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 54, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 55, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 56, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 57, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 50, 1, 58, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 51, 1, 59, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 52, 1, 60, 0, 13, 116, 121, 112, 101, 45, 100, 117, 114, 97, 116, 105, 111, 110, 1, 61, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 62, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 63, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 192, 0, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 193, 0, 0, 4, 0, 9, 118, 101, 99, 45, 118, 97, 108, 117, 101, 3, 0, 66, 1, 107, 27, 1, 107, 127, 1, 107, 1, 1, 107, 118, 1, 107, 117, 1, 107, 3, 1, 107, 5, 1, 107, 115, 1, 107, 125, 1, 107, 123, 1, 107, 121, 1, 107, 119, 1, 107, 126, 1, 107, 124, 1, 107, 122, 1, 107, 120, 1, 107, 7, 1, 107, 9, 1, 107, 11, 1, 107, 13, 1, 107, 15, 1, 107, 17, 1, 107, 19, 1, 107, 21, 1, 107, 23, 1, 107, 25, 1, 107, 29, 1, 107, 31, 1, 107, 33, 1, 107, 35, 1, 113, 30, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 196, 0, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 197, 0, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 198, 0, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 199, 0, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 200, 0, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 201, 0, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 202, 0, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 203, 0, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 204, 0, 0, 8, 116, 121, 112, 101, 45, 117, 49, 54, 1, 205, 0, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 206, 0, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 207, 0, 0, 7, 116, 121, 112, 101, 45, 105, 56, 1, 208, 0, 0, 8, 116, 121, 112, 101, 45, 105, 49, 54, 1, 209, 0, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 210, 0, 0, 8, 116, 121, 112, 101, 45, 105, 54, 52, 1, 211, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 212, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 213, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 214, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 215, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 216, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 217, 0, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 50, 1, 218, 0, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 51, 1, 219, 0, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 52, 1, 220, 0, 0, 13, 116, 121, 112, 101, 45, 100, 117, 114, 97, 116, 105, 111, 110, 1, 221, 0, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 222, 0, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 223, 0, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 224, 0, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 225, 0, 0, 4, 0, 12, 111, 112, 116, 105, 111, 110, 45, 118, 97, 108, 117, 101, 3, 0, 98, 1, 113, 32, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 27, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 127, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 1, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 118, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 117, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 3, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 5, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 115, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 125, 0, 8, 116, 121, 112, 101, 45, 117, 49, 54, 1, 123, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 121, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 119, 0, 7, 116, 121, 112, 101, 45, 105, 56, 1, 126, 0, 8, 116, 121, 112, 101, 45, 105, 49, 54, 1, 124, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 122, 0, 8, 116, 121, 112, 101, 45, 105, 54, 52, 1, 120, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 7, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 9, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 11, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 13, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 15, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 17, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 50, 1, 19, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 51, 1, 21, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 52, 1, 23, 0, 13, 116, 121, 112, 101, 45, 100, 117, 114, 97, 116, 105, 111, 110, 1, 25, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 29, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 31, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 33, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 35, 0, 8, 116, 121, 112, 101, 45, 118, 101, 99, 1, 195, 0, 0, 11, 116, 121, 112, 101, 45, 111, 112, 116, 105, 111, 110, 1, 227, 0, 0, 4, 0, 5, 118, 97, 108, 117, 101, 3, 0, 100, 1, 111, 2, 121, 229, 0, 1, 112, 230, 0, 4, 0, 6, 101, 110, 116, 105, 116, 121, 3, 0, 103, 1, 114, 4, 10, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 46, 8, 105, 110, 99, 108, 117, 100, 101, 115, 46, 8, 101, 120, 99, 108, 117, 100, 101, 115, 46, 7, 99, 104, 97, 110, 103, 101, 100, 46, 4, 0, 11, 113, 117, 101, 114, 121, 45, 98, 117, 105, 108, 100, 3, 0, 105, 1, 109, 3, 5, 102, 114, 97, 109, 101, 5, 115, 112, 97, 119, 110, 7, 100, 101, 115, 112, 97, 119, 110, 4, 0, 11, 113, 117, 101, 114, 121, 45, 101, 118, 101, 110, 116, 3, 0, 107, 1, 64, 1, 2, 105, 100, 115, 0, 206, 0, 4, 0, 9, 103, 101, 116, 45, 105, 110, 100, 101, 120, 1, 109, 1, 64, 1, 5, 105, 110, 100, 101, 120, 121, 0, 203, 0, 4, 0, 6, 103, 101, 116, 45, 105, 100, 1, 110, 1, 107, 229, 0, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 0, 239, 0, 4, 0, 13, 103, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 1, 112, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 110, 100, 105, 99, 101, 115, 46, 0, 232, 0, 4, 0, 14, 103, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 113, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 0, 232, 0, 4, 0, 18, 103, 101, 116, 45, 97, 108, 108, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 114, 1, 64, 3, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 5, 118, 97, 108, 117, 101, 229, 0, 1, 0, 4, 0, 13, 97, 100, 100, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 1, 115, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 4, 100, 97, 116, 97, 232, 0, 1, 0, 4, 0, 14, 97, 100, 100, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 116, 4, 0, 13, 115, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 1, 115, 4, 0, 14, 115, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 116, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 0, 127, 4, 0, 13, 104, 97, 115, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 1, 117, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 110, 100, 105, 99, 101, 115, 46, 0, 127, 4, 0, 14, 104, 97, 115, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 118, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 1, 0, 4, 0, 16, 114, 101, 109, 111, 118, 101, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 1, 119, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 110, 100, 105, 99, 101, 115, 46, 1, 0, 4, 0, 17, 114, 101, 109, 111, 118, 101, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 120, 1, 64, 2, 1, 113, 234, 0, 1, 116, 236, 0, 0, 119, 4, 0, 5, 113, 117, 101, 114, 121, 1, 121, 1, 112, 229, 0, 1, 111, 2, 1, 250, 0, 1, 112, 251, 0, 1, 64, 1, 1, 113, 119, 0, 252, 0, 4, 0, 10, 113, 117, 101, 114, 121, 45, 101, 118, 97, 108, 1, 125, 4, 1, 26, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 5, 34, 2, 3, 0, 14, 6, 101, 110, 116, 105, 116, 121, 1, 66, 29, 2, 3, 2, 1, 9, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 2, 3, 2, 1, 6, 4, 0, 4, 118, 101, 99, 51, 3, 0, 2, 2, 3, 2, 1, 22, 4, 0, 4, 113, 117, 97, 116, 3, 0, 4, 2, 3, 2, 1, 21, 4, 0, 4, 109, 97, 116, 52, 3, 0, 6, 2, 3, 2, 1, 35, 4, 0, 11, 101, 110, 116, 105, 116, 121, 45, 100, 97, 116, 97, 3, 0, 8, 1, 112, 1, 1, 112, 7, 1, 64, 2, 8, 101, 110, 116, 105, 116, 105, 101, 115, 10, 6, 111, 114, 105, 103, 105, 110, 1, 0, 11, 4, 0, 26, 103, 101, 116, 45, 116, 114, 97, 110, 115, 102, 111, 114, 109, 115, 45, 114, 101, 108, 97, 116, 105, 118, 101, 45, 116, 111, 1, 12, 1, 64, 1, 4, 100, 97, 116, 97, 9, 0, 1, 4, 0, 5, 115, 112, 97, 119, 110, 1, 13, 1, 107, 9, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 0, 14, 4, 0, 7, 100, 101, 115, 112, 97, 119, 110, 1, 15, 1, 64, 2, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 6, 114, 97, 100, 105, 117, 115, 118, 0, 10, 4, 0, 7, 105, 110, 45, 97, 114, 101, 97, 1, 16, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 0, 127, 4, 0, 6, 101, 120, 105, 115, 116, 115, 1, 17, 1, 64, 1, 5, 105, 110, 100, 101, 120, 121, 0, 10, 4, 0, 7, 103, 101, 116, 45, 97, 108, 108, 1, 18, 1, 64, 0, 0, 1, 4, 0, 9, 114, 101, 115, 111, 117, 114, 99, 101, 115, 1, 19, 4, 0, 22, 115, 121, 110, 99, 104, 114, 111, 110, 105, 122, 101, 100, 45, 114, 101, 115, 111, 117, 114, 99, 101, 115, 1, 19, 4, 0, 19, 112, 101, 114, 115, 105, 115, 116, 101, 100, 45, 114, 101, 115, 111, 117, 114, 99, 101, 115, 1, 19, 4, 1, 23, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 101, 110, 116, 105, 116, 121, 5, 36, 1, 66, 9, 2, 3, 2, 1, 9, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 1, 113, 4, 7, 114, 117, 110, 116, 105, 109, 101, 0, 0, 5, 108, 111, 99, 97, 108, 1, 1, 0, 6, 115, 101, 114, 118, 101, 114, 0, 0, 6, 99, 108, 105, 101, 110, 116, 1, 115, 0, 4, 0, 6, 115, 111, 117, 114, 99, 101, 3, 0, 2, 1, 64, 0, 1, 0, 4, 0, 4, 105, 110, 105, 116, 1, 4, 1, 112, 125, 1, 64, 3, 14, 109, 101, 115, 115, 97, 103, 101, 45, 115, 111, 117, 114, 99, 101, 3, 12, 109, 101, 115, 115, 97, 103, 101, 45, 110, 97, 109, 101, 115, 12, 109, 101, 115, 115, 97, 103, 101, 45, 100, 97, 116, 97, 5, 1, 0, 4, 0, 4, 101, 120, 101, 99, 1, 6, 4, 1, 22, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 103, 117, 101, 115, 116, 5, 37, 1, 66, 4, 2, 3, 2, 1, 35, 4, 0, 6, 101, 110, 116, 105, 116, 121, 3, 0, 0, 1, 64, 1, 4, 110, 97, 109, 101, 115, 1, 0, 4, 0, 9, 115, 117, 98, 115, 99, 114, 105, 98, 101, 1, 2, 4, 1, 24, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 109, 101, 115, 115, 97, 103, 101, 5, 38, 1, 66, 5, 2, 3, 2, 1, 9, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 1, 107, 1, 1, 64, 1, 7, 117, 115, 101, 114, 45, 105, 100, 115, 0, 2, 4, 0, 14, 103, 101, 116, 45, 98, 121, 45, 117, 115, 101, 114, 45, 105, 100, 1, 3, 4, 1, 23, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 112, 108, 97, 121, 101, 114, 5, 39, 1, 66, 7, 2, 3, 2, 1, 9, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 1, 113, 6, 27, 99, 108, 105, 101, 110, 116, 45, 98, 114, 111, 97, 100, 99, 97, 115, 116, 45, 117, 110, 114, 101, 108, 105, 97, 98, 108, 101, 0, 0, 25, 99, 108, 105, 101, 110, 116, 45, 98, 114, 111, 97, 100, 99, 97, 115, 116, 45, 114, 101, 108, 105, 97, 98, 108, 101, 0, 0, 26, 99, 108, 105, 101, 110, 116, 45, 116, 97, 114, 103, 101, 116, 101, 100, 45, 117, 110, 114, 101, 108, 105, 97, 98, 108, 101, 1, 115, 0, 24, 99, 108, 105, 101, 110, 116, 45, 116, 97, 114, 103, 101, 116, 101, 100, 45, 114, 101, 108, 105, 97, 98, 108, 101, 1, 115, 0, 15, 108, 111, 99, 97, 108, 45, 98, 114, 111, 97, 100, 99, 97, 115, 116, 1, 127, 0, 5, 108, 111, 99, 97, 108, 1, 1, 0, 4, 0, 6, 116, 97, 114, 103, 101, 116, 3, 0, 2, 1, 112, 125, 1, 64, 3, 9, 116, 97, 114, 103, 101, 116, 45, 105, 100, 3, 4, 110, 97, 109, 101, 115, 4, 100, 97, 116, 97, 4, 1, 0, 4, 0, 4, 115, 101, 110, 100, 1, 5, 4, 1, 31, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 115, 101, 114, 118, 101, 114, 45, 109, 101, 115, 115, 97, 103, 101, 5, 40, 1, 66, 43, 2, 3, 2, 1, 9, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 2, 3, 2, 1, 6, 4, 0, 4, 118, 101, 99, 51, 3, 0, 2, 2, 3, 2, 1, 21, 4, 0, 4, 109, 97, 116, 52, 3, 0, 4, 1, 114, 3, 4, 115, 105, 100, 101, 127, 2, 117, 112, 127, 4, 100, 111, 119, 110, 127, 4, 0, 19, 99, 104, 97, 114, 97, 99, 116, 101, 114, 45, 99, 111, 108, 108, 105, 115, 105, 111, 110, 3, 0, 6, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 102, 111, 114, 99, 101, 3, 1, 0, 4, 0, 9, 97, 100, 100, 45, 102, 111, 114, 99, 101, 1, 8, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 109, 112, 117, 108, 115, 101, 3, 1, 0, 4, 0, 11, 97, 100, 100, 45, 105, 109, 112, 117, 108, 115, 101, 1, 9, 1, 107, 118, 1, 64, 4, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 7, 105, 109, 112, 117, 108, 115, 101, 118, 6, 114, 97, 100, 105, 117, 115, 118, 14, 102, 97, 108, 108, 111, 102, 102, 45, 114, 97, 100, 105, 117, 115, 10, 1, 0, 4, 0, 18, 97, 100, 100, 45, 114, 97, 100, 105, 97, 108, 45, 105, 109, 112, 117, 108, 115, 101, 1, 11, 1, 64, 3, 6, 101, 110, 116, 105, 116, 121, 1, 5, 102, 111, 114, 99, 101, 3, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 1, 0, 4, 0, 21, 97, 100, 100, 45, 102, 111, 114, 99, 101, 45, 97, 116, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 12, 1, 64, 3, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 109, 112, 117, 108, 115, 101, 3, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 1, 0, 4, 0, 23, 97, 100, 100, 45, 105, 109, 112, 117, 108, 115, 101, 45, 97, 116, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 13, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 0, 3, 4, 0, 24, 103, 101, 116, 45, 118, 101, 108, 111, 99, 105, 116, 121, 45, 97, 116, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 14, 1, 64, 1, 7, 103, 114, 97, 118, 105, 116, 121, 3, 1, 0, 4, 0, 11, 115, 101, 116, 45, 103, 114, 97, 118, 105, 116, 121, 1, 15, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 1, 0, 4, 0, 8, 117, 110, 102, 114, 101, 101, 122, 101, 1, 16, 4, 0, 6, 102, 114, 101, 101, 122, 101, 1, 16, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 8, 118, 101, 108, 111, 99, 105, 116, 121, 118, 1, 0, 4, 0, 11, 115, 116, 97, 114, 116, 45, 109, 111, 116, 111, 114, 1, 17, 4, 0, 10, 115, 116, 111, 112, 45, 109, 111, 116, 111, 114, 1, 16, 1, 64, 4, 6, 97, 99, 116, 111, 114, 48, 1, 10, 116, 114, 97, 110, 115, 102, 111, 114, 109, 48, 5, 6, 97, 99, 116, 111, 114, 49, 1, 10, 116, 114, 97, 110, 115, 102, 111, 114, 109, 49, 5, 1, 0, 4, 0, 21, 99, 114, 101, 97, 116, 101, 45, 114, 101, 118, 111, 108, 117, 116, 101, 45, 106, 111, 105, 110, 116, 1, 18, 1, 111, 2, 1, 118, 1, 107, 19, 1, 64, 2, 6, 111, 114, 105, 103, 105, 110, 3, 9, 100, 105, 114, 101, 99, 116, 105, 111, 110, 3, 0, 20, 4, 0, 13, 114, 97, 121, 99, 97, 115, 116, 45, 102, 105, 114, 115, 116, 1, 21, 1, 112, 19, 1, 64, 2, 6, 111, 114, 105, 103, 105, 110, 3, 9, 100, 105, 114, 101, 99, 116, 105, 111, 110, 3, 0, 22, 4, 0, 7, 114, 97, 121, 99, 97, 115, 116, 1, 23, 1, 64, 4, 6, 101, 110, 116, 105, 116, 121, 1, 12, 100, 105, 115, 112, 108, 97, 99, 101, 109, 101, 110, 116, 3, 8, 109, 105, 110, 45, 100, 105, 115, 116, 118, 12, 101, 108, 97, 112, 115, 101, 100, 45, 116, 105, 109, 101, 118, 0, 7, 4, 0, 14, 109, 111, 118, 101, 45, 99, 104, 97, 114, 97, 99, 116, 101, 114, 1, 24, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 1, 0, 4, 0, 22, 115, 101, 116, 45, 99, 104, 97, 114, 97, 99, 116, 101, 114, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 25, 4, 0, 27, 115, 101, 116, 45, 99, 104, 97, 114, 97, 99, 116, 101, 114, 45, 102, 111, 111, 116, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 25, 4, 1, 31, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 115, 101, 114, 118, 101, 114, 45, 112, 104, 121, 115, 105, 99, 115, 5, 41, 1, 65, 63, 1, 66, 32, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 0, 4, 118, 101, 99, 50, 3, 0, 2, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 0, 4, 118, 101, 99, 51, 3, 0, 4, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 0, 4, 118, 101, 99, 52, 3, 0, 6, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 0, 5, 117, 118, 101, 99, 50, 3, 0, 8, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 0, 5, 117, 118, 101, 99, 51, 3, 0, 10, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 0, 5, 117, 118, 101, 99, 52, 3, 0, 12, 1, 114, 2, 1, 120, 122, 1, 121, 122, 4, 0, 5, 105, 118, 101, 99, 50, 3, 0, 14, 1, 114, 3, 1, 120, 122, 1, 121, 122, 1, 122, 122, 4, 0, 5, 105, 118, 101, 99, 51, 3, 0, 16, 1, 114, 4, 1, 120, 122, 1, 121, 122, 1, 122, 122, 1, 119, 122, 4, 0, 5, 105, 118, 101, 99, 52, 3, 0, 18, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 0, 4, 113, 117, 97, 116, 3, 0, 20, 1, 114, 4, 1, 120, 7, 1, 121, 7, 1, 122, 7, 1, 119, 7, 4, 0, 4, 109, 97, 116, 52, 3, 0, 22, 1, 114, 2, 7, 115, 101, 99, 111, 110, 100, 115, 119, 11, 110, 97, 110, 111, 115, 101, 99, 111, 110, 100, 115, 121, 4, 0, 8, 100, 117, 114, 97, 116, 105, 111, 110, 3, 0, 24, 1, 114, 2, 6, 111, 114, 105, 103, 105, 110, 5, 3, 100, 105, 114, 5, 4, 0, 3, 114, 97, 121, 3, 0, 26, 1, 114, 1, 5, 100, 117, 109, 109, 121, 125, 4, 0, 5, 101, 109, 112, 116, 121, 3, 0, 28, 1, 111, 2, 119, 119, 4, 0, 4, 117, 108, 105, 100, 3, 0, 30, 3, 1, 22, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 116, 121, 112, 101, 115, 5, 0, 1, 66, 5, 1, 113, 1, 11, 105, 110, 118, 97, 108, 105, 100, 45, 117, 114, 108, 1, 115, 0, 4, 0, 9, 117, 114, 108, 45, 101, 114, 114, 111, 114, 3, 0, 0, 1, 106, 1, 115, 1, 1, 1, 64, 1, 4, 112, 97, 116, 104, 115, 0, 2, 4, 0, 3, 117, 114, 108, 1, 3, 3, 1, 22, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 97, 115, 115, 101, 116, 5, 1, 2, 3, 0, 0, 4, 118, 101, 99, 50, 2, 3, 0, 0, 4, 118, 101, 99, 51, 2, 3, 0, 0, 4, 117, 108, 105, 100, 1, 66, 18, 2, 3, 2, 1, 2, 4, 0, 4, 118, 101, 99, 50, 3, 0, 0, 2, 3, 2, 1, 3, 4, 0, 4, 118, 101, 99, 51, 3, 0, 2, 2, 3, 2, 1, 4, 4, 0, 4, 117, 108, 105, 100, 3, 0, 4, 1, 114, 4, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 6, 110, 111, 114, 109, 97, 108, 3, 7, 116, 97, 110, 103, 101, 110, 116, 3, 9, 116, 101, 120, 99, 111, 111, 114, 100, 48, 1, 4, 0, 6, 118, 101, 114, 116, 101, 120, 3, 0, 6, 1, 112, 7, 1, 112, 121, 1, 114, 2, 8, 118, 101, 114, 116, 105, 99, 101, 115, 8, 7, 105, 110, 100, 105, 99, 101, 115, 9, 4, 0, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 3, 0, 10, 1, 114, 1, 4, 117, 108, 105, 100, 5, 4, 0, 6, 104, 97, 110, 100, 108, 101, 3, 0, 12, 1, 64, 1, 4, 100, 101, 115, 99, 11, 0, 13, 4, 0, 6, 99, 114, 101, 97, 116, 101, 1, 14, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 13, 1, 0, 4, 0, 7, 100, 101, 115, 116, 114, 111, 121, 1, 15, 3, 1, 28, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 104, 5, 5, 1, 66, 13, 2, 3, 2, 1, 4, 4, 0, 4, 117, 108, 105, 100, 3, 0, 0, 1, 113, 42, 8, 114, 56, 45, 117, 110, 111, 114, 109, 0, 0, 8, 114, 56, 45, 115, 110, 111, 114, 109, 0, 0, 7, 114, 56, 45, 117, 105, 110, 116, 0, 0, 7, 114, 56, 45, 115, 105, 110, 116, 0, 0, 8, 114, 49, 54, 45, 117, 105, 110, 116, 0, 0, 8, 114, 49, 54, 45, 115, 105, 110, 116, 0, 0, 9, 114, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 9, 114, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 9, 114, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 56, 45, 117, 110, 111, 114, 109, 0, 0, 9, 114, 103, 56, 45, 115, 110, 111, 114, 109, 0, 0, 8, 114, 103, 56, 45, 117, 105, 110, 116, 0, 0, 8, 114, 103, 56, 45, 115, 105, 110, 116, 0, 0, 8, 114, 51, 50, 45, 117, 105, 110, 116, 0, 0, 8, 114, 51, 50, 45, 115, 105, 110, 116, 0, 0, 9, 114, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 49, 54, 45, 117, 105, 110, 116, 0, 0, 9, 114, 103, 49, 54, 45, 115, 105, 110, 116, 0, 0, 10, 114, 103, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 10, 114, 103, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 10, 114, 103, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 56, 45, 117, 110, 111, 114, 109, 0, 0, 16, 114, 103, 98, 97, 56, 45, 117, 110, 111, 114, 109, 45, 115, 114, 103, 98, 0, 0, 11, 114, 103, 98, 97, 56, 45, 115, 110, 111, 114, 109, 0, 0, 10, 114, 103, 98, 97, 56, 45, 117, 105, 110, 116, 0, 0, 10, 114, 103, 98, 97, 56, 45, 115, 105, 110, 116, 0, 0, 11, 98, 103, 114, 97, 56, 45, 117, 110, 111, 114, 109, 0, 0, 16, 98, 103, 114, 97, 56, 45, 117, 110, 111, 114, 109, 45, 115, 114, 103, 98, 0, 0, 13, 114, 103, 98, 57, 101, 53, 45, 117, 102, 108, 111, 97, 116, 0, 0, 13, 114, 103, 98, 49, 48, 97, 50, 45, 117, 110, 111, 114, 109, 0, 0, 13, 114, 103, 49, 49, 98, 49, 48, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 51, 50, 45, 117, 105, 110, 116, 0, 0, 9, 114, 103, 51, 50, 45, 115, 105, 110, 116, 0, 0, 10, 114, 103, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 49, 54, 45, 117, 105, 110, 116, 0, 0, 11, 114, 103, 98, 97, 49, 54, 45, 115, 105, 110, 116, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 51, 50, 45, 117, 105, 110, 116, 0, 0, 11, 114, 103, 98, 97, 51, 50, 45, 115, 105, 110, 116, 0, 0, 12, 114, 103, 98, 97, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 4, 0, 6, 102, 111, 114, 109, 97, 116, 3, 0, 2, 1, 112, 125, 1, 114, 4, 5, 119, 105, 100, 116, 104, 121, 6, 104, 101, 105, 103, 104, 116, 121, 6, 102, 111, 114, 109, 97, 116, 3, 4, 100, 97, 116, 97, 4, 4, 0, 12, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 50, 100, 3, 0, 5, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 0, 6, 104, 97, 110, 100, 108, 101, 3, 0, 7, 1, 64, 1, 4, 100, 101, 115, 99, 6, 0, 8, 4, 0, 8, 99, 114, 101, 97, 116, 101, 50, 100, 1, 9, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 8, 1, 0, 4, 0, 7, 100, 101, 115, 116, 114, 111, 121, 1, 10, 3, 1, 31, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 5, 6, 1, 66, 14, 2, 3, 2, 1, 4, 4, 0, 4, 117, 108, 105, 100, 3, 0, 0, 1, 113, 3, 13, 99, 108, 97, 109, 112, 45, 116, 111, 45, 101, 100, 103, 101, 0, 0, 6, 114, 101, 112, 101, 97, 116, 0, 0, 13, 109, 105, 114, 114, 111, 114, 45, 114, 101, 112, 101, 97, 116, 0, 0, 4, 0, 12, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 3, 0, 2, 1, 113, 2, 7, 110, 101, 97, 114, 101, 115, 116, 0, 0, 6, 108, 105, 110, 101, 97, 114, 0, 0, 4, 0, 11, 102, 105, 108, 116, 101, 114, 45, 109, 111, 100, 101, 3, 0, 4, 1, 114, 6, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 117, 3, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 118, 3, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 119, 3, 10, 109, 97, 103, 45, 102, 105, 108, 116, 101, 114, 5, 10, 109, 105, 110, 45, 102, 105, 108, 116, 101, 114, 5, 13, 109, 105, 112, 109, 97, 112, 45, 102, 105, 108, 116, 101, 114, 5, 4, 0, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 3, 0, 6, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 0, 6, 104, 97, 110, 100, 108, 101, 3, 0, 8, 1, 64, 1, 4, 100, 101, 115, 99, 7, 0, 9, 4, 0, 6, 99, 114, 101, 97, 116, 101, 1, 10, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 9, 1, 0, 4, 0, 7, 100, 101, 115, 116, 114, 111, 121, 1, 11, 3, 1, 31, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 5, 7, 2, 3, 0, 3, 6, 104, 97, 110, 100, 108, 101, 2, 3, 0, 4, 6, 104, 97, 110, 100, 108, 101, 1, 66, 14, 2, 3, 2, 1, 4, 4, 0, 4, 117, 108, 105, 100, 3, 0, 0, 2, 3, 2, 1, 8, 4, 0, 14, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 3, 0, 2, 2, 3, 2, 1, 9, 4, 0, 14, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 3, 0, 4, 1, 114, 5, 14, 98, 97, 115, 101, 45, 99, 111, 108, 111, 114, 45, 109, 97, 112, 3, 10, 110, 111, 114, 109, 97, 108, 45, 109, 97, 112, 3, 22, 109, 101, 116, 97, 108, 108, 105, 99, 45, 114, 111, 117, 103, 104, 110, 101, 115, 115, 45, 109, 97, 112, 3, 7, 115, 97, 109, 112, 108, 101, 114, 5, 11, 116, 114, 97, 110, 115, 112, 97, 114, 101, 110, 116, 127, 4, 0, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 3, 0, 6, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 0, 6, 104, 97, 110, 100, 108, 101, 3, 0, 8, 1, 64, 1, 4, 100, 101, 115, 99, 7, 0, 9, 4, 0, 6, 99, 114, 101, 97, 116, 101, 1, 10, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 9, 1, 0, 4, 0, 7, 100, 101, 115, 116, 114, 111, 121, 1, 11, 3, 1, 32, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 109, 97, 116, 101, 114, 105, 97, 108, 5, 10, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 2, 3, 0, 0, 4, 109, 97, 116, 52, 2, 3, 0, 0, 4, 113, 117, 97, 116, 2, 3, 0, 0, 4, 118, 101, 99, 52, 2, 3, 0, 0, 5, 117, 118, 101, 99, 50, 2, 3, 0, 0, 5, 117, 118, 101, 99, 51, 2, 3, 0, 0, 5, 117, 118, 101, 99, 52, 2, 3, 0, 0, 5, 105, 118, 101, 99, 50, 2, 3, 0, 0, 5, 105, 118, 101, 99, 51, 2, 3, 0, 0, 5, 105, 118, 101, 99, 52, 2, 3, 0, 0, 8, 100, 117, 114, 97, 116, 105, 111, 110, 2, 3, 0, 0, 5, 101, 109, 112, 116, 121, 2, 3, 0, 2, 6, 104, 97, 110, 100, 108, 101, 2, 3, 0, 5, 6, 104, 97, 110, 100, 108, 101, 1, 66, 141, 1, 2, 3, 2, 1, 11, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 2, 3, 2, 1, 12, 4, 0, 4, 109, 97, 116, 52, 3, 0, 2, 2, 3, 2, 1, 13, 4, 0, 4, 113, 117, 97, 116, 3, 0, 4, 2, 3, 2, 1, 2, 4, 0, 4, 118, 101, 99, 50, 3, 0, 6, 2, 3, 2, 1, 3, 4, 0, 4, 118, 101, 99, 51, 3, 0, 8, 2, 3, 2, 1, 14, 4, 0, 4, 118, 101, 99, 52, 3, 0, 10, 2, 3, 2, 1, 15, 4, 0, 5, 117, 118, 101, 99, 50, 3, 0, 12, 2, 3, 2, 1, 16, 4, 0, 5, 117, 118, 101, 99, 51, 3, 0, 14, 2, 3, 2, 1, 17, 4, 0, 5, 117, 118, 101, 99, 52, 3, 0, 16, 2, 3, 2, 1, 18, 4, 0, 5, 105, 118, 101, 99, 50, 3, 0, 18, 2, 3, 2, 1, 19, 4, 0, 5, 105, 118, 101, 99, 51, 3, 0, 20, 2, 3, 2, 1, 20, 4, 0, 5, 105, 118, 101, 99, 52, 3, 0, 22, 2, 3, 2, 1, 21, 4, 0, 8, 100, 117, 114, 97, 116, 105, 111, 110, 3, 0, 24, 2, 3, 2, 1, 22, 4, 0, 5, 101, 109, 112, 116, 121, 3, 0, 26, 2, 3, 2, 1, 23, 4, 0, 22, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 3, 0, 28, 2, 3, 2, 1, 8, 4, 0, 25, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 3, 0, 30, 2, 3, 2, 1, 9, 4, 0, 25, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 3, 0, 32, 2, 3, 2, 1, 24, 4, 0, 26, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 3, 0, 34, 1, 112, 27, 1, 112, 127, 1, 112, 1, 1, 112, 118, 1, 112, 117, 1, 112, 3, 1, 112, 5, 1, 112, 115, 1, 112, 125, 1, 112, 123, 1, 112, 121, 1, 112, 119, 1, 112, 126, 1, 112, 124, 1, 112, 122, 1, 112, 120, 1, 112, 7, 1, 112, 9, 1, 112, 11, 1, 112, 13, 1, 112, 15, 1, 112, 17, 1, 112, 19, 1, 112, 21, 1, 112, 23, 1, 112, 25, 1, 112, 29, 1, 112, 31, 1, 112, 33, 1, 112, 35, 1, 113, 30, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 36, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 37, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 38, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 39, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 40, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 41, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 42, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 43, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 44, 0, 8, 116, 121, 112, 101, 45, 117, 49, 54, 1, 45, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 46, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 47, 0, 7, 116, 121, 112, 101, 45, 105, 56, 1, 48, 0, 8, 116, 121, 112, 101, 45, 105, 49, 54, 1, 49, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 50, 0, 8, 116, 121, 112, 101, 45, 105, 54, 52, 1, 51, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 52, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 53, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 54, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 55, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 56, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 57, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 50, 1, 58, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 51, 1, 59, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 52, 1, 60, 0, 13, 116, 121, 112, 101, 45, 100, 117, 114, 97, 116, 105, 111, 110, 1, 61, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 62, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 63, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 192, 0, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 193, 0, 0, 4, 0, 9, 118, 101, 99, 45, 118, 97, 108, 117, 101, 3, 0, 66, 1, 107, 27, 1, 107, 127, 1, 107, 1, 1, 107, 118, 1, 107, 117, 1, 107, 3, 1, 107, 5, 1, 107, 115, 1, 107, 125, 1, 107, 123, 1, 107, 121, 1, 107, 119, 1, 107, 126, 1, 107, 124, 1, 107, 122, 1, 107, 120, 1, 107, 7, 1, 107, 9, 1, 107, 11, 1, 107, 13, 1, 107, 15, 1, 107, 17, 1, 107, 19, 1, 107, 21, 1, 107, 23, 1, 107, 25, 1, 107, 29, 1, 107, 31, 1, 107, 33, 1, 107, 35, 1, 113, 30, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 196, 0, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 197, 0, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 198, 0, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 199, 0, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 200, 0, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 201, 0, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 202, 0, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 203, 0, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 204, 0, 0, 8, 116, 121, 112, 101, 45, 117, 49, 54, 1, 205, 0, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 206, 0, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 207, 0, 0, 7, 116, 121, 112, 101, 45, 105, 56, 1, 208, 0, 0, 8, 116, 121, 112, 101, 45, 105, 49, 54, 1, 209, 0, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 210, 0, 0, 8, 116, 121, 112, 101, 45, 105, 54, 52, 1, 211, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 212, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 213, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 214, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 215, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 216, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 217, 0, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 50, 1, 218, 0, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 51, 1, 219, 0, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 52, 1, 220, 0, 0, 13, 116, 121, 112, 101, 45, 100, 117, 114, 97, 116, 105, 111, 110, 1, 221, 0, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 222, 0, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 223, 0, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 224, 0, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 225, 0, 0, 4, 0, 12, 111, 112, 116, 105, 111, 110, 45, 118, 97, 108, 117, 101, 3, 0, 98, 1, 113, 32, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 27, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 127, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 1, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 118, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 117, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 3, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 5, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 115, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 125, 0, 8, 116, 121, 112, 101, 45, 117, 49, 54, 1, 123, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 121, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 119, 0, 7, 116, 121, 112, 101, 45, 105, 56, 1, 126, 0, 8, 116, 121, 112, 101, 45, 105, 49, 54, 1, 124, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 122, 0, 8, 116, 121, 112, 101, 45, 105, 54, 52, 1, 120, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 7, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 9, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 11, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 13, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 15, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 17, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 50, 1, 19, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 51, 1, 21, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 52, 1, 23, 0, 13, 116, 121, 112, 101, 45, 100, 117, 114, 97, 116, 105, 111, 110, 1, 25, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 29, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 31, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 33, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 35, 0, 8, 116, 121, 112, 101, 45, 118, 101, 99, 1, 195, 0, 0, 11, 116, 121, 112, 101, 45, 111, 112, 116, 105, 111, 110, 1, 227, 0, 0, 4, 0, 5, 118, 97, 108, 117, 101, 3, 0, 100, 1, 111, 2, 121, 229, 0, 1, 112, 230, 0, 4, 0, 6, 101, 110, 116, 105, 116, 121, 3, 0, 103, 1, 114, 4, 10, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 46, 8, 105, 110, 99, 108, 117, 100, 101, 115, 46, 8, 101, 120, 99, 108, 117, 100, 101, 115, 46, 7, 99, 104, 97, 110, 103, 101, 100, 46, 4, 0, 11, 113, 117, 101, 114, 121, 45, 98, 117, 105, 108, 100, 3, 0, 105, 1, 109, 3, 5, 102, 114, 97, 109, 101, 5, 115, 112, 97, 119, 110, 7, 100, 101, 115, 112, 97, 119, 110, 4, 0, 11, 113, 117, 101, 114, 121, 45, 101, 118, 101, 110, 116, 3, 0, 107, 1, 64, 1, 2, 105, 100, 115, 0, 206, 0, 4, 0, 9, 103, 101, 116, 45, 105, 110, 100, 101, 120, 1, 109, 1, 64, 1, 5, 105, 110, 100, 101, 120, 121, 0, 203, 0, 4, 0, 6, 103, 101, 116, 45, 105, 100, 1, 110, 1, 107, 229, 0, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 0, 239, 0, 4, 0, 13, 103, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 1, 112, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 110, 100, 105, 99, 101, 115, 46, 0, 232, 0, 4, 0, 14, 103, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 113, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 0, 232, 0, 4, 0, 18, 103, 101, 116, 45, 97, 108, 108, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 114, 1, 64, 3, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 5, 118, 97, 108, 117, 101, 229, 0, 1, 0, 4, 0, 13, 97, 100, 100, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 1, 115, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 4, 100, 97, 116, 97, 232, 0, 1, 0, 4, 0, 14, 97, 100, 100, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 116, 4, 0, 13, 115, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 1, 115, 4, 0, 14, 115, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 116, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 0, 127, 4, 0, 13, 104, 97, 115, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 1, 117, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 110, 100, 105, 99, 101, 115, 46, 0, 127, 4, 0, 14, 104, 97, 115, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 118, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 1, 0, 4, 0, 16, 114, 101, 109, 111, 118, 101, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 1, 119, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 110, 100, 105, 99, 101, 115, 46, 1, 0, 4, 0, 17, 114, 101, 109, 111, 118, 101, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 120, 1, 64, 2, 1, 113, 234, 0, 1, 116, 236, 0, 0, 119, 4, 0, 5, 113, 117, 101, 114, 121, 1, 121, 1, 112, 229, 0, 1, 111, 2, 1, 250, 0, 1, 112, 251, 0, 1, 64, 1, 1, 113, 119, 0, 252, 0, 4, 0, 10, 113, 117, 101, 114, 121, 45, 101, 118, 97, 108, 1, 125, 3, 1, 26, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 5, 25, 2, 3, 0, 6, 6, 101, 110, 116, 105, 116, 121, 1, 66, 29, 2, 3, 2, 1, 11, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 2, 3, 2, 1, 3, 4, 0, 4, 118, 101, 99, 51, 3, 0, 2, 2, 3, 2, 1, 13, 4, 0, 4, 113, 117, 97, 116, 3, 0, 4, 2, 3, 2, 1, 12, 4, 0, 4, 109, 97, 116, 52, 3, 0, 6, 2, 3, 2, 1, 26, 4, 0, 11, 101, 110, 116, 105, 116, 121, 45, 100, 97, 116, 97, 3, 0, 8, 1, 112, 1, 1, 112, 7, 1, 64, 2, 8, 101, 110, 116, 105, 116, 105, 101, 115, 10, 6, 111, 114, 105, 103, 105, 110, 1, 0, 11, 4, 0, 26, 103, 101, 116, 45, 116, 114, 97, 110, 115, 102, 111, 114, 109, 115, 45, 114, 101, 108, 97, 116, 105, 118, 101, 45, 116, 111, 1, 12, 1, 64, 1, 4, 100, 97, 116, 97, 9, 0, 1, 4, 0, 5, 115, 112, 97, 119, 110, 1, 13, 1, 107, 9, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 0, 14, 4, 0, 7, 100, 101, 115, 112, 97, 119, 110, 1, 15, 1, 64, 2, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 6, 114, 97, 100, 105, 117, 115, 118, 0, 10, 4, 0, 7, 105, 110, 45, 97, 114, 101, 97, 1, 16, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 0, 127, 4, 0, 6, 101, 120, 105, 115, 116, 115, 1, 17, 1, 64, 1, 5, 105, 110, 100, 101, 120, 121, 0, 10, 4, 0, 7, 103, 101, 116, 45, 97, 108, 108, 1, 18, 1, 64, 0, 0, 1, 4, 0, 9, 114, 101, 115, 111, 117, 114, 99, 101, 115, 1, 19, 4, 0, 22, 115, 121, 110, 99, 104, 114, 111, 110, 105, 122, 101, 100, 45, 114, 101, 115, 111, 117, 114, 99, 101, 115, 1, 19, 4, 0, 19, 112, 101, 114, 115, 105, 115, 116, 101, 100, 45, 114, 101, 115, 111, 117, 114, 99, 101, 115, 1, 19, 3, 1, 23, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 101, 110, 116, 105, 116, 121, 5, 27, 1, 66, 4, 2, 3, 2, 1, 26, 4, 0, 6, 101, 110, 116, 105, 116, 121, 3, 0, 0, 1, 64, 1, 4, 110, 97, 109, 101, 115, 1, 0, 4, 0, 9, 115, 117, 98, 115, 99, 114, 105, 98, 101, 1, 2, 3, 1, 24, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 109, 101, 115, 115, 97, 103, 101, 5, 28, 1, 66, 5, 2, 3, 2, 1, 11, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 1, 107, 1, 1, 64, 1, 7, 117, 115, 101, 114, 45, 105, 100, 115, 0, 2, 4, 0, 14, 103, 101, 116, 45, 98, 121, 45, 117, 115, 101, 114, 45, 105, 100, 1, 3, 3, 1, 23, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 112, 108, 97, 121, 101, 114, 5, 29, 1, 66, 7, 2, 3, 2, 1, 11, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 1, 113, 4, 17, 115, 101, 114, 118, 101, 114, 45, 117, 110, 114, 101, 108, 105, 97, 98, 108, 101, 0, 0, 15, 115, 101, 114, 118, 101, 114, 45, 114, 101, 108, 105, 97, 98, 108, 101, 0, 0, 15, 108, 111, 99, 97, 108, 45, 98, 114, 111, 97, 100, 99, 97, 115, 116, 1, 127, 0, 5, 108, 111, 99, 97, 108, 1, 1, 0, 4, 0, 6, 116, 97, 114, 103, 101, 116, 3, 0, 2, 1, 112, 125, 1, 64, 3, 9, 116, 97, 114, 103, 101, 116, 45, 105, 100, 3, 4, 110, 97, 109, 101, 115, 4, 100, 97, 116, 97, 4, 1, 0, 4, 0, 4, 115, 101, 110, 100, 1, 5, 3, 1, 31, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 115, 97, 103, 101, 5, 30, 1, 66, 4, 2, 3, 2, 1, 11, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 1, 64, 0, 0, 1, 4, 0, 9, 103, 101, 116, 45, 108, 111, 99, 97, 108, 1, 2, 3, 1, 30, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 112, 108, 97, 121, 101, 114, 5, 31, 1, 66, 23, 2, 3, 2, 1, 2, 4, 0, 4, 118, 101, 99, 50, 3, 0, 0, 2, 3, 2, 1, 11, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 2, 1, 109, 163, 1, 4, 107, 101, 121, 49, 4, 107, 101, 121, 50, 4, 107, 101, 121, 51, 4, 107, 101, 121, 52, 4, 107, 101, 121, 53, 4, 107, 101, 121, 54, 4, 107, 101, 121, 55, 4, 107, 101, 121, 56, 4, 107, 101, 121, 57, 4, 107, 101, 121, 48, 1, 97, 1, 98, 1, 99, 1, 100, 1, 101, 1, 102, 1, 103, 1, 104, 1, 105, 1, 106, 1, 107, 1, 108, 1, 109, 1, 110, 1, 111, 1, 112, 1, 113, 1, 114, 1, 115, 1, 116, 1, 117, 1, 118, 1, 119, 1, 120, 1, 121, 1, 122, 6, 101, 115, 99, 97, 112, 101, 2, 102, 49, 2, 102, 50, 2, 102, 51, 2, 102, 52, 2, 102, 53, 2, 102, 54, 2, 102, 55, 2, 102, 56, 2, 102, 57, 3, 102, 49, 48, 3, 102, 49, 49, 3, 102, 49, 50, 3, 102, 49, 51, 3, 102, 49, 52, 3, 102, 49, 53, 3, 102, 49, 54, 3, 102, 49, 55, 3, 102, 49, 56, 3, 102, 49, 57, 3, 102, 50, 48, 3, 102, 50, 49, 3, 102, 50, 50, 3, 102, 50, 51, 3, 102, 50, 52, 8, 115, 110, 97, 112, 115, 104, 111, 116, 6, 115, 99, 114, 111, 108, 108, 5, 112, 97, 117, 115, 101, 6, 105, 110, 115, 101, 114, 116, 4, 104, 111, 109, 101, 6, 100, 101, 108, 101, 116, 101, 3, 101, 110, 100, 9, 112, 97, 103, 101, 45, 100, 111, 119, 110, 7, 112, 97, 103, 101, 45, 117, 112, 4, 108, 101, 102, 116, 2, 117, 112, 5, 114, 105, 103, 104, 116, 4, 100, 111, 119, 110, 4, 98, 97, 99, 107, 6, 114, 101, 116, 117, 114, 110, 5, 115, 112, 97, 99, 101, 7, 99, 111, 109, 112, 111, 115, 101, 5, 99, 97, 114, 101, 116, 7, 110, 117, 109, 108, 111, 99, 107, 7, 110, 117, 109, 112, 97, 100, 48, 7, 110, 117, 109, 112, 97, 100, 49, 7, 110, 117, 109, 112, 97, 100, 50, 7, 110, 117, 109, 112, 97, 100, 51, 7, 110, 117, 109, 112, 97, 100, 52, 7, 110, 117, 109, 112, 97, 100, 53, 7, 110, 117, 109, 112, 97, 100, 54, 7, 110, 117, 109, 112, 97, 100, 55, 7, 110, 117, 109, 112, 97, 100, 56, 7, 110, 117, 109, 112, 97, 100, 57, 10, 110, 117, 109, 112, 97, 100, 45, 97, 100, 100, 13, 110, 117, 109, 112, 97, 100, 45, 100, 105, 118, 105, 100, 101, 14, 110, 117, 109, 112, 97, 100, 45, 100, 101, 99, 105, 109, 97, 108, 12, 110, 117, 109, 112, 97, 100, 45, 99, 111, 109, 109, 97, 12, 110, 117, 109, 112, 97, 100, 45, 101, 110, 116, 101, 114, 13, 110, 117, 109, 112, 97, 100, 45, 101, 113, 117, 97, 108, 115, 15, 110, 117, 109, 112, 97, 100, 45, 109, 117, 108, 116, 105, 112, 108, 121, 15, 110, 117, 109, 112, 97, 100, 45, 115, 117, 98, 116, 114, 97, 99, 116, 7, 97, 98, 110, 116, 45, 99, 49, 7, 97, 98, 110, 116, 45, 99, 50, 10, 97, 112, 111, 115, 116, 114, 111, 112, 104, 101, 4, 97, 112, 112, 115, 8, 97, 115, 116, 101, 114, 105, 115, 107, 2, 97, 116, 2, 97, 120, 9, 98, 97, 99, 107, 115, 108, 97, 115, 104, 10, 99, 97, 108, 99, 117, 108, 97, 116, 111, 114, 7, 99, 97, 112, 105, 116, 97, 108, 5, 99, 111, 108, 111, 110, 5, 99, 111, 109, 109, 97, 7, 99, 111, 110, 118, 101, 114, 116, 6, 101, 113, 117, 97, 108, 115, 5, 103, 114, 97, 118, 101, 4, 107, 97, 110, 97, 5, 107, 97, 110, 106, 105, 5, 108, 45, 97, 108, 116, 9, 108, 45, 98, 114, 97, 99, 107, 101, 116, 9, 108, 45, 99, 111, 110, 116, 114, 111, 108, 7, 108, 45, 115, 104, 105, 102, 116, 5, 108, 45, 119, 105, 110, 4, 109, 97, 105, 108, 12, 109, 101, 100, 105, 97, 45, 115, 101, 108, 101, 99, 116, 10, 109, 101, 100, 105, 97, 45, 115, 116, 111, 112, 5, 109, 105, 110, 117, 115, 4, 109, 117, 116, 101, 11, 109, 121, 45, 99, 111, 109, 112, 117, 116, 101, 114, 16, 110, 97, 118, 105, 103, 97, 116, 101, 45, 102, 111, 114, 119, 97, 114, 100, 17, 110, 97, 118, 105, 103, 97, 116, 101, 45, 98, 97, 99, 107, 119, 97, 114, 100, 10, 110, 101, 120, 116, 45, 116, 114, 97, 99, 107, 10, 110, 111, 45, 99, 111, 110, 118, 101, 114, 116, 6, 111, 101, 109, 49, 48, 50, 6, 112, 101, 114, 105, 111, 100, 10, 112, 108, 97, 121, 45, 112, 97, 117, 115, 101, 4, 112, 108, 117, 115, 5, 112, 111, 119, 101, 114, 10, 112, 114, 101, 118, 45, 116, 114, 97, 99, 107, 5, 114, 45, 97, 108, 116, 9, 114, 45, 98, 114, 97, 99, 107, 101, 116, 9, 114, 45, 99, 111, 110, 116, 114, 111, 108, 7, 114, 45, 115, 104, 105, 102, 116, 5, 114, 45, 119, 105, 110, 9, 115, 101, 109, 105, 99, 111, 108, 111, 110, 5, 115, 108, 97, 115, 104, 5, 115, 108, 101, 101, 112, 4, 115, 116, 111, 112, 5, 115, 121, 115, 114, 113, 3, 116, 97, 98, 9, 117, 110, 100, 101, 114, 108, 105, 110, 101, 9, 117, 110, 108, 97, 98, 101, 108, 101, 100, 11, 118, 111, 108, 117, 109, 101, 45, 100, 111, 119, 110, 9, 118, 111, 108, 117, 109, 101, 45, 117, 112, 4, 119, 97, 107, 101, 8, 119, 101, 98, 45, 98, 97, 99, 107, 13, 119, 101, 98, 45, 102, 97, 118, 111, 114, 105, 116, 101, 115, 11, 119, 101, 98, 45, 102, 111, 114, 119, 97, 114, 100, 8, 119, 101, 98, 45, 104, 111, 109, 101, 11, 119, 101, 98, 45, 114, 101, 102, 114, 101, 115, 104, 10, 119, 101, 98, 45, 115, 101, 97, 114, 99, 104, 8, 119, 101, 98, 45, 115, 116, 111, 112, 3, 121, 101, 110, 4, 99, 111, 112, 121, 5, 112, 97, 115, 116, 101, 3, 99, 117, 116, 4, 0, 16, 118, 105, 114, 116, 117, 97, 108, 45, 107, 101, 121, 45, 99, 111, 100, 101, 3, 0, 4, 1, 113, 4, 4, 108, 101, 102, 116, 0, 0, 5, 114, 105, 103, 104, 116, 0, 0, 6, 109, 105, 100, 100, 108, 101, 0, 0, 5, 111, 116, 104, 101, 114, 1, 123, 0, 4, 0, 12, 109, 111, 117, 115, 101, 45, 98, 117, 116, 116, 111, 110, 3, 0, 6, 1, 112, 5, 1, 112, 7, 1, 114, 5, 4, 107, 101, 121, 115, 8, 14, 109, 111, 117, 115, 101, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 11, 109, 111, 117, 115, 101, 45, 100, 101, 108, 116, 97, 1, 11, 109, 111, 117, 115, 101, 45, 119, 104, 101, 101, 108, 118, 13, 109, 111, 117, 115, 101, 45, 98, 117, 116, 116, 111, 110, 115, 9, 4, 0, 5, 105, 110, 112, 117, 116, 3, 0, 10, 1, 113, 35, 12, 100, 101, 102, 97, 117, 108, 116, 45, 105, 99, 111, 110, 0, 0, 9, 99, 114, 111, 115, 115, 104, 97, 105, 114, 0, 0, 4, 104, 97, 110, 100, 0, 0, 5, 97, 114, 114, 111, 119, 0, 0, 4, 109, 111, 118, 101, 0, 0, 4, 116, 101, 120, 116, 0, 0, 4, 119, 97, 105, 116, 0, 0, 4, 104, 101, 108, 112, 0, 0, 8, 112, 114, 111, 103, 114, 101, 115, 115, 0, 0, 11, 110, 111, 116, 45, 97, 108, 108, 111, 119, 101, 100, 0, 0, 12, 99, 111, 110, 116, 101, 120, 116, 45, 109, 101, 110, 117, 0, 0, 4, 99, 101, 108, 108, 0, 0, 13, 118, 101, 114, 116, 105, 99, 97, 108, 45, 116, 101, 120, 116, 0, 0, 5, 97, 108, 105, 97, 115, 0, 0, 4, 99, 111, 112, 121, 0, 0, 7, 110, 111, 45, 100, 114, 111, 112, 0, 0, 4, 103, 114, 97, 98, 0, 0, 8, 103, 114, 97, 98, 98, 105, 110, 103, 0, 0, 10, 97, 108, 108, 45, 115, 99, 114, 111, 108, 108, 0, 0, 7, 122, 111, 111, 109, 45, 105, 110, 0, 0, 8, 122, 111, 111, 109, 45, 111, 117, 116, 0, 0, 8, 101, 45, 114, 101, 115, 105, 122, 101, 0, 0, 8, 110, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 110, 101, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 110, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 8, 115, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 115, 101, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 115, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 8, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 101, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 110, 115, 45, 114, 101, 115, 105, 122, 101, 0, 0, 11, 110, 101, 115, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 11, 110, 119, 115, 101, 45, 114, 101, 115, 105, 122, 101, 0, 0, 10, 99, 111, 108, 45, 114, 101, 115, 105, 122, 101, 0, 0, 10, 114, 111, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 4, 0, 11, 99, 117, 114, 115, 111, 114, 45, 105, 99, 111, 110, 3, 0, 12, 1, 64, 0, 0, 11, 4, 0, 3, 103, 101, 116, 1, 14, 4, 0, 12, 103, 101, 116, 45, 112, 114, 101, 118, 105, 111, 117, 115, 1, 14, 1, 64, 1, 4, 105, 99, 111, 110, 13, 1, 0, 4, 0, 10, 115, 101, 116, 45, 99, 117, 114, 115, 111, 114, 1, 15, 1, 64, 1, 7, 118, 105, 115, 105, 98, 108, 101, 127, 1, 0, 4, 0, 18, 115, 101, 116, 45, 99, 117, 114, 115, 111, 114, 45, 118, 105, 115, 105, 98, 108, 101, 1, 16, 1, 64, 1, 6, 108, 111, 99, 107, 101, 100, 127, 1, 0, 4, 0, 15, 115, 101, 116, 45, 99, 117, 114, 115, 111, 114, 45, 108, 111, 99, 107, 1, 17, 3, 1, 29, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 105, 110, 112, 117, 116, 5, 32, 2, 3, 0, 0, 3, 114, 97, 121, 1, 66, 16, 2, 3, 2, 1, 3, 4, 0, 4, 118, 101, 99, 51, 3, 0, 0, 2, 3, 2, 1, 2, 4, 0, 4, 118, 101, 99, 50, 3, 0, 2, 2, 3, 2, 1, 33, 4, 0, 3, 114, 97, 121, 3, 0, 4, 2, 3, 2, 1, 11, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 6, 1, 64, 2, 6, 99, 97, 109, 101, 114, 97, 7, 14, 99, 108, 105, 112, 45, 115, 112, 97, 99, 101, 45, 112, 111, 115, 3, 0, 5, 4, 0, 26, 99, 108, 105, 112, 45, 112, 111, 115, 105, 116, 105, 111, 110, 45, 116, 111, 45, 119, 111, 114, 108, 100, 45, 114, 97, 121, 1, 8, 1, 64, 1, 10, 115, 99, 114, 101, 101, 110, 45, 112, 111, 115, 3, 0, 3, 4, 0, 20, 115, 99, 114, 101, 101, 110, 45, 116, 111, 45, 99, 108, 105, 112, 45, 115, 112, 97, 99, 101, 1, 9, 1, 64, 2, 6, 99, 97, 109, 101, 114, 97, 7, 10, 115, 99, 114, 101, 101, 110, 45, 112, 111, 115, 3, 0, 5, 4, 0, 28, 115, 99, 114, 101, 101, 110, 45, 112, 111, 115, 105, 116, 105, 111, 110, 45, 116, 111, 45, 119, 111, 114, 108, 100, 45, 114, 97, 121, 1, 10, 1, 64, 2, 6, 99, 97, 109, 101, 114, 97, 7, 10, 115, 99, 114, 101, 101, 110, 45, 112, 111, 115, 1, 0, 3, 4, 0, 15, 119, 111, 114, 108, 100, 45, 116, 111, 45, 115, 99, 114, 101, 101, 110, 1, 11, 3, 1, 30, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 99, 97, 109, 101, 114, 97, 5, 34, 1, 66, 5, 1, 107, 115, 1, 64, 0, 0, 0, 4, 0, 3, 103, 101, 116, 1, 1, 1, 64, 1, 4, 116, 101, 120, 116, 115, 1, 0, 4, 0, 3, 115, 101, 116, 1, 2, 3, 1, 33, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 99, 108, 105, 112, 98, 111, 97, 114, 100, 5, 35, 1, 66, 2, 1, 64, 1, 10, 102, 117, 108, 108, 115, 99, 114, 101, 101, 110, 127, 1, 0, 4, 0, 14, 115, 101, 116, 45, 102, 117, 108, 108, 115, 99, 114, 101, 101, 110, 1, 0, 3, 1, 30, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 119, 105, 110, 100, 111, 119, 5, 36, 1, 66, 2, 1, 64, 0, 1, 0, 4, 0, 10, 98, 117, 105, 108, 100, 45, 119, 97, 115, 109, 1, 0, 3, 1, 29, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 115, 101, 114, 118, 101, 114, 45, 97, 115, 115, 101, 116, 5, 37, 1, 66, 43, 2, 3, 2, 1, 11, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 2, 3, 2, 1, 3, 4, 0, 4, 118, 101, 99, 51, 3, 0, 2, 2, 3, 2, 1, 12, 4, 0, 4, 109, 97, 116, 52, 3, 0, 4, 1, 114, 3, 4, 115, 105, 100, 101, 127, 2, 117, 112, 127, 4, 100, 111, 119, 110, 127, 4, 0, 19, 99, 104, 97, 114, 97, 99, 116, 101, 114, 45, 99, 111, 108, 108, 105, 115, 105, 111, 110, 3, 0, 6, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 102, 111, 114, 99, 101, 3, 1, 0, 4, 0, 9, 97, 100, 100, 45, 102, 111, 114, 99, 101, 1, 8, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 109, 112, 117, 108, 115, 101, 3, 1, 0, 4, 0, 11, 97, 100, 100, 45, 105, 109, 112, 117, 108, 115, 101, 1, 9, 1, 107, 118, 1, 64, 4, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 7, 105, 109, 112, 117, 108, 115, 101, 118, 6, 114, 97, 100, 105, 117, 115, 118, 14, 102, 97, 108, 108, 111, 102, 102, 45, 114, 97, 100, 105, 117, 115, 10, 1, 0, 4, 0, 18, 97, 100, 100, 45, 114, 97, 100, 105, 97, 108, 45, 105, 109, 112, 117, 108, 115, 101, 1, 11, 1, 64, 3, 6, 101, 110, 116, 105, 116, 121, 1, 5, 102, 111, 114, 99, 101, 3, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 1, 0, 4, 0, 21, 97, 100, 100, 45, 102, 111, 114, 99, 101, 45, 97, 116, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 12, 1, 64, 3, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 109, 112, 117, 108, 115, 101, 3, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 1, 0, 4, 0, 23, 97, 100, 100, 45, 105, 109, 112, 117, 108, 115, 101, 45, 97, 116, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 13, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 0, 3, 4, 0, 24, 103, 101, 116, 45, 118, 101, 108, 111, 99, 105, 116, 121, 45, 97, 116, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 14, 1, 64, 1, 7, 103, 114, 97, 118, 105, 116, 121, 3, 1, 0, 4, 0, 11, 115, 101, 116, 45, 103, 114, 97, 118, 105, 116, 121, 1, 15, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 1, 0, 4, 0, 8, 117, 110, 102, 114, 101, 101, 122, 101, 1, 16, 4, 0, 6, 102, 114, 101, 101, 122, 101, 1, 16, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 8, 118, 101, 108, 111, 99, 105, 116, 121, 118, 1, 0, 4, 0, 11, 115, 116, 97, 114, 116, 45, 109, 111, 116, 111, 114, 1, 17, 4, 0, 10, 115, 116, 111, 112, 45, 109, 111, 116, 111, 114, 1, 16, 1, 64, 4, 6, 97, 99, 116, 111, 114, 48, 1, 10, 116, 114, 97, 110, 115, 102, 111, 114, 109, 48, 5, 6, 97, 99, 116, 111, 114, 49, 1, 10, 116, 114, 97, 110, 115, 102, 111, 114, 109, 49, 5, 1, 0, 4, 0, 21, 99, 114, 101, 97, 116, 101, 45, 114, 101, 118, 111, 108, 117, 116, 101, 45, 106, 111, 105, 110, 116, 1, 18, 1, 111, 2, 1, 118, 1, 107, 19, 1, 64, 2, 6, 111, 114, 105, 103, 105, 110, 3, 9, 100, 105, 114, 101, 99, 116, 105, 111, 110, 3, 0, 20, 4, 0, 13, 114, 97, 121, 99, 97, 115, 116, 45, 102, 105, 114, 115, 116, 1, 21, 1, 112, 19, 1, 64, 2, 6, 111, 114, 105, 103, 105, 110, 3, 9, 100, 105, 114, 101, 99, 116, 105, 111, 110, 3, 0, 22, 4, 0, 7, 114, 97, 121, 99, 97, 115, 116, 1, 23, 1, 64, 4, 6, 101, 110, 116, 105, 116, 121, 1, 12, 100, 105, 115, 112, 108, 97, 99, 101, 109, 101, 110, 116, 3, 8, 109, 105, 110, 45, 100, 105, 115, 116, 118, 12, 101, 108, 97, 112, 115, 101, 100, 45, 116, 105, 109, 101, 118, 0, 7, 4, 0, 14, 109, 111, 118, 101, 45, 99, 104, 97, 114, 97, 99, 116, 101, 114, 1, 24, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 1, 0, 4, 0, 22, 115, 101, 116, 45, 99, 104, 97, 114, 97, 99, 116, 101, 114, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 25, 4, 0, 27, 115, 101, 116, 45, 99, 104, 97, 114, 97, 99, 116, 101, 114, 45, 102, 111, 111, 116, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 25, 3, 1, 31, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 115, 101, 114, 118, 101, 114, 45, 112, 104, 121, 115, 105, 99, 115, 5, 38, 1, 66, 7, 2, 3, 2, 1, 11, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 1, 113, 6, 27, 99, 108, 105, 101, 110, 116, 45, 98, 114, 111, 97, 100, 99, 97, 115, 116, 45, 117, 110, 114, 101, 108, 105, 97, 98, 108, 101, 0, 0, 25, 99, 108, 105, 101, 110, 116, 45, 98, 114, 111, 97, 100, 99, 97, 115, 116, 45, 114, 101, 108, 105, 97, 98, 108, 101, 0, 0, 26, 99, 108, 105, 101, 110, 116, 45, 116, 97, 114, 103, 101, 116, 101, 100, 45, 117, 110, 114, 101, 108, 105, 97, 98, 108, 101, 1, 115, 0, 24, 99, 108, 105, 101, 110, 116, 45, 116, 97, 114, 103, 101, 116, 101, 100, 45, 114, 101, 108, 105, 97, 98, 108, 101, 1, 115, 0, 15, 108, 111, 99, 97, 108, 45, 98, 114, 111, 97, 100, 99, 97, 115, 116, 1, 127, 0, 5, 108, 111, 99, 97, 108, 1, 1, 0, 4, 0, 6, 116, 97, 114, 103, 101, 116, 3, 0, 2, 1, 112, 125, 1, 64, 3, 9, 116, 97, 114, 103, 101, 116, 45, 105, 100, 3, 4, 110, 97, 109, 101, 115, 4, 100, 97, 116, 97, 4, 1, 0, 4, 0, 4, 115, 101, 110, 100, 1, 5, 3, 1, 31, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 115, 101, 114, 118, 101, 114, 45, 109, 101, 115, 115, 97, 103, 101, 5, 39, 1, 66, 2, 1, 64, 1, 3, 117, 114, 108, 115, 1, 0, 4, 0, 3, 103, 101, 116, 1, 0, 3, 1, 28, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 115, 101, 114, 118, 101, 114, 45, 104, 116, 116, 112, 5, 40, 1, 66, 9, 2, 3, 2, 1, 11, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 1, 113, 4, 7, 114, 117, 110, 116, 105, 109, 101, 0, 0, 5, 108, 111, 99, 97, 108, 1, 1, 0, 6, 115, 101, 114, 118, 101, 114, 0, 0, 6, 99, 108, 105, 101, 110, 116, 1, 115, 0, 4, 0, 6, 115, 111, 117, 114, 99, 101, 3, 0, 2, 1, 64, 0, 1, 0, 4, 0, 4, 105, 110, 105, 116, 1, 4, 1, 112, 125, 1, 64, 3, 14, 109, 101, 115, 115, 97, 103, 101, 45, 115, 111, 117, 114, 99, 101, 3, 12, 109, 101, 115, 115, 97, 103, 101, 45, 110, 97, 109, 101, 115, 12, 109, 101, 115, 115, 97, 103, 101, 45, 100, 97, 116, 97, 5, 1, 0, 4, 0, 4, 101, 120, 101, 99, 1, 6, 4, 1, 22, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 103, 117, 101, 115, 116, 5, 41, 4, 1, 25, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 98, 105, 110, 100, 105, 110, 103, 115, 4, 42, 0, 69, 9, 112, 114, 111, 100, 117, 99, 101, 114, 115, 1, 12, 112, 114, 111, 99, 101, 115, 115, 101, 100, 45, 98, 121, 2, 13, 119, 105, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 6, 48, 46, 49, 50, 46, 48, 16, 119, 105, 116, 45, 98, 105, 110, 100, 103, 101, 110, 45, 114, 117, 115, 116, 5, 48, 46, 57, 46, 48, 11, 26, 1, 1, 20, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 119, 105, 116, 3, 0, 0];
                            
                            #[inline(never)]
                            #[doc(hidden)]
                            #[cfg(target_arch = "wasm32")]
                            pub fn __link_section() {}
                            