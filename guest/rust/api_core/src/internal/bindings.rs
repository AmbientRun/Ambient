// Generated by `wit-bindgen` 0.6.0. DO NOT EDIT!

#[allow(clippy::all)]
pub mod types{
  #[used]
  #[doc(hidden)]
  #[cfg(target_arch = "wasm32")]
  static __FORCE_SECTION_REF: fn() = super::__link_section;
  
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct Vec4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
  }
  impl core::fmt::Debug for Vec4 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("Vec4").field("x", &self.x).field("y", &self.y).field("z", &self.z).field("w", &self.w).finish()
    }
  }
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct Vec3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
  }
  impl core::fmt::Debug for Vec3 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("Vec3").field("x", &self.x).field("y", &self.y).field("z", &self.z).finish()
    }
  }
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct Vec2 {
    pub x: f32,
    pub y: f32,
  }
  impl core::fmt::Debug for Vec2 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("Vec2").field("x", &self.x).field("y", &self.y).finish()
    }
  }
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct Uvec4 {
    pub x: u32,
    pub y: u32,
    pub z: u32,
    pub w: u32,
  }
  impl core::fmt::Debug for Uvec4 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("Uvec4").field("x", &self.x).field("y", &self.y).field("z", &self.z).field("w", &self.w).finish()
    }
  }
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct Uvec3 {
    pub x: u32,
    pub y: u32,
    pub z: u32,
  }
  impl core::fmt::Debug for Uvec3 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("Uvec3").field("x", &self.x).field("y", &self.y).field("z", &self.z).finish()
    }
  }
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct Uvec2 {
    pub x: u32,
    pub y: u32,
  }
  impl core::fmt::Debug for Uvec2 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("Uvec2").field("x", &self.x).field("y", &self.y).finish()
    }
  }
  pub type Ulid = (u64,u64,);
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct Ray {
    pub origin: Vec3,
    pub dir: Vec3,
  }
  impl core::fmt::Debug for Ray {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("Ray").field("origin", &self.origin).field("dir", &self.dir).finish()
    }
  }
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct Quat {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
  }
  impl core::fmt::Debug for Quat {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("Quat").field("x", &self.x).field("y", &self.y).field("z", &self.z).field("w", &self.w).finish()
    }
  }
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct Mat4 {
    pub x: Vec4,
    pub y: Vec4,
    pub z: Vec4,
    pub w: Vec4,
  }
  impl core::fmt::Debug for Mat4 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("Mat4").field("x", &self.x).field("y", &self.y).field("z", &self.z).field("w", &self.w).finish()
    }
  }
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct EntityId {
    pub id0: u64,
    pub id1: u64,
  }
  impl core::fmt::Debug for EntityId {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("EntityId").field("id0", &self.id0).field("id1", &self.id1).finish()
    }
  }
  
}


#[allow(clippy::all)]
pub mod asset{
  #[used]
  #[doc(hidden)]
  #[cfg(target_arch = "wasm32")]
  static __FORCE_SECTION_REF: fn() = super::__link_section;
  
  #[derive(Clone)]
  pub enum UrlError{
    InvalidUrl(wit_bindgen::rt::string::String),
  }
  impl core::fmt::Debug for UrlError {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      match self {
        UrlError::InvalidUrl(e) => {
          f.debug_tuple("UrlError::InvalidUrl").field(e).finish()
        }
      }
    }
  }
  impl core::fmt::Display for UrlError {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      write!(f, "{:?}", self)}
    }
    
    impl std::error::Error for UrlError {}
    /// Cache status of an asset
    #[derive(Clone)]
    pub enum AssetCacheStatus{
      /// Ready to be used
      Ready,
      /// Not yet loaded
      NotLoaded,
      /// Asset has an error
      FailedLoading(wit_bindgen::rt::string::String),
    }
    impl core::fmt::Debug for AssetCacheStatus {
      fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
          AssetCacheStatus::Ready => {
            f.debug_tuple("AssetCacheStatus::Ready").finish()
          }
          AssetCacheStatus::NotLoaded => {
            f.debug_tuple("AssetCacheStatus::NotLoaded").finish()
          }
          AssetCacheStatus::FailedLoading(e) => {
            f.debug_tuple("AssetCacheStatus::FailedLoading").field(e).finish()
          }
        }
      }
    }
    /// Animation asset metdata
    #[derive(Clone)]
    pub struct AnimationAssetMetadata {
      /// BinderId for the animation tracks
      pub binders: wit_bindgen::rt::vec::Vec::<wit_bindgen::rt::string::String>,
      /// Duration in seconds
      pub duration: f32,
      /// Cache status of an animation asset
      pub status: AssetCacheStatus,
    }
    impl core::fmt::Debug for AnimationAssetMetadata {
      fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_struct("AnimationAssetMetadata").field("binders", &self.binders).field("duration", &self.duration).field("status", &self.status).finish()
      }
    }
    #[allow(clippy::all)]
    pub fn get_animation_asset_status(clip_url: &str,) -> AssetCacheStatus{
      
      #[allow(unused_imports)]
      use wit_bindgen::rt::{alloc, vec::Vec, string::String};
      unsafe {
        
        #[repr(align(4))]
        struct RetArea([u8; 12]);
        let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
        let vec0 = clip_url;
        let ptr0 = vec0.as_ptr() as i32;
        let len0 = vec0.len() as i32;
        let ptr1 = ret_area.as_mut_ptr() as i32;
        #[link(wasm_import_module = "asset")]
        extern "C" {
          #[cfg_attr(target_arch = "wasm32", link_name = "get-animation-asset-status")]
          #[cfg_attr(not(target_arch = "wasm32"), link_name = "asset_get-animation-asset-status")]
          fn wit_import(
          _: i32, _: i32, _: i32, );
        }
        wit_import(ptr0, len0, ptr1);
        {{match i32::from(*((ptr1 + 0) as *const u8)) {
          0 => AssetCacheStatus::Ready,
          1 => AssetCacheStatus::NotLoaded,
          #[cfg(debug_assertions)]2 => AssetCacheStatus::FailedLoading({
            let len2 = *((ptr1 + 8) as *const i32) as usize;
            
            {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 4) as *const i32) as *mut _, len2, len2))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 4) as *const i32) as *mut _, len2, len2)).unwrap()}}
          }),
          #[cfg(not(debug_assertions))]_ => AssetCacheStatus::FailedLoading({
            let len2 = *((ptr1 + 8) as *const i32) as usize;
            
            {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 4) as *const i32) as *mut _, len2, len2))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 4) as *const i32) as *mut _, len2, len2)).unwrap()}}
          }),
          #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
        }}}
      }
    }
    #[allow(clippy::all)]
    pub fn get_animation_asset_metadata(clips: &[&str],) -> wit_bindgen::rt::vec::Vec::<AnimationAssetMetadata>{
      
      #[allow(unused_imports)]
      use wit_bindgen::rt::{alloc, vec::Vec, string::String};
      unsafe {
        
        #[repr(align(4))]
        struct RetArea([u8; 8]);
        let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
        let vec1 = clips;
        let len1 = vec1.len() as i32;
        let layout1 = alloc::Layout::from_size_align_unchecked(vec1.len() * 8, 4);
        let result1 = if layout1.size() != 0
        {
          let ptr = alloc::alloc(layout1);
          if ptr.is_null()
          {
            alloc::handle_alloc_error(layout1);
          }
          ptr
        }else {
          core::ptr::null_mut()
        };
        for (i, e) in vec1.into_iter().enumerate() {
          let base = result1 as i32 + (i as i32) * 8;
          {
            let vec0 = e;
            let ptr0 = vec0.as_ptr() as i32;
            let len0 = vec0.len() as i32;
            *((base + 4) as *mut i32) = len0;
            *((base + 0) as *mut i32) = ptr0;
            
          }}
          let ptr2 = ret_area.as_mut_ptr() as i32;
          #[link(wasm_import_module = "asset")]
          extern "C" {
            #[cfg_attr(target_arch = "wasm32", link_name = "get-animation-asset-metadata")]
            #[cfg_attr(not(target_arch = "wasm32"), link_name = "asset_get-animation-asset-metadata")]
            fn wit_import(
            _: i32, _: i32, _: i32, );
          }
          wit_import(result1 as i32, len1, ptr2);
          let base6 = *((ptr2 + 0) as *const i32);
          let len6 = *((ptr2 + 4) as *const i32);
          let mut result6 = Vec::with_capacity(len6 as usize);
          for i in 0..len6 {
            let base = base6 + i *24;
            result6.push({
              let base4 = *((base + 0) as *const i32);
              let len4 = *((base + 4) as *const i32);
              let mut result4 = Vec::with_capacity(len4 as usize);
              for i in 0..len4 {
                let base = base4 + i *8;
                result4.push({
                  let len3 = *((base + 4) as *const i32) as usize;
                  
                  {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len3, len3))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len3, len3)).unwrap()}}
                });
              }
              wit_bindgen::rt::dealloc(base4, (len4 as usize) * 8, 4);
              
              AnimationAssetMetadata{binders:result4, duration:*((base + 8) as *const f32), status:{{match i32::from(*((base + 12) as *const u8)) {
                0 => AssetCacheStatus::Ready,
                1 => AssetCacheStatus::NotLoaded,
                #[cfg(debug_assertions)]2 => AssetCacheStatus::FailedLoading({
                  let len5 = *((base + 20) as *const i32) as usize;
                  
                  {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 16) as *const i32) as *mut _, len5, len5))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 16) as *const i32) as *mut _, len5, len5)).unwrap()}}
                }),
                #[cfg(not(debug_assertions))]_ => AssetCacheStatus::FailedLoading({
                  let len5 = *((base + 20) as *const i32) as usize;
                  
                  {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 16) as *const i32) as *mut _, len5, len5))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 16) as *const i32) as *mut _, len5, len5)).unwrap()}}
                }),
                #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
              }}}, }
            });
          }
          wit_bindgen::rt::dealloc(base6, (len6 as usize) * 24, 4);
          if layout1.size() != 0 {
            alloc::dealloc(result1, layout1);
          }
          result6
        }
      }
      #[allow(clippy::all)]
      pub fn url(path: &str,) -> Result<wit_bindgen::rt::string::String,UrlError>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 16]);
          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = path;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let ptr1 = ret_area.as_mut_ptr() as i32;
          #[link(wasm_import_module = "asset")]
          extern "C" {
            #[cfg_attr(target_arch = "wasm32", link_name = "url")]
            #[cfg_attr(not(target_arch = "wasm32"), link_name = "asset_url")]
            fn wit_import(
            _: i32, _: i32, _: i32, );
          }
          wit_import(ptr0, len0, ptr1);
          match i32::from(*((ptr1 + 0) as *const u8)) {
            0 => Ok({
              let len2 = *((ptr1 + 8) as *const i32) as usize;
              
              {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 4) as *const i32) as *mut _, len2, len2))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 4) as *const i32) as *mut _, len2, len2)).unwrap()}}
            }),
            1 => Err({{match i32::from(*((ptr1 + 4) as *const u8)) {
              #[cfg(debug_assertions)]0 => UrlError::InvalidUrl({
                let len3 = *((ptr1 + 12) as *const i32) as usize;
                
                {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 8) as *const i32) as *mut _, len3, len3))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 8) as *const i32) as *mut _, len3, len3)).unwrap()}}
              }),
              #[cfg(not(debug_assertions))]_ => UrlError::InvalidUrl({
                let len3 = *((ptr1 + 12) as *const i32) as usize;
                
                {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 8) as *const i32) as *mut _, len3, len3))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 8) as *const i32) as *mut _, len3, len3)).unwrap()}}
              }),
              #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
            }}}),
            #[cfg(not(debug_assertions))]
            _ => core::hint::unreachable_unchecked(),
            #[cfg(debug_assertions)]
            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod client_mesh{
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::__link_section;
      
      pub type Vec2 = super::types::Vec2;
      pub type Vec3 = super::types::Vec3;
      pub type Ulid = super::types::Ulid;
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Vertex {
        pub position: Vec3,
        pub normal: Vec3,
        pub tangent: Vec3,
        pub texcoord0: Vec2,
      }
      impl core::fmt::Debug for Vertex {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
          f.debug_struct("Vertex").field("position", &self.position).field("normal", &self.normal).field("tangent", &self.tangent).field("texcoord0", &self.texcoord0).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Handle {
        pub ulid: Ulid,
      }
      impl core::fmt::Debug for Handle {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
          f.debug_struct("Handle").field("ulid", &self.ulid).finish()
        }
      }
      #[derive(Clone)]
      pub struct Descriptor<'a,> {
        pub vertices: &'a [Vertex],
        pub indices: &'a [u32],
      }
      impl<'a,> core::fmt::Debug for Descriptor<'a,> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
          f.debug_struct("Descriptor").field("vertices", &self.vertices).field("indices", &self.indices).finish()
        }
      }
      #[allow(clippy::all)]
      pub fn create(desc: Descriptor<'_,>,) -> Handle{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(8))]
          struct RetArea([u8; 16]);
          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
          let Descriptor{ vertices:vertices0, indices:indices0, } = desc;
          let vec1 = vertices0;
          let ptr1 = vec1.as_ptr() as i32;
          let len1 = vec1.len() as i32;
          let vec2 = indices0;
          let ptr2 = vec2.as_ptr() as i32;
          let len2 = vec2.len() as i32;
          let ptr3 = ret_area.as_mut_ptr() as i32;
          #[link(wasm_import_module = "client-mesh")]
          extern "C" {
            #[cfg_attr(target_arch = "wasm32", link_name = "create")]
            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-mesh_create")]
            fn wit_import(
            _: i32, _: i32, _: i32, _: i32, _: i32, );
          }
          wit_import(ptr1, len1, ptr2, len2, ptr3);
          Handle{ulid:(*((ptr3 + 0) as *const i64) as u64, *((ptr3 + 8) as *const i64) as u64), }
        }
      }
      #[allow(clippy::all)]
      pub fn destroy(handle: Handle,){
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          let Handle{ ulid:ulid0, } = handle;
          let (t1_0, t1_1, ) = ulid0;
          
          #[link(wasm_import_module = "client-mesh")]
          extern "C" {
            #[cfg_attr(target_arch = "wasm32", link_name = "destroy")]
            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-mesh_destroy")]
            fn wit_import(
            _: i64, _: i64, );
          }
          wit_import(wit_bindgen::rt::as_i64(t1_0), wit_bindgen::rt::as_i64(t1_1));
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod client_texture{
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::__link_section;
      
      pub type Ulid = super::types::Ulid;
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Handle {
        pub ulid: Ulid,
      }
      impl core::fmt::Debug for Handle {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
          f.debug_struct("Handle").field("ulid", &self.ulid).finish()
        }
      }
      #[derive(Clone, Copy)]
      pub enum Format{
        R8Unorm,
        R8Snorm,
        R8Uint,
        R8Sint,
        R16Uint,
        R16Sint,
        R16Unorm,
        R16Snorm,
        R16Float,
        Rg8Unorm,
        Rg8Snorm,
        Rg8Uint,
        Rg8Sint,
        R32Uint,
        R32Sint,
        R32Float,
        Rg16Uint,
        Rg16Sint,
        Rg16Unorm,
        Rg16Snorm,
        Rg16Float,
        Rgba8Unorm,
        Rgba8UnormSrgb,
        Rgba8Snorm,
        Rgba8Uint,
        Rgba8Sint,
        Bgra8Unorm,
        Bgra8UnormSrgb,
        Rgb9e5Ufloat,
        Rgb10a2Unorm,
        Rg11b10Float,
        Rg32Uint,
        Rg32Sint,
        Rg32Float,
        Rgba16Uint,
        Rgba16Sint,
        Rgba16Unorm,
        Rgba16Snorm,
        Rgba16Float,
        Rgba32Uint,
        Rgba32Sint,
        Rgba32Float,
      }
      impl core::fmt::Debug for Format {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
          match self {
            Format::R8Unorm => {
              f.debug_tuple("Format::R8Unorm").finish()
            }
            Format::R8Snorm => {
              f.debug_tuple("Format::R8Snorm").finish()
            }
            Format::R8Uint => {
              f.debug_tuple("Format::R8Uint").finish()
            }
            Format::R8Sint => {
              f.debug_tuple("Format::R8Sint").finish()
            }
            Format::R16Uint => {
              f.debug_tuple("Format::R16Uint").finish()
            }
            Format::R16Sint => {
              f.debug_tuple("Format::R16Sint").finish()
            }
            Format::R16Unorm => {
              f.debug_tuple("Format::R16Unorm").finish()
            }
            Format::R16Snorm => {
              f.debug_tuple("Format::R16Snorm").finish()
            }
            Format::R16Float => {
              f.debug_tuple("Format::R16Float").finish()
            }
            Format::Rg8Unorm => {
              f.debug_tuple("Format::Rg8Unorm").finish()
            }
            Format::Rg8Snorm => {
              f.debug_tuple("Format::Rg8Snorm").finish()
            }
            Format::Rg8Uint => {
              f.debug_tuple("Format::Rg8Uint").finish()
            }
            Format::Rg8Sint => {
              f.debug_tuple("Format::Rg8Sint").finish()
            }
            Format::R32Uint => {
              f.debug_tuple("Format::R32Uint").finish()
            }
            Format::R32Sint => {
              f.debug_tuple("Format::R32Sint").finish()
            }
            Format::R32Float => {
              f.debug_tuple("Format::R32Float").finish()
            }
            Format::Rg16Uint => {
              f.debug_tuple("Format::Rg16Uint").finish()
            }
            Format::Rg16Sint => {
              f.debug_tuple("Format::Rg16Sint").finish()
            }
            Format::Rg16Unorm => {
              f.debug_tuple("Format::Rg16Unorm").finish()
            }
            Format::Rg16Snorm => {
              f.debug_tuple("Format::Rg16Snorm").finish()
            }
            Format::Rg16Float => {
              f.debug_tuple("Format::Rg16Float").finish()
            }
            Format::Rgba8Unorm => {
              f.debug_tuple("Format::Rgba8Unorm").finish()
            }
            Format::Rgba8UnormSrgb => {
              f.debug_tuple("Format::Rgba8UnormSrgb").finish()
            }
            Format::Rgba8Snorm => {
              f.debug_tuple("Format::Rgba8Snorm").finish()
            }
            Format::Rgba8Uint => {
              f.debug_tuple("Format::Rgba8Uint").finish()
            }
            Format::Rgba8Sint => {
              f.debug_tuple("Format::Rgba8Sint").finish()
            }
            Format::Bgra8Unorm => {
              f.debug_tuple("Format::Bgra8Unorm").finish()
            }
            Format::Bgra8UnormSrgb => {
              f.debug_tuple("Format::Bgra8UnormSrgb").finish()
            }
            Format::Rgb9e5Ufloat => {
              f.debug_tuple("Format::Rgb9e5Ufloat").finish()
            }
            Format::Rgb10a2Unorm => {
              f.debug_tuple("Format::Rgb10a2Unorm").finish()
            }
            Format::Rg11b10Float => {
              f.debug_tuple("Format::Rg11b10Float").finish()
            }
            Format::Rg32Uint => {
              f.debug_tuple("Format::Rg32Uint").finish()
            }
            Format::Rg32Sint => {
              f.debug_tuple("Format::Rg32Sint").finish()
            }
            Format::Rg32Float => {
              f.debug_tuple("Format::Rg32Float").finish()
            }
            Format::Rgba16Uint => {
              f.debug_tuple("Format::Rgba16Uint").finish()
            }
            Format::Rgba16Sint => {
              f.debug_tuple("Format::Rgba16Sint").finish()
            }
            Format::Rgba16Unorm => {
              f.debug_tuple("Format::Rgba16Unorm").finish()
            }
            Format::Rgba16Snorm => {
              f.debug_tuple("Format::Rgba16Snorm").finish()
            }
            Format::Rgba16Float => {
              f.debug_tuple("Format::Rgba16Float").finish()
            }
            Format::Rgba32Uint => {
              f.debug_tuple("Format::Rgba32Uint").finish()
            }
            Format::Rgba32Sint => {
              f.debug_tuple("Format::Rgba32Sint").finish()
            }
            Format::Rgba32Float => {
              f.debug_tuple("Format::Rgba32Float").finish()
            }
          }
        }
      }
      #[derive(Clone)]
      pub struct Descriptor2d<'a,> {
        pub width: u32,
        pub height: u32,
        pub format: Format,
        pub data: &'a [u8],
      }
      impl<'a,> core::fmt::Debug for Descriptor2d<'a,> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
          f.debug_struct("Descriptor2d").field("width", &self.width).field("height", &self.height).field("format", &self.format).field("data", &self.data).finish()
        }
      }
      #[allow(clippy::all)]
      pub fn create2d(desc: Descriptor2d<'_,>,) -> Handle{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(8))]
          struct RetArea([u8; 16]);
          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
          let Descriptor2d{ width:width0, height:height0, format:format0, data:data0, } = desc;
          let result1 = match format0 {
            Format::R8Unorm=> {
              0i32
            }
            Format::R8Snorm=> {
              1i32
            }
            Format::R8Uint=> {
              2i32
            }
            Format::R8Sint=> {
              3i32
            }
            Format::R16Uint=> {
              4i32
            }
            Format::R16Sint=> {
              5i32
            }
            Format::R16Unorm=> {
              6i32
            }
            Format::R16Snorm=> {
              7i32
            }
            Format::R16Float=> {
              8i32
            }
            Format::Rg8Unorm=> {
              9i32
            }
            Format::Rg8Snorm=> {
              10i32
            }
            Format::Rg8Uint=> {
              11i32
            }
            Format::Rg8Sint=> {
              12i32
            }
            Format::R32Uint=> {
              13i32
            }
            Format::R32Sint=> {
              14i32
            }
            Format::R32Float=> {
              15i32
            }
            Format::Rg16Uint=> {
              16i32
            }
            Format::Rg16Sint=> {
              17i32
            }
            Format::Rg16Unorm=> {
              18i32
            }
            Format::Rg16Snorm=> {
              19i32
            }
            Format::Rg16Float=> {
              20i32
            }
            Format::Rgba8Unorm=> {
              21i32
            }
            Format::Rgba8UnormSrgb=> {
              22i32
            }
            Format::Rgba8Snorm=> {
              23i32
            }
            Format::Rgba8Uint=> {
              24i32
            }
            Format::Rgba8Sint=> {
              25i32
            }
            Format::Bgra8Unorm=> {
              26i32
            }
            Format::Bgra8UnormSrgb=> {
              27i32
            }
            Format::Rgb9e5Ufloat=> {
              28i32
            }
            Format::Rgb10a2Unorm=> {
              29i32
            }
            Format::Rg11b10Float=> {
              30i32
            }
            Format::Rg32Uint=> {
              31i32
            }
            Format::Rg32Sint=> {
              32i32
            }
            Format::Rg32Float=> {
              33i32
            }
            Format::Rgba16Uint=> {
              34i32
            }
            Format::Rgba16Sint=> {
              35i32
            }
            Format::Rgba16Unorm=> {
              36i32
            }
            Format::Rgba16Snorm=> {
              37i32
            }
            Format::Rgba16Float=> {
              38i32
            }
            Format::Rgba32Uint=> {
              39i32
            }
            Format::Rgba32Sint=> {
              40i32
            }
            Format::Rgba32Float=> {
              41i32
            }
          };
          let vec2 = data0;
          let ptr2 = vec2.as_ptr() as i32;
          let len2 = vec2.len() as i32;
          let ptr3 = ret_area.as_mut_ptr() as i32;
          #[link(wasm_import_module = "client-texture")]
          extern "C" {
            #[cfg_attr(target_arch = "wasm32", link_name = "create2d")]
            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-texture_create2d")]
            fn wit_import(
            _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
          }
          wit_import(wit_bindgen::rt::as_i32(width0), wit_bindgen::rt::as_i32(height0), result1, ptr2, len2, ptr3);
          Handle{ulid:(*((ptr3 + 0) as *const i64) as u64, *((ptr3 + 8) as *const i64) as u64), }
        }
      }
      #[allow(clippy::all)]
      pub fn destroy(handle: Handle,){
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          let Handle{ ulid:ulid0, } = handle;
          let (t1_0, t1_1, ) = ulid0;
          
          #[link(wasm_import_module = "client-texture")]
          extern "C" {
            #[cfg_attr(target_arch = "wasm32", link_name = "destroy")]
            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-texture_destroy")]
            fn wit_import(
            _: i64, _: i64, );
          }
          wit_import(wit_bindgen::rt::as_i64(t1_0), wit_bindgen::rt::as_i64(t1_1));
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod client_sampler{
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::__link_section;
      
      pub type Ulid = super::types::Ulid;
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Handle {
        pub ulid: Ulid,
      }
      impl core::fmt::Debug for Handle {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
          f.debug_struct("Handle").field("ulid", &self.ulid).finish()
        }
      }
      #[derive(Clone, Copy)]
      pub enum FilterMode{
        Nearest,
        Linear,
      }
      impl core::fmt::Debug for FilterMode {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
          match self {
            FilterMode::Nearest => {
              f.debug_tuple("FilterMode::Nearest").finish()
            }
            FilterMode::Linear => {
              f.debug_tuple("FilterMode::Linear").finish()
            }
          }
        }
      }
      #[derive(Clone, Copy)]
      pub enum AddressMode{
        ClampToEdge,
        Repeat,
        MirrorRepeat,
      }
      impl core::fmt::Debug for AddressMode {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
          match self {
            AddressMode::ClampToEdge => {
              f.debug_tuple("AddressMode::ClampToEdge").finish()
            }
            AddressMode::Repeat => {
              f.debug_tuple("AddressMode::Repeat").finish()
            }
            AddressMode::MirrorRepeat => {
              f.debug_tuple("AddressMode::MirrorRepeat").finish()
            }
          }
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Descriptor {
        pub address_mode_u: AddressMode,
        pub address_mode_v: AddressMode,
        pub address_mode_w: AddressMode,
        pub mag_filter: FilterMode,
        pub min_filter: FilterMode,
        pub mipmap_filter: FilterMode,
      }
      impl core::fmt::Debug for Descriptor {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
          f.debug_struct("Descriptor").field("address-mode-u", &self.address_mode_u).field("address-mode-v", &self.address_mode_v).field("address-mode-w", &self.address_mode_w).field("mag-filter", &self.mag_filter).field("min-filter", &self.min_filter).field("mipmap-filter", &self.mipmap_filter).finish()
        }
      }
      #[allow(clippy::all)]
      pub fn create(desc: Descriptor,) -> Handle{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(8))]
          struct RetArea([u8; 16]);
          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
          let Descriptor{ address_mode_u:address_mode_u0, address_mode_v:address_mode_v0, address_mode_w:address_mode_w0, mag_filter:mag_filter0, min_filter:min_filter0, mipmap_filter:mipmap_filter0, } = desc;
          let result1 = match address_mode_u0 {
            AddressMode::ClampToEdge=> {
              0i32
            }
            AddressMode::Repeat=> {
              1i32
            }
            AddressMode::MirrorRepeat=> {
              2i32
            }
          };
          let result2 = match address_mode_v0 {
            AddressMode::ClampToEdge=> {
              0i32
            }
            AddressMode::Repeat=> {
              1i32
            }
            AddressMode::MirrorRepeat=> {
              2i32
            }
          };
          let result3 = match address_mode_w0 {
            AddressMode::ClampToEdge=> {
              0i32
            }
            AddressMode::Repeat=> {
              1i32
            }
            AddressMode::MirrorRepeat=> {
              2i32
            }
          };
          let result4 = match mag_filter0 {
            FilterMode::Nearest=> {
              0i32
            }
            FilterMode::Linear=> {
              1i32
            }
          };
          let result5 = match min_filter0 {
            FilterMode::Nearest=> {
              0i32
            }
            FilterMode::Linear=> {
              1i32
            }
          };
          let result6 = match mipmap_filter0 {
            FilterMode::Nearest=> {
              0i32
            }
            FilterMode::Linear=> {
              1i32
            }
          };
          let ptr7 = ret_area.as_mut_ptr() as i32;
          #[link(wasm_import_module = "client-sampler")]
          extern "C" {
            #[cfg_attr(target_arch = "wasm32", link_name = "create")]
            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-sampler_create")]
            fn wit_import(
            _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
          }
          wit_import(result1, result2, result3, result4, result5, result6, ptr7);
          Handle{ulid:(*((ptr7 + 0) as *const i64) as u64, *((ptr7 + 8) as *const i64) as u64), }
        }
      }
      #[allow(clippy::all)]
      pub fn destroy(handle: Handle,){
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          let Handle{ ulid:ulid0, } = handle;
          let (t1_0, t1_1, ) = ulid0;
          
          #[link(wasm_import_module = "client-sampler")]
          extern "C" {
            #[cfg_attr(target_arch = "wasm32", link_name = "destroy")]
            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-sampler_destroy")]
            fn wit_import(
            _: i64, _: i64, );
          }
          wit_import(wit_bindgen::rt::as_i64(t1_0), wit_bindgen::rt::as_i64(t1_1));
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod client_material{
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::__link_section;
      
      pub type Ulid = super::types::Ulid;
      pub type TextureHandle = super::client_texture::Handle;
      pub type SamplerHandle = super::client_sampler::Handle;
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Handle {
        pub ulid: Ulid,
      }
      impl core::fmt::Debug for Handle {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
          f.debug_struct("Handle").field("ulid", &self.ulid).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Descriptor {
        pub base_color_map: TextureHandle,
        pub normal_map: TextureHandle,
        pub metallic_roughness_map: TextureHandle,
        pub sampler: SamplerHandle,
        pub transparent: bool,
      }
      impl core::fmt::Debug for Descriptor {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
          f.debug_struct("Descriptor").field("base-color-map", &self.base_color_map).field("normal-map", &self.normal_map).field("metallic-roughness-map", &self.metallic_roughness_map).field("sampler", &self.sampler).field("transparent", &self.transparent).finish()
        }
      }
      #[allow(clippy::all)]
      pub fn create(desc: Descriptor,) -> Handle{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(8))]
          struct RetArea([u8; 16]);
          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
          let Descriptor{ base_color_map:base_color_map0, normal_map:normal_map0, metallic_roughness_map:metallic_roughness_map0, sampler:sampler0, transparent:transparent0, } = desc;
          let super::client_texture::Handle{ ulid:ulid1, } = base_color_map0;
          let (t2_0, t2_1, ) = ulid1;
          let super::client_texture::Handle{ ulid:ulid3, } = normal_map0;
          let (t4_0, t4_1, ) = ulid3;
          let super::client_texture::Handle{ ulid:ulid5, } = metallic_roughness_map0;
          let (t6_0, t6_1, ) = ulid5;
          let super::client_sampler::Handle{ ulid:ulid7, } = sampler0;
          let (t8_0, t8_1, ) = ulid7;
          let ptr9 = ret_area.as_mut_ptr() as i32;
          #[link(wasm_import_module = "client-material")]
          extern "C" {
            #[cfg_attr(target_arch = "wasm32", link_name = "create")]
            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-material_create")]
            fn wit_import(
            _: i64, _: i64, _: i64, _: i64, _: i64, _: i64, _: i64, _: i64, _: i32, _: i32, );
          }
          wit_import(wit_bindgen::rt::as_i64(t2_0), wit_bindgen::rt::as_i64(t2_1), wit_bindgen::rt::as_i64(t4_0), wit_bindgen::rt::as_i64(t4_1), wit_bindgen::rt::as_i64(t6_0), wit_bindgen::rt::as_i64(t6_1), wit_bindgen::rt::as_i64(t8_0), wit_bindgen::rt::as_i64(t8_1), match transparent0 { true => 1, false => 0 }, ptr9);
          Handle{ulid:(*((ptr9 + 0) as *const i64) as u64, *((ptr9 + 8) as *const i64) as u64), }
        }
      }
      #[allow(clippy::all)]
      pub fn destroy(handle: Handle,){
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          let Handle{ ulid:ulid0, } = handle;
          let (t1_0, t1_1, ) = ulid0;
          
          #[link(wasm_import_module = "client-material")]
          extern "C" {
            #[cfg_attr(target_arch = "wasm32", link_name = "destroy")]
            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-material_destroy")]
            fn wit_import(
            _: i64, _: i64, );
          }
          wit_import(wit_bindgen::rt::as_i64(t1_0), wit_bindgen::rt::as_i64(t1_1));
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod component{
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::__link_section;
      
      pub type EntityId = super::types::EntityId;
      pub type Mat4 = super::types::Mat4;
      pub type Quat = super::types::Quat;
      pub type Vec2 = super::types::Vec2;
      pub type Vec3 = super::types::Vec3;
      pub type Vec4 = super::types::Vec4;
      pub type Uvec2 = super::types::Uvec2;
      pub type Uvec3 = super::types::Uvec3;
      pub type Uvec4 = super::types::Uvec4;
      pub type ProceduralMeshHandle = super::client_mesh::Handle;
      pub type ProceduralTextureHandle = super::client_texture::Handle;
      pub type ProceduralSamplerHandle = super::client_sampler::Handle;
      pub type ProceduralMaterialHandle = super::client_material::Handle;
      #[repr(u8)]
      #[derive(Clone, Copy, PartialEq, Eq)]
      pub enum QueryEvent {
        Frame,
        Spawn,
        Despawn,
      }
      impl core::fmt::Debug for QueryEvent {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
          match self {
            QueryEvent::Frame => {
              f.debug_tuple("QueryEvent::Frame").finish()
            }
            QueryEvent::Spawn => {
              f.debug_tuple("QueryEvent::Spawn").finish()
            }
            QueryEvent::Despawn => {
              f.debug_tuple("QueryEvent::Despawn").finish()
            }
          }
        }
      }
      #[derive(Clone)]
      pub struct QueryBuild<'a,> {
        pub components: &'a [u32],
        pub include: &'a [u32],
        pub exclude: &'a [u32],
        pub changed: &'a [u32],
      }
      impl<'a,> core::fmt::Debug for QueryBuild<'a,> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
          f.debug_struct("QueryBuild").field("components", &self.components).field("include", &self.include).field("exclude", &self.exclude).field("changed", &self.changed).finish()
        }
      }
      #[derive(Clone)]
      pub enum VecValue{
        TypeEmpty(wit_bindgen::rt::vec::Vec::<()>),
        TypeBool(wit_bindgen::rt::vec::Vec::<bool>),
        TypeEntityId(wit_bindgen::rt::vec::Vec::<EntityId>),
        TypeF32(wit_bindgen::rt::vec::Vec::<f32>),
        TypeF64(wit_bindgen::rt::vec::Vec::<f64>),
        TypeMat4(wit_bindgen::rt::vec::Vec::<Mat4>),
        TypeI32(wit_bindgen::rt::vec::Vec::<i32>),
        TypeQuat(wit_bindgen::rt::vec::Vec::<Quat>),
        TypeString(wit_bindgen::rt::vec::Vec::<wit_bindgen::rt::string::String>),
        TypeU8(wit_bindgen::rt::vec::Vec::<u8>),
        TypeU32(wit_bindgen::rt::vec::Vec::<u32>),
        TypeU64(wit_bindgen::rt::vec::Vec::<u64>),
        TypeVec2(wit_bindgen::rt::vec::Vec::<Vec2>),
        TypeVec3(wit_bindgen::rt::vec::Vec::<Vec3>),
        TypeVec4(wit_bindgen::rt::vec::Vec::<Vec4>),
        TypeUvec2(wit_bindgen::rt::vec::Vec::<Uvec2>),
        TypeUvec3(wit_bindgen::rt::vec::Vec::<Uvec3>),
        TypeUvec4(wit_bindgen::rt::vec::Vec::<Uvec4>),
        TypeProceduralMeshHandle(wit_bindgen::rt::vec::Vec::<ProceduralMeshHandle>),
        TypeProceduralTextureHandle(wit_bindgen::rt::vec::Vec::<ProceduralTextureHandle>),
        TypeProceduralSamplerHandle(wit_bindgen::rt::vec::Vec::<ProceduralSamplerHandle>),
        TypeProceduralMaterialHandle(wit_bindgen::rt::vec::Vec::<ProceduralMaterialHandle>),
      }
      impl core::fmt::Debug for VecValue {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
          match self {
            VecValue::TypeEmpty(e) => {
              f.debug_tuple("VecValue::TypeEmpty").field(e).finish()
            }
            VecValue::TypeBool(e) => {
              f.debug_tuple("VecValue::TypeBool").field(e).finish()
            }
            VecValue::TypeEntityId(e) => {
              f.debug_tuple("VecValue::TypeEntityId").field(e).finish()
            }
            VecValue::TypeF32(e) => {
              f.debug_tuple("VecValue::TypeF32").field(e).finish()
            }
            VecValue::TypeF64(e) => {
              f.debug_tuple("VecValue::TypeF64").field(e).finish()
            }
            VecValue::TypeMat4(e) => {
              f.debug_tuple("VecValue::TypeMat4").field(e).finish()
            }
            VecValue::TypeI32(e) => {
              f.debug_tuple("VecValue::TypeI32").field(e).finish()
            }
            VecValue::TypeQuat(e) => {
              f.debug_tuple("VecValue::TypeQuat").field(e).finish()
            }
            VecValue::TypeString(e) => {
              f.debug_tuple("VecValue::TypeString").field(e).finish()
            }
            VecValue::TypeU8(e) => {
              f.debug_tuple("VecValue::TypeU8").field(e).finish()
            }
            VecValue::TypeU32(e) => {
              f.debug_tuple("VecValue::TypeU32").field(e).finish()
            }
            VecValue::TypeU64(e) => {
              f.debug_tuple("VecValue::TypeU64").field(e).finish()
            }
            VecValue::TypeVec2(e) => {
              f.debug_tuple("VecValue::TypeVec2").field(e).finish()
            }
            VecValue::TypeVec3(e) => {
              f.debug_tuple("VecValue::TypeVec3").field(e).finish()
            }
            VecValue::TypeVec4(e) => {
              f.debug_tuple("VecValue::TypeVec4").field(e).finish()
            }
            VecValue::TypeUvec2(e) => {
              f.debug_tuple("VecValue::TypeUvec2").field(e).finish()
            }
            VecValue::TypeUvec3(e) => {
              f.debug_tuple("VecValue::TypeUvec3").field(e).finish()
            }
            VecValue::TypeUvec4(e) => {
              f.debug_tuple("VecValue::TypeUvec4").field(e).finish()
            }
            VecValue::TypeProceduralMeshHandle(e) => {
              f.debug_tuple("VecValue::TypeProceduralMeshHandle").field(e).finish()
            }
            VecValue::TypeProceduralTextureHandle(e) => {
              f.debug_tuple("VecValue::TypeProceduralTextureHandle").field(e).finish()
            }
            VecValue::TypeProceduralSamplerHandle(e) => {
              f.debug_tuple("VecValue::TypeProceduralSamplerHandle").field(e).finish()
            }
            VecValue::TypeProceduralMaterialHandle(e) => {
              f.debug_tuple("VecValue::TypeProceduralMaterialHandle").field(e).finish()
            }
          }
        }
      }
      #[derive(Clone)]
      pub enum OptionValue{
        TypeEmpty(Option<()>),
        TypeBool(Option<bool>),
        TypeEntityId(Option<EntityId>),
        TypeF32(Option<f32>),
        TypeF64(Option<f64>),
        TypeMat4(Option<Mat4>),
        TypeI32(Option<i32>),
        TypeQuat(Option<Quat>),
        TypeString(Option<wit_bindgen::rt::string::String>),
        TypeU8(Option<u8>),
        TypeU32(Option<u32>),
        TypeU64(Option<u64>),
        TypeVec2(Option<Vec2>),
        TypeVec3(Option<Vec3>),
        TypeVec4(Option<Vec4>),
        TypeUvec2(Option<Uvec2>),
        TypeUvec3(Option<Uvec3>),
        TypeUvec4(Option<Uvec4>),
        TypeProceduralMeshHandle(Option<ProceduralMeshHandle>),
        TypeProceduralTextureHandle(Option<ProceduralTextureHandle>),
        TypeProceduralSamplerHandle(Option<ProceduralSamplerHandle>),
        TypeProceduralMaterialHandle(Option<ProceduralMaterialHandle>),
      }
      impl core::fmt::Debug for OptionValue {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
          match self {
            OptionValue::TypeEmpty(e) => {
              f.debug_tuple("OptionValue::TypeEmpty").field(e).finish()
            }
            OptionValue::TypeBool(e) => {
              f.debug_tuple("OptionValue::TypeBool").field(e).finish()
            }
            OptionValue::TypeEntityId(e) => {
              f.debug_tuple("OptionValue::TypeEntityId").field(e).finish()
            }
            OptionValue::TypeF32(e) => {
              f.debug_tuple("OptionValue::TypeF32").field(e).finish()
            }
            OptionValue::TypeF64(e) => {
              f.debug_tuple("OptionValue::TypeF64").field(e).finish()
            }
            OptionValue::TypeMat4(e) => {
              f.debug_tuple("OptionValue::TypeMat4").field(e).finish()
            }
            OptionValue::TypeI32(e) => {
              f.debug_tuple("OptionValue::TypeI32").field(e).finish()
            }
            OptionValue::TypeQuat(e) => {
              f.debug_tuple("OptionValue::TypeQuat").field(e).finish()
            }
            OptionValue::TypeString(e) => {
              f.debug_tuple("OptionValue::TypeString").field(e).finish()
            }
            OptionValue::TypeU8(e) => {
              f.debug_tuple("OptionValue::TypeU8").field(e).finish()
            }
            OptionValue::TypeU32(e) => {
              f.debug_tuple("OptionValue::TypeU32").field(e).finish()
            }
            OptionValue::TypeU64(e) => {
              f.debug_tuple("OptionValue::TypeU64").field(e).finish()
            }
            OptionValue::TypeVec2(e) => {
              f.debug_tuple("OptionValue::TypeVec2").field(e).finish()
            }
            OptionValue::TypeVec3(e) => {
              f.debug_tuple("OptionValue::TypeVec3").field(e).finish()
            }
            OptionValue::TypeVec4(e) => {
              f.debug_tuple("OptionValue::TypeVec4").field(e).finish()
            }
            OptionValue::TypeUvec2(e) => {
              f.debug_tuple("OptionValue::TypeUvec2").field(e).finish()
            }
            OptionValue::TypeUvec3(e) => {
              f.debug_tuple("OptionValue::TypeUvec3").field(e).finish()
            }
            OptionValue::TypeUvec4(e) => {
              f.debug_tuple("OptionValue::TypeUvec4").field(e).finish()
            }
            OptionValue::TypeProceduralMeshHandle(e) => {
              f.debug_tuple("OptionValue::TypeProceduralMeshHandle").field(e).finish()
            }
            OptionValue::TypeProceduralTextureHandle(e) => {
              f.debug_tuple("OptionValue::TypeProceduralTextureHandle").field(e).finish()
            }
            OptionValue::TypeProceduralSamplerHandle(e) => {
              f.debug_tuple("OptionValue::TypeProceduralSamplerHandle").field(e).finish()
            }
            OptionValue::TypeProceduralMaterialHandle(e) => {
              f.debug_tuple("OptionValue::TypeProceduralMaterialHandle").field(e).finish()
            }
          }
        }
      }
      #[derive(Clone)]
      pub enum Value{
        TypeEmpty(()),
        TypeBool(bool),
        TypeEntityId(EntityId),
        TypeF32(f32),
        TypeF64(f64),
        TypeMat4(Mat4),
        TypeI32(i32),
        TypeQuat(Quat),
        TypeString(wit_bindgen::rt::string::String),
        TypeU8(u8),
        TypeU32(u32),
        TypeU64(u64),
        TypeVec2(Vec2),
        TypeVec3(Vec3),
        TypeVec4(Vec4),
        TypeUvec2(Uvec2),
        TypeUvec3(Uvec3),
        TypeUvec4(Uvec4),
        TypeProceduralMeshHandle(ProceduralMeshHandle),
        TypeProceduralTextureHandle(ProceduralTextureHandle),
        TypeProceduralSamplerHandle(ProceduralSamplerHandle),
        TypeProceduralMaterialHandle(ProceduralMaterialHandle),
        TypeVec(VecValue),
        TypeOption(OptionValue),
      }
      impl core::fmt::Debug for Value {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
          match self {
            Value::TypeEmpty(e) => {
              f.debug_tuple("Value::TypeEmpty").field(e).finish()
            }
            Value::TypeBool(e) => {
              f.debug_tuple("Value::TypeBool").field(e).finish()
            }
            Value::TypeEntityId(e) => {
              f.debug_tuple("Value::TypeEntityId").field(e).finish()
            }
            Value::TypeF32(e) => {
              f.debug_tuple("Value::TypeF32").field(e).finish()
            }
            Value::TypeF64(e) => {
              f.debug_tuple("Value::TypeF64").field(e).finish()
            }
            Value::TypeMat4(e) => {
              f.debug_tuple("Value::TypeMat4").field(e).finish()
            }
            Value::TypeI32(e) => {
              f.debug_tuple("Value::TypeI32").field(e).finish()
            }
            Value::TypeQuat(e) => {
              f.debug_tuple("Value::TypeQuat").field(e).finish()
            }
            Value::TypeString(e) => {
              f.debug_tuple("Value::TypeString").field(e).finish()
            }
            Value::TypeU8(e) => {
              f.debug_tuple("Value::TypeU8").field(e).finish()
            }
            Value::TypeU32(e) => {
              f.debug_tuple("Value::TypeU32").field(e).finish()
            }
            Value::TypeU64(e) => {
              f.debug_tuple("Value::TypeU64").field(e).finish()
            }
            Value::TypeVec2(e) => {
              f.debug_tuple("Value::TypeVec2").field(e).finish()
            }
            Value::TypeVec3(e) => {
              f.debug_tuple("Value::TypeVec3").field(e).finish()
            }
            Value::TypeVec4(e) => {
              f.debug_tuple("Value::TypeVec4").field(e).finish()
            }
            Value::TypeUvec2(e) => {
              f.debug_tuple("Value::TypeUvec2").field(e).finish()
            }
            Value::TypeUvec3(e) => {
              f.debug_tuple("Value::TypeUvec3").field(e).finish()
            }
            Value::TypeUvec4(e) => {
              f.debug_tuple("Value::TypeUvec4").field(e).finish()
            }
            Value::TypeProceduralMeshHandle(e) => {
              f.debug_tuple("Value::TypeProceduralMeshHandle").field(e).finish()
            }
            Value::TypeProceduralTextureHandle(e) => {
              f.debug_tuple("Value::TypeProceduralTextureHandle").field(e).finish()
            }
            Value::TypeProceduralSamplerHandle(e) => {
              f.debug_tuple("Value::TypeProceduralSamplerHandle").field(e).finish()
            }
            Value::TypeProceduralMaterialHandle(e) => {
              f.debug_tuple("Value::TypeProceduralMaterialHandle").field(e).finish()
            }
            Value::TypeVec(e) => {
              f.debug_tuple("Value::TypeVec").field(e).finish()
            }
            Value::TypeOption(e) => {
              f.debug_tuple("Value::TypeOption").field(e).finish()
            }
          }
        }
      }
      pub type Entity = wit_bindgen::rt::vec::Vec::<(u32,Value,)>;
      #[allow(clippy::all)]
      pub fn get_index(id: &str,) -> Option<u32>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 8]);
          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = id;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let ptr1 = ret_area.as_mut_ptr() as i32;
          #[link(wasm_import_module = "component")]
          extern "C" {
            #[cfg_attr(target_arch = "wasm32", link_name = "get-index")]
            #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_get-index")]
            fn wit_import(
            _: i32, _: i32, _: i32, );
          }
          wit_import(ptr0, len0, ptr1);
          match i32::from(*((ptr1 + 0) as *const u8)) {
            0 => None,
            1 => Some(*((ptr1 + 4) as *const i32) as u32),
            #[cfg(not(debug_assertions))]
            _ => core::hint::unreachable_unchecked(),
            #[cfg(debug_assertions)]
            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      #[allow(clippy::all)]
      pub fn get_component(entity: EntityId,index: u32,) -> Option<Value>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(8))]
          struct RetArea([u8; 96]);
          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
          let super::types::EntityId{ id0:id00, id1:id10, } = entity;
          let ptr1 = ret_area.as_mut_ptr() as i32;
          #[link(wasm_import_module = "component")]
          extern "C" {
            #[cfg_attr(target_arch = "wasm32", link_name = "get-component")]
            #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_get-component")]
            fn wit_import(
            _: i64, _: i64, _: i32, _: i32, );
          }
          wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_i32(index), ptr1);
          match i32::from(*((ptr1 + 0) as *const u8)) {
            0 => None,
            1 => Some({{match i32::from(*((ptr1 + 8) as *const u8)) {
              0 => Value::TypeEmpty(()),
              1 => Value::TypeBool({
                #[cfg(not(debug_assertions))]
                { core::mem::transmute::<u8, bool>(i32::from(*((ptr1 + 16) as *const u8)) as u8) }
                #[cfg(debug_assertions)]
                {
                  match i32::from(*((ptr1 + 16) as *const u8)) {
                    0 => false,
                    1 => true,
                    _ => panic!("invalid bool discriminant"),
                  }
                }
              }),
              2 => Value::TypeEntityId(super::types::EntityId{id0:*((ptr1 + 16) as *const i64) as u64, id1:*((ptr1 + 24) as *const i64) as u64, }),
              3 => Value::TypeF32(*((ptr1 + 16) as *const f32)),
              4 => Value::TypeF64(*((ptr1 + 16) as *const f64)),
              5 => Value::TypeMat4(super::types::Mat4{x:super::types::Vec4{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), z:*((ptr1 + 24) as *const f32), w:*((ptr1 + 28) as *const f32), }, y:super::types::Vec4{x:*((ptr1 + 32) as *const f32), y:*((ptr1 + 36) as *const f32), z:*((ptr1 + 40) as *const f32), w:*((ptr1 + 44) as *const f32), }, z:super::types::Vec4{x:*((ptr1 + 48) as *const f32), y:*((ptr1 + 52) as *const f32), z:*((ptr1 + 56) as *const f32), w:*((ptr1 + 60) as *const f32), }, w:super::types::Vec4{x:*((ptr1 + 64) as *const f32), y:*((ptr1 + 68) as *const f32), z:*((ptr1 + 72) as *const f32), w:*((ptr1 + 76) as *const f32), }, }),
              6 => Value::TypeI32(*((ptr1 + 16) as *const i32)),
              7 => Value::TypeQuat(super::types::Quat{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), z:*((ptr1 + 24) as *const f32), w:*((ptr1 + 28) as *const f32), }),
              8 => Value::TypeString({
                let len2 = *((ptr1 + 20) as *const i32) as usize;
                
                {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 16) as *const i32) as *mut _, len2, len2))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 16) as *const i32) as *mut _, len2, len2)).unwrap()}}
              }),
              9 => Value::TypeU8(i32::from(*((ptr1 + 16) as *const u8)) as u8),
              10 => Value::TypeU32(*((ptr1 + 16) as *const i32) as u32),
              11 => Value::TypeU64(*((ptr1 + 16) as *const i64) as u64),
              12 => Value::TypeVec2(super::types::Vec2{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), }),
              13 => Value::TypeVec3(super::types::Vec3{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), z:*((ptr1 + 24) as *const f32), }),
              14 => Value::TypeVec4(super::types::Vec4{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), z:*((ptr1 + 24) as *const f32), w:*((ptr1 + 28) as *const f32), }),
              15 => Value::TypeUvec2(super::types::Uvec2{x:*((ptr1 + 16) as *const i32) as u32, y:*((ptr1 + 20) as *const i32) as u32, }),
              16 => Value::TypeUvec3(super::types::Uvec3{x:*((ptr1 + 16) as *const i32) as u32, y:*((ptr1 + 20) as *const i32) as u32, z:*((ptr1 + 24) as *const i32) as u32, }),
              17 => Value::TypeUvec4(super::types::Uvec4{x:*((ptr1 + 16) as *const i32) as u32, y:*((ptr1 + 20) as *const i32) as u32, z:*((ptr1 + 24) as *const i32) as u32, w:*((ptr1 + 28) as *const i32) as u32, }),
              18 => Value::TypeProceduralMeshHandle(super::client_mesh::Handle{ulid:(*((ptr1 + 16) as *const i64) as u64, *((ptr1 + 24) as *const i64) as u64), }),
              19 => Value::TypeProceduralTextureHandle(super::client_texture::Handle{ulid:(*((ptr1 + 16) as *const i64) as u64, *((ptr1 + 24) as *const i64) as u64), }),
              20 => Value::TypeProceduralSamplerHandle(super::client_sampler::Handle{ulid:(*((ptr1 + 16) as *const i64) as u64, *((ptr1 + 24) as *const i64) as u64), }),
              21 => Value::TypeProceduralMaterialHandle(super::client_material::Handle{ulid:(*((ptr1 + 16) as *const i64) as u64, *((ptr1 + 24) as *const i64) as u64), }),
              22 => Value::TypeVec({{match i32::from(*((ptr1 + 16) as *const u8)) {
                0 => VecValue::TypeEmpty({
                  let len3 = *((ptr1 + 24) as *const i32) as usize;
                  
                  Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len3, len3)
                }),
                1 => VecValue::TypeBool({
                  let base4 = *((ptr1 + 20) as *const i32);
                  let len4 = *((ptr1 + 24) as *const i32);
                  let mut result4 = Vec::with_capacity(len4 as usize);
                  for i in 0..len4 {
                    let base = base4 + i *1;
                    result4.push({
                      #[cfg(not(debug_assertions))]
                      { core::mem::transmute::<u8, bool>(i32::from(*((base + 0) as *const u8)) as u8) }
                      #[cfg(debug_assertions)]
                      {
                        match i32::from(*((base + 0) as *const u8)) {
                          0 => false,
                          1 => true,
                          _ => panic!("invalid bool discriminant"),
                        }
                      }
                    });
                  }
                  wit_bindgen::rt::dealloc(base4, (len4 as usize) * 1, 1);
                  
                  result4
                }),
                2 => VecValue::TypeEntityId({
                  let len5 = *((ptr1 + 24) as *const i32) as usize;
                  
                  Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len5, len5)
                }),
                3 => VecValue::TypeF32({
                  let len6 = *((ptr1 + 24) as *const i32) as usize;
                  
                  Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len6, len6)
                }),
                4 => VecValue::TypeF64({
                  let len7 = *((ptr1 + 24) as *const i32) as usize;
                  
                  Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len7, len7)
                }),
                5 => VecValue::TypeMat4({
                  let len8 = *((ptr1 + 24) as *const i32) as usize;
                  
                  Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len8, len8)
                }),
                6 => VecValue::TypeI32({
                  let len9 = *((ptr1 + 24) as *const i32) as usize;
                  
                  Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len9, len9)
                }),
                7 => VecValue::TypeQuat({
                  let len10 = *((ptr1 + 24) as *const i32) as usize;
                  
                  Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len10, len10)
                }),
                8 => VecValue::TypeString({
                  let base12 = *((ptr1 + 20) as *const i32);
                  let len12 = *((ptr1 + 24) as *const i32);
                  let mut result12 = Vec::with_capacity(len12 as usize);
                  for i in 0..len12 {
                    let base = base12 + i *8;
                    result12.push({
                      let len11 = *((base + 4) as *const i32) as usize;
                      
                      {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len11, len11))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len11, len11)).unwrap()}}
                    });
                  }
                  wit_bindgen::rt::dealloc(base12, (len12 as usize) * 8, 4);
                  
                  result12
                }),
                9 => VecValue::TypeU8({
                  let len13 = *((ptr1 + 24) as *const i32) as usize;
                  
                  Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len13, len13)
                }),
                10 => VecValue::TypeU32({
                  let len14 = *((ptr1 + 24) as *const i32) as usize;
                  
                  Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len14, len14)
                }),
                11 => VecValue::TypeU64({
                  let len15 = *((ptr1 + 24) as *const i32) as usize;
                  
                  Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len15, len15)
                }),
                12 => VecValue::TypeVec2({
                  let len16 = *((ptr1 + 24) as *const i32) as usize;
                  
                  Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len16, len16)
                }),
                13 => VecValue::TypeVec3({
                  let len17 = *((ptr1 + 24) as *const i32) as usize;
                  
                  Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len17, len17)
                }),
                14 => VecValue::TypeVec4({
                  let len18 = *((ptr1 + 24) as *const i32) as usize;
                  
                  Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len18, len18)
                }),
                15 => VecValue::TypeUvec2({
                  let len19 = *((ptr1 + 24) as *const i32) as usize;
                  
                  Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len19, len19)
                }),
                16 => VecValue::TypeUvec3({
                  let len20 = *((ptr1 + 24) as *const i32) as usize;
                  
                  Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len20, len20)
                }),
                17 => VecValue::TypeUvec4({
                  let len21 = *((ptr1 + 24) as *const i32) as usize;
                  
                  Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len21, len21)
                }),
                18 => VecValue::TypeProceduralMeshHandle({
                  let len22 = *((ptr1 + 24) as *const i32) as usize;
                  
                  Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len22, len22)
                }),
                19 => VecValue::TypeProceduralTextureHandle({
                  let len23 = *((ptr1 + 24) as *const i32) as usize;
                  
                  Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len23, len23)
                }),
                20 => VecValue::TypeProceduralSamplerHandle({
                  let len24 = *((ptr1 + 24) as *const i32) as usize;
                  
                  Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len24, len24)
                }),
                #[cfg(debug_assertions)]21 => VecValue::TypeProceduralMaterialHandle({
                  let len25 = *((ptr1 + 24) as *const i32) as usize;
                  
                  Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len25, len25)
                }),
                #[cfg(not(debug_assertions))]_ => VecValue::TypeProceduralMaterialHandle({
                  let len25 = *((ptr1 + 24) as *const i32) as usize;
                  
                  Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len25, len25)
                }),
                #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
              }}}),
              #[cfg(debug_assertions)]23 => Value::TypeOption({{match i32::from(*((ptr1 + 16) as *const u8)) {
                0 => OptionValue::TypeEmpty(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(()),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                1 => OptionValue::TypeBool(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some({
                    #[cfg(not(debug_assertions))]
                    { core::mem::transmute::<u8, bool>(i32::from(*((ptr1 + 25) as *const u8)) as u8) }
                    #[cfg(debug_assertions)]
                    {
                      match i32::from(*((ptr1 + 25) as *const u8)) {
                        0 => false,
                        1 => true,
                        _ => panic!("invalid bool discriminant"),
                      }
                    }
                  }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                2 => OptionValue::TypeEntityId(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::types::EntityId{id0:*((ptr1 + 32) as *const i64) as u64, id1:*((ptr1 + 40) as *const i64) as u64, }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                3 => OptionValue::TypeF32(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(*((ptr1 + 28) as *const f32)),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                4 => OptionValue::TypeF64(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(*((ptr1 + 32) as *const f64)),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                5 => OptionValue::TypeMat4(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::types::Mat4{x:super::types::Vec4{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }, y:super::types::Vec4{x:*((ptr1 + 44) as *const f32), y:*((ptr1 + 48) as *const f32), z:*((ptr1 + 52) as *const f32), w:*((ptr1 + 56) as *const f32), }, z:super::types::Vec4{x:*((ptr1 + 60) as *const f32), y:*((ptr1 + 64) as *const f32), z:*((ptr1 + 68) as *const f32), w:*((ptr1 + 72) as *const f32), }, w:super::types::Vec4{x:*((ptr1 + 76) as *const f32), y:*((ptr1 + 80) as *const f32), z:*((ptr1 + 84) as *const f32), w:*((ptr1 + 88) as *const f32), }, }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                6 => OptionValue::TypeI32(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(*((ptr1 + 28) as *const i32)),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                7 => OptionValue::TypeQuat(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::types::Quat{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                8 => OptionValue::TypeString(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some({
                    let len26 = *((ptr1 + 32) as *const i32) as usize;
                    
                    {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 28) as *const i32) as *mut _, len26, len26))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 28) as *const i32) as *mut _, len26, len26)).unwrap()}}
                  }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                9 => OptionValue::TypeU8(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(i32::from(*((ptr1 + 25) as *const u8)) as u8),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                10 => OptionValue::TypeU32(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(*((ptr1 + 28) as *const i32) as u32),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                11 => OptionValue::TypeU64(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(*((ptr1 + 32) as *const i64) as u64),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                12 => OptionValue::TypeVec2(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::types::Vec2{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                13 => OptionValue::TypeVec3(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::types::Vec3{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                14 => OptionValue::TypeVec4(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::types::Vec4{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                15 => OptionValue::TypeUvec2(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::types::Uvec2{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                16 => OptionValue::TypeUvec3(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::types::Uvec3{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, z:*((ptr1 + 36) as *const i32) as u32, }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                17 => OptionValue::TypeUvec4(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::types::Uvec4{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, z:*((ptr1 + 36) as *const i32) as u32, w:*((ptr1 + 40) as *const i32) as u32, }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                18 => OptionValue::TypeProceduralMeshHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::client_mesh::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                19 => OptionValue::TypeProceduralTextureHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::client_texture::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                20 => OptionValue::TypeProceduralSamplerHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::client_sampler::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                #[cfg(debug_assertions)]21 => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::client_material::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                #[cfg(not(debug_assertions))]_ => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::client_material::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
              }}}),
              #[cfg(not(debug_assertions))]_ => Value::TypeOption({{match i32::from(*((ptr1 + 16) as *const u8)) {
                0 => OptionValue::TypeEmpty(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(()),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                1 => OptionValue::TypeBool(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some({
                    #[cfg(not(debug_assertions))]
                    { core::mem::transmute::<u8, bool>(i32::from(*((ptr1 + 25) as *const u8)) as u8) }
                    #[cfg(debug_assertions)]
                    {
                      match i32::from(*((ptr1 + 25) as *const u8)) {
                        0 => false,
                        1 => true,
                        _ => panic!("invalid bool discriminant"),
                      }
                    }
                  }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                2 => OptionValue::TypeEntityId(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::types::EntityId{id0:*((ptr1 + 32) as *const i64) as u64, id1:*((ptr1 + 40) as *const i64) as u64, }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                3 => OptionValue::TypeF32(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(*((ptr1 + 28) as *const f32)),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                4 => OptionValue::TypeF64(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(*((ptr1 + 32) as *const f64)),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                5 => OptionValue::TypeMat4(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::types::Mat4{x:super::types::Vec4{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }, y:super::types::Vec4{x:*((ptr1 + 44) as *const f32), y:*((ptr1 + 48) as *const f32), z:*((ptr1 + 52) as *const f32), w:*((ptr1 + 56) as *const f32), }, z:super::types::Vec4{x:*((ptr1 + 60) as *const f32), y:*((ptr1 + 64) as *const f32), z:*((ptr1 + 68) as *const f32), w:*((ptr1 + 72) as *const f32), }, w:super::types::Vec4{x:*((ptr1 + 76) as *const f32), y:*((ptr1 + 80) as *const f32), z:*((ptr1 + 84) as *const f32), w:*((ptr1 + 88) as *const f32), }, }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                6 => OptionValue::TypeI32(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(*((ptr1 + 28) as *const i32)),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                7 => OptionValue::TypeQuat(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::types::Quat{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                8 => OptionValue::TypeString(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some({
                    let len26 = *((ptr1 + 32) as *const i32) as usize;
                    
                    {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 28) as *const i32) as *mut _, len26, len26))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 28) as *const i32) as *mut _, len26, len26)).unwrap()}}
                  }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                9 => OptionValue::TypeU8(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(i32::from(*((ptr1 + 25) as *const u8)) as u8),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                10 => OptionValue::TypeU32(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(*((ptr1 + 28) as *const i32) as u32),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                11 => OptionValue::TypeU64(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(*((ptr1 + 32) as *const i64) as u64),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                12 => OptionValue::TypeVec2(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::types::Vec2{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                13 => OptionValue::TypeVec3(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::types::Vec3{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                14 => OptionValue::TypeVec4(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::types::Vec4{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                15 => OptionValue::TypeUvec2(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::types::Uvec2{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                16 => OptionValue::TypeUvec3(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::types::Uvec3{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, z:*((ptr1 + 36) as *const i32) as u32, }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                17 => OptionValue::TypeUvec4(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::types::Uvec4{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, z:*((ptr1 + 36) as *const i32) as u32, w:*((ptr1 + 40) as *const i32) as u32, }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                18 => OptionValue::TypeProceduralMeshHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::client_mesh::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                19 => OptionValue::TypeProceduralTextureHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::client_texture::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                20 => OptionValue::TypeProceduralSamplerHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::client_sampler::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                #[cfg(debug_assertions)]21 => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::client_material::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                #[cfg(not(debug_assertions))]_ => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                  0 => None,
                  1 => Some(super::client_material::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                  #[cfg(not(debug_assertions))]
                  _ => core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
              }}}),
              #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
            }}}),
            #[cfg(not(debug_assertions))]
            _ => core::hint::unreachable_unchecked(),
            #[cfg(debug_assertions)]
            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      #[allow(clippy::all)]
      pub fn add_component(entity: EntityId,index: u32,value: &Value,){
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          let mut cleanup_list = Vec::new();
          
          #[repr(align(8))]
          struct RetArea([u8; 112]);
          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
          let ptr0 = ret_area.as_mut_ptr() as i32;let super::types::EntityId{ id0:id01, id1:id11, } = entity;
          *((ptr0 + 0) as *mut i64) = wit_bindgen::rt::as_i64(id01);
          *((ptr0 + 8) as *mut i64) = wit_bindgen::rt::as_i64(id11);
          *((ptr0 + 16) as *mut i32) = wit_bindgen::rt::as_i32(index);
          match value {
            Value::TypeEmpty(e) => {
              *((ptr0 + 24) as *mut u8) = (0i32) as u8;
              let () = e;
              
            },
            Value::TypeBool(e) => {
              *((ptr0 + 24) as *mut u8) = (1i32) as u8;
              *((ptr0 + 32) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
              
            },
            Value::TypeEntityId(e) => {
              *((ptr0 + 24) as *mut u8) = (2i32) as u8;
              let super::types::EntityId{ id0:id03, id1:id13, } = e;
              *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(id03);
              *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(id13);
              
            },
            Value::TypeF32(e) => {
              *((ptr0 + 24) as *mut u8) = (3i32) as u8;
              *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(e);
              
            },
            Value::TypeF64(e) => {
              *((ptr0 + 24) as *mut u8) = (4i32) as u8;
              *((ptr0 + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
              
            },
            Value::TypeMat4(e) => {
              *((ptr0 + 24) as *mut u8) = (5i32) as u8;
              let super::types::Mat4{ x:x4, y:y4, z:z4, w:w4, } = e;
              let super::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = x4;
              *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x5);
              *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y5);
              *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z5);
              *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w5);
              let super::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = y4;
              *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(x6);
              *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(y6);
              *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(z6);
              *((ptr0 + 60) as *mut f32) = wit_bindgen::rt::as_f32(w6);
              let super::types::Vec4{ x:x7, y:y7, z:z7, w:w7, } = z4;
              *((ptr0 + 64) as *mut f32) = wit_bindgen::rt::as_f32(x7);
              *((ptr0 + 68) as *mut f32) = wit_bindgen::rt::as_f32(y7);
              *((ptr0 + 72) as *mut f32) = wit_bindgen::rt::as_f32(z7);
              *((ptr0 + 76) as *mut f32) = wit_bindgen::rt::as_f32(w7);
              let super::types::Vec4{ x:x8, y:y8, z:z8, w:w8, } = w4;
              *((ptr0 + 80) as *mut f32) = wit_bindgen::rt::as_f32(x8);
              *((ptr0 + 84) as *mut f32) = wit_bindgen::rt::as_f32(y8);
              *((ptr0 + 88) as *mut f32) = wit_bindgen::rt::as_f32(z8);
              *((ptr0 + 92) as *mut f32) = wit_bindgen::rt::as_f32(w8);
              
            },
            Value::TypeI32(e) => {
              *((ptr0 + 24) as *mut u8) = (6i32) as u8;
              *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(e);
              
            },
            Value::TypeQuat(e) => {
              *((ptr0 + 24) as *mut u8) = (7i32) as u8;
              let super::types::Quat{ x:x9, y:y9, z:z9, w:w9, } = e;
              *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x9);
              *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y9);
              *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z9);
              *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w9);
              
            },
            Value::TypeString(e) => {
              *((ptr0 + 24) as *mut u8) = (8i32) as u8;
              let vec10 = e;
              let ptr10 = vec10.as_ptr() as i32;
              let len10 = vec10.len() as i32;
              *((ptr0 + 36) as *mut i32) = len10;
              *((ptr0 + 32) as *mut i32) = ptr10;
              
            },
            Value::TypeU8(e) => {
              *((ptr0 + 24) as *mut u8) = (9i32) as u8;
              *((ptr0 + 32) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
              
            },
            Value::TypeU32(e) => {
              *((ptr0 + 24) as *mut u8) = (10i32) as u8;
              *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(e);
              
            },
            Value::TypeU64(e) => {
              *((ptr0 + 24) as *mut u8) = (11i32) as u8;
              *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
              
            },
            Value::TypeVec2(e) => {
              *((ptr0 + 24) as *mut u8) = (12i32) as u8;
              let super::types::Vec2{ x:x11, y:y11, } = e;
              *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x11);
              *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y11);
              
            },
            Value::TypeVec3(e) => {
              *((ptr0 + 24) as *mut u8) = (13i32) as u8;
              let super::types::Vec3{ x:x12, y:y12, z:z12, } = e;
              *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x12);
              *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y12);
              *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z12);
              
            },
            Value::TypeVec4(e) => {
              *((ptr0 + 24) as *mut u8) = (14i32) as u8;
              let super::types::Vec4{ x:x13, y:y13, z:z13, w:w13, } = e;
              *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x13);
              *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y13);
              *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z13);
              *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w13);
              
            },
            Value::TypeUvec2(e) => {
              *((ptr0 + 24) as *mut u8) = (15i32) as u8;
              let super::types::Uvec2{ x:x14, y:y14, } = e;
              *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x14);
              *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y14);
              
            },
            Value::TypeUvec3(e) => {
              *((ptr0 + 24) as *mut u8) = (16i32) as u8;
              let super::types::Uvec3{ x:x15, y:y15, z:z15, } = e;
              *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x15);
              *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y15);
              *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z15);
              
            },
            Value::TypeUvec4(e) => {
              *((ptr0 + 24) as *mut u8) = (17i32) as u8;
              let super::types::Uvec4{ x:x16, y:y16, z:z16, w:w16, } = e;
              *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x16);
              *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y16);
              *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z16);
              *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(w16);
              
            },
            Value::TypeProceduralMeshHandle(e) => {
              *((ptr0 + 24) as *mut u8) = (18i32) as u8;
              let super::client_mesh::Handle{ ulid:ulid17, } = e;
              let (t18_0, t18_1, ) = ulid17;
              *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t18_0);
              *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t18_1);
              
            },
            Value::TypeProceduralTextureHandle(e) => {
              *((ptr0 + 24) as *mut u8) = (19i32) as u8;
              let super::client_texture::Handle{ ulid:ulid19, } = e;
              let (t20_0, t20_1, ) = ulid19;
              *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t20_0);
              *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t20_1);
              
            },
            Value::TypeProceduralSamplerHandle(e) => {
              *((ptr0 + 24) as *mut u8) = (20i32) as u8;
              let super::client_sampler::Handle{ ulid:ulid21, } = e;
              let (t22_0, t22_1, ) = ulid21;
              *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t22_0);
              *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t22_1);
              
            },
            Value::TypeProceduralMaterialHandle(e) => {
              *((ptr0 + 24) as *mut u8) = (21i32) as u8;
              let super::client_material::Handle{ ulid:ulid23, } = e;
              let (t24_0, t24_1, ) = ulid23;
              *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t24_0);
              *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t24_1);
              
            },
            Value::TypeVec(e) => {
              *((ptr0 + 24) as *mut u8) = (22i32) as u8;
              match e {
                VecValue::TypeEmpty(e) => {
                  *((ptr0 + 32) as *mut u8) = (0i32) as u8;
                  let vec25 = e;
                  let ptr25 = vec25.as_ptr() as i32;
                  let len25 = vec25.len() as i32;
                  *((ptr0 + 40) as *mut i32) = len25;
                  *((ptr0 + 36) as *mut i32) = ptr25;
                  
                },
                VecValue::TypeBool(e) => {
                  *((ptr0 + 32) as *mut u8) = (1i32) as u8;
                  let vec26 = e;
                  let len26 = vec26.len() as i32;
                  let layout26 = alloc::Layout::from_size_align_unchecked(vec26.len() * 1, 1);
                  let result26 = if layout26.size() != 0
                  {
                    let ptr = alloc::alloc(layout26);
                    if ptr.is_null()
                    {
                      alloc::handle_alloc_error(layout26);
                    }
                    ptr
                  }else {
                    core::ptr::null_mut()
                  };
                  for (i, e) in vec26.into_iter().enumerate() {
                    let base = result26 as i32 + (i as i32) * 1;
                    {
                      *((base + 0) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                      
                    }}
                    *((ptr0 + 40) as *mut i32) = len26;
                    *((ptr0 + 36) as *mut i32) = result26 as i32;
                    cleanup_list.extend_from_slice(&[(result26, layout26),]);
                    
                  },
                  VecValue::TypeEntityId(e) => {
                    *((ptr0 + 32) as *mut u8) = (2i32) as u8;
                    let vec27 = e;
                    let ptr27 = vec27.as_ptr() as i32;
                    let len27 = vec27.len() as i32;
                    *((ptr0 + 40) as *mut i32) = len27;
                    *((ptr0 + 36) as *mut i32) = ptr27;
                    
                  },
                  VecValue::TypeF32(e) => {
                    *((ptr0 + 32) as *mut u8) = (3i32) as u8;
                    let vec28 = e;
                    let ptr28 = vec28.as_ptr() as i32;
                    let len28 = vec28.len() as i32;
                    *((ptr0 + 40) as *mut i32) = len28;
                    *((ptr0 + 36) as *mut i32) = ptr28;
                    
                  },
                  VecValue::TypeF64(e) => {
                    *((ptr0 + 32) as *mut u8) = (4i32) as u8;
                    let vec29 = e;
                    let ptr29 = vec29.as_ptr() as i32;
                    let len29 = vec29.len() as i32;
                    *((ptr0 + 40) as *mut i32) = len29;
                    *((ptr0 + 36) as *mut i32) = ptr29;
                    
                  },
                  VecValue::TypeMat4(e) => {
                    *((ptr0 + 32) as *mut u8) = (5i32) as u8;
                    let vec30 = e;
                    let ptr30 = vec30.as_ptr() as i32;
                    let len30 = vec30.len() as i32;
                    *((ptr0 + 40) as *mut i32) = len30;
                    *((ptr0 + 36) as *mut i32) = ptr30;
                    
                  },
                  VecValue::TypeI32(e) => {
                    *((ptr0 + 32) as *mut u8) = (6i32) as u8;
                    let vec31 = e;
                    let ptr31 = vec31.as_ptr() as i32;
                    let len31 = vec31.len() as i32;
                    *((ptr0 + 40) as *mut i32) = len31;
                    *((ptr0 + 36) as *mut i32) = ptr31;
                    
                  },
                  VecValue::TypeQuat(e) => {
                    *((ptr0 + 32) as *mut u8) = (7i32) as u8;
                    let vec32 = e;
                    let ptr32 = vec32.as_ptr() as i32;
                    let len32 = vec32.len() as i32;
                    *((ptr0 + 40) as *mut i32) = len32;
                    *((ptr0 + 36) as *mut i32) = ptr32;
                    
                  },
                  VecValue::TypeString(e) => {
                    *((ptr0 + 32) as *mut u8) = (8i32) as u8;
                    let vec34 = e;
                    let len34 = vec34.len() as i32;
                    let layout34 = alloc::Layout::from_size_align_unchecked(vec34.len() * 8, 4);
                    let result34 = if layout34.size() != 0
                    {
                      let ptr = alloc::alloc(layout34);
                      if ptr.is_null()
                      {
                        alloc::handle_alloc_error(layout34);
                      }
                      ptr
                    }else {
                      core::ptr::null_mut()
                    };
                    for (i, e) in vec34.into_iter().enumerate() {
                      let base = result34 as i32 + (i as i32) * 8;
                      {
                        let vec33 = e;
                        let ptr33 = vec33.as_ptr() as i32;
                        let len33 = vec33.len() as i32;
                        *((base + 4) as *mut i32) = len33;
                        *((base + 0) as *mut i32) = ptr33;
                        
                      }}
                      *((ptr0 + 40) as *mut i32) = len34;
                      *((ptr0 + 36) as *mut i32) = result34 as i32;
                      cleanup_list.extend_from_slice(&[(result34, layout34),]);
                      
                    },
                    VecValue::TypeU8(e) => {
                      *((ptr0 + 32) as *mut u8) = (9i32) as u8;
                      let vec35 = e;
                      let ptr35 = vec35.as_ptr() as i32;
                      let len35 = vec35.len() as i32;
                      *((ptr0 + 40) as *mut i32) = len35;
                      *((ptr0 + 36) as *mut i32) = ptr35;
                      
                    },
                    VecValue::TypeU32(e) => {
                      *((ptr0 + 32) as *mut u8) = (10i32) as u8;
                      let vec36 = e;
                      let ptr36 = vec36.as_ptr() as i32;
                      let len36 = vec36.len() as i32;
                      *((ptr0 + 40) as *mut i32) = len36;
                      *((ptr0 + 36) as *mut i32) = ptr36;
                      
                    },
                    VecValue::TypeU64(e) => {
                      *((ptr0 + 32) as *mut u8) = (11i32) as u8;
                      let vec37 = e;
                      let ptr37 = vec37.as_ptr() as i32;
                      let len37 = vec37.len() as i32;
                      *((ptr0 + 40) as *mut i32) = len37;
                      *((ptr0 + 36) as *mut i32) = ptr37;
                      
                    },
                    VecValue::TypeVec2(e) => {
                      *((ptr0 + 32) as *mut u8) = (12i32) as u8;
                      let vec38 = e;
                      let ptr38 = vec38.as_ptr() as i32;
                      let len38 = vec38.len() as i32;
                      *((ptr0 + 40) as *mut i32) = len38;
                      *((ptr0 + 36) as *mut i32) = ptr38;
                      
                    },
                    VecValue::TypeVec3(e) => {
                      *((ptr0 + 32) as *mut u8) = (13i32) as u8;
                      let vec39 = e;
                      let ptr39 = vec39.as_ptr() as i32;
                      let len39 = vec39.len() as i32;
                      *((ptr0 + 40) as *mut i32) = len39;
                      *((ptr0 + 36) as *mut i32) = ptr39;
                      
                    },
                    VecValue::TypeVec4(e) => {
                      *((ptr0 + 32) as *mut u8) = (14i32) as u8;
                      let vec40 = e;
                      let ptr40 = vec40.as_ptr() as i32;
                      let len40 = vec40.len() as i32;
                      *((ptr0 + 40) as *mut i32) = len40;
                      *((ptr0 + 36) as *mut i32) = ptr40;
                      
                    },
                    VecValue::TypeUvec2(e) => {
                      *((ptr0 + 32) as *mut u8) = (15i32) as u8;
                      let vec41 = e;
                      let ptr41 = vec41.as_ptr() as i32;
                      let len41 = vec41.len() as i32;
                      *((ptr0 + 40) as *mut i32) = len41;
                      *((ptr0 + 36) as *mut i32) = ptr41;
                      
                    },
                    VecValue::TypeUvec3(e) => {
                      *((ptr0 + 32) as *mut u8) = (16i32) as u8;
                      let vec42 = e;
                      let ptr42 = vec42.as_ptr() as i32;
                      let len42 = vec42.len() as i32;
                      *((ptr0 + 40) as *mut i32) = len42;
                      *((ptr0 + 36) as *mut i32) = ptr42;
                      
                    },
                    VecValue::TypeUvec4(e) => {
                      *((ptr0 + 32) as *mut u8) = (17i32) as u8;
                      let vec43 = e;
                      let ptr43 = vec43.as_ptr() as i32;
                      let len43 = vec43.len() as i32;
                      *((ptr0 + 40) as *mut i32) = len43;
                      *((ptr0 + 36) as *mut i32) = ptr43;
                      
                    },
                    VecValue::TypeProceduralMeshHandle(e) => {
                      *((ptr0 + 32) as *mut u8) = (18i32) as u8;
                      let vec44 = e;
                      let ptr44 = vec44.as_ptr() as i32;
                      let len44 = vec44.len() as i32;
                      *((ptr0 + 40) as *mut i32) = len44;
                      *((ptr0 + 36) as *mut i32) = ptr44;
                      
                    },
                    VecValue::TypeProceduralTextureHandle(e) => {
                      *((ptr0 + 32) as *mut u8) = (19i32) as u8;
                      let vec45 = e;
                      let ptr45 = vec45.as_ptr() as i32;
                      let len45 = vec45.len() as i32;
                      *((ptr0 + 40) as *mut i32) = len45;
                      *((ptr0 + 36) as *mut i32) = ptr45;
                      
                    },
                    VecValue::TypeProceduralSamplerHandle(e) => {
                      *((ptr0 + 32) as *mut u8) = (20i32) as u8;
                      let vec46 = e;
                      let ptr46 = vec46.as_ptr() as i32;
                      let len46 = vec46.len() as i32;
                      *((ptr0 + 40) as *mut i32) = len46;
                      *((ptr0 + 36) as *mut i32) = ptr46;
                      
                    },
                    VecValue::TypeProceduralMaterialHandle(e) => {
                      *((ptr0 + 32) as *mut u8) = (21i32) as u8;
                      let vec47 = e;
                      let ptr47 = vec47.as_ptr() as i32;
                      let len47 = vec47.len() as i32;
                      *((ptr0 + 40) as *mut i32) = len47;
                      *((ptr0 + 36) as *mut i32) = ptr47;
                      
                    },
                  };
                  
                },
                Value::TypeOption(e) => {
                  *((ptr0 + 24) as *mut u8) = (23i32) as u8;
                  match e {
                    OptionValue::TypeEmpty(e) => {
                      *((ptr0 + 32) as *mut u8) = (0i32) as u8;
                      match e {
                        Some(e) => {
                          *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                          let () = e;
                          
                        },
                        None => {
                          {
                            *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                            
                          }
                        },
                      };
                    },
                    OptionValue::TypeBool(e) => {
                      *((ptr0 + 32) as *mut u8) = (1i32) as u8;
                      match e {
                        Some(e) => {
                          *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                          *((ptr0 + 41) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                          
                        },
                        None => {
                          {
                            *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                            
                          }
                        },
                      };
                    },
                    OptionValue::TypeEntityId(e) => {
                      *((ptr0 + 32) as *mut u8) = (2i32) as u8;
                      match e {
                        Some(e) => {
                          *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                          let super::types::EntityId{ id0:id049, id1:id149, } = e;
                          *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(id049);
                          *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(id149);
                          
                        },
                        None => {
                          {
                            *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                            
                          }
                        },
                      };
                    },
                    OptionValue::TypeF32(e) => {
                      *((ptr0 + 32) as *mut u8) = (3i32) as u8;
                      match e {
                        Some(e) => {
                          *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                          *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(e);
                          
                        },
                        None => {
                          {
                            *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                            
                          }
                        },
                      };
                    },
                    OptionValue::TypeF64(e) => {
                      *((ptr0 + 32) as *mut u8) = (4i32) as u8;
                      match e {
                        Some(e) => {
                          *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                          *((ptr0 + 48) as *mut f64) = wit_bindgen::rt::as_f64(e);
                          
                        },
                        None => {
                          {
                            *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                            
                          }
                        },
                      };
                    },
                    OptionValue::TypeMat4(e) => {
                      *((ptr0 + 32) as *mut u8) = (5i32) as u8;
                      match e {
                        Some(e) => {
                          *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                          let super::types::Mat4{ x:x50, y:y50, z:z50, w:w50, } = e;
                          let super::types::Vec4{ x:x51, y:y51, z:z51, w:w51, } = x50;
                          *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x51);
                          *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y51);
                          *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z51);
                          *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w51);
                          let super::types::Vec4{ x:x52, y:y52, z:z52, w:w52, } = y50;
                          *((ptr0 + 60) as *mut f32) = wit_bindgen::rt::as_f32(x52);
                          *((ptr0 + 64) as *mut f32) = wit_bindgen::rt::as_f32(y52);
                          *((ptr0 + 68) as *mut f32) = wit_bindgen::rt::as_f32(z52);
                          *((ptr0 + 72) as *mut f32) = wit_bindgen::rt::as_f32(w52);
                          let super::types::Vec4{ x:x53, y:y53, z:z53, w:w53, } = z50;
                          *((ptr0 + 76) as *mut f32) = wit_bindgen::rt::as_f32(x53);
                          *((ptr0 + 80) as *mut f32) = wit_bindgen::rt::as_f32(y53);
                          *((ptr0 + 84) as *mut f32) = wit_bindgen::rt::as_f32(z53);
                          *((ptr0 + 88) as *mut f32) = wit_bindgen::rt::as_f32(w53);
                          let super::types::Vec4{ x:x54, y:y54, z:z54, w:w54, } = w50;
                          *((ptr0 + 92) as *mut f32) = wit_bindgen::rt::as_f32(x54);
                          *((ptr0 + 96) as *mut f32) = wit_bindgen::rt::as_f32(y54);
                          *((ptr0 + 100) as *mut f32) = wit_bindgen::rt::as_f32(z54);
                          *((ptr0 + 104) as *mut f32) = wit_bindgen::rt::as_f32(w54);
                          
                        },
                        None => {
                          {
                            *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                            
                          }
                        },
                      };
                    },
                    OptionValue::TypeI32(e) => {
                      *((ptr0 + 32) as *mut u8) = (6i32) as u8;
                      match e {
                        Some(e) => {
                          *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                          *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(e);
                          
                        },
                        None => {
                          {
                            *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                            
                          }
                        },
                      };
                    },
                    OptionValue::TypeQuat(e) => {
                      *((ptr0 + 32) as *mut u8) = (7i32) as u8;
                      match e {
                        Some(e) => {
                          *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                          let super::types::Quat{ x:x55, y:y55, z:z55, w:w55, } = e;
                          *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x55);
                          *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y55);
                          *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z55);
                          *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w55);
                          
                        },
                        None => {
                          {
                            *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                            
                          }
                        },
                      };
                    },
                    OptionValue::TypeString(e) => {
                      *((ptr0 + 32) as *mut u8) = (8i32) as u8;
                      match e {
                        Some(e) => {
                          *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                          let vec56 = e;
                          let ptr56 = vec56.as_ptr() as i32;
                          let len56 = vec56.len() as i32;
                          *((ptr0 + 48) as *mut i32) = len56;
                          *((ptr0 + 44) as *mut i32) = ptr56;
                          
                        },
                        None => {
                          {
                            *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                            
                          }
                        },
                      };
                    },
                    OptionValue::TypeU8(e) => {
                      *((ptr0 + 32) as *mut u8) = (9i32) as u8;
                      match e {
                        Some(e) => {
                          *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                          *((ptr0 + 41) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                          
                        },
                        None => {
                          {
                            *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                            
                          }
                        },
                      };
                    },
                    OptionValue::TypeU32(e) => {
                      *((ptr0 + 32) as *mut u8) = (10i32) as u8;
                      match e {
                        Some(e) => {
                          *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                          *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(e);
                          
                        },
                        None => {
                          {
                            *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                            
                          }
                        },
                      };
                    },
                    OptionValue::TypeU64(e) => {
                      *((ptr0 + 32) as *mut u8) = (11i32) as u8;
                      match e {
                        Some(e) => {
                          *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                          *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(e);
                          
                        },
                        None => {
                          {
                            *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                            
                          }
                        },
                      };
                    },
                    OptionValue::TypeVec2(e) => {
                      *((ptr0 + 32) as *mut u8) = (12i32) as u8;
                      match e {
                        Some(e) => {
                          *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                          let super::types::Vec2{ x:x57, y:y57, } = e;
                          *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x57);
                          *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y57);
                          
                        },
                        None => {
                          {
                            *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                            
                          }
                        },
                      };
                    },
                    OptionValue::TypeVec3(e) => {
                      *((ptr0 + 32) as *mut u8) = (13i32) as u8;
                      match e {
                        Some(e) => {
                          *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                          let super::types::Vec3{ x:x58, y:y58, z:z58, } = e;
                          *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x58);
                          *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y58);
                          *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z58);
                          
                        },
                        None => {
                          {
                            *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                            
                          }
                        },
                      };
                    },
                    OptionValue::TypeVec4(e) => {
                      *((ptr0 + 32) as *mut u8) = (14i32) as u8;
                      match e {
                        Some(e) => {
                          *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                          let super::types::Vec4{ x:x59, y:y59, z:z59, w:w59, } = e;
                          *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x59);
                          *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y59);
                          *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z59);
                          *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w59);
                          
                        },
                        None => {
                          {
                            *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                            
                          }
                        },
                      };
                    },
                    OptionValue::TypeUvec2(e) => {
                      *((ptr0 + 32) as *mut u8) = (15i32) as u8;
                      match e {
                        Some(e) => {
                          *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                          let super::types::Uvec2{ x:x60, y:y60, } = e;
                          *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x60);
                          *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y60);
                          
                        },
                        None => {
                          {
                            *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                            
                          }
                        },
                      };
                    },
                    OptionValue::TypeUvec3(e) => {
                      *((ptr0 + 32) as *mut u8) = (16i32) as u8;
                      match e {
                        Some(e) => {
                          *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                          let super::types::Uvec3{ x:x61, y:y61, z:z61, } = e;
                          *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x61);
                          *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y61);
                          *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z61);
                          
                        },
                        None => {
                          {
                            *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                            
                          }
                        },
                      };
                    },
                    OptionValue::TypeUvec4(e) => {
                      *((ptr0 + 32) as *mut u8) = (17i32) as u8;
                      match e {
                        Some(e) => {
                          *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                          let super::types::Uvec4{ x:x62, y:y62, z:z62, w:w62, } = e;
                          *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x62);
                          *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y62);
                          *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z62);
                          *((ptr0 + 56) as *mut i32) = wit_bindgen::rt::as_i32(w62);
                          
                        },
                        None => {
                          {
                            *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                            
                          }
                        },
                      };
                    },
                    OptionValue::TypeProceduralMeshHandle(e) => {
                      *((ptr0 + 32) as *mut u8) = (18i32) as u8;
                      match e {
                        Some(e) => {
                          *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                          let super::client_mesh::Handle{ ulid:ulid63, } = e;
                          let (t64_0, t64_1, ) = ulid63;
                          *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t64_0);
                          *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t64_1);
                          
                        },
                        None => {
                          {
                            *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                            
                          }
                        },
                      };
                    },
                    OptionValue::TypeProceduralTextureHandle(e) => {
                      *((ptr0 + 32) as *mut u8) = (19i32) as u8;
                      match e {
                        Some(e) => {
                          *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                          let super::client_texture::Handle{ ulid:ulid65, } = e;
                          let (t66_0, t66_1, ) = ulid65;
                          *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t66_0);
                          *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t66_1);
                          
                        },
                        None => {
                          {
                            *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                            
                          }
                        },
                      };
                    },
                    OptionValue::TypeProceduralSamplerHandle(e) => {
                      *((ptr0 + 32) as *mut u8) = (20i32) as u8;
                      match e {
                        Some(e) => {
                          *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                          let super::client_sampler::Handle{ ulid:ulid67, } = e;
                          let (t68_0, t68_1, ) = ulid67;
                          *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t68_0);
                          *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t68_1);
                          
                        },
                        None => {
                          {
                            *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                            
                          }
                        },
                      };
                    },
                    OptionValue::TypeProceduralMaterialHandle(e) => {
                      *((ptr0 + 32) as *mut u8) = (21i32) as u8;
                      match e {
                        Some(e) => {
                          *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                          let super::client_material::Handle{ ulid:ulid69, } = e;
                          let (t70_0, t70_1, ) = ulid69;
                          *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t70_0);
                          *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t70_1);
                          
                        },
                        None => {
                          {
                            *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                            
                          }
                        },
                      };
                    },
                  };
                  
                },
              };
              
              #[link(wasm_import_module = "component")]
              extern "C" {
                #[cfg_attr(target_arch = "wasm32", link_name = "add-component")]
                #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_add-component")]
                fn wit_import(
                _: i32, );
              }
              wit_import(ptr0);
              for (ptr, layout) in cleanup_list {
                
                if layout.size() != 0 {
                  
                  alloc::dealloc(ptr, layout);
                  
                }
                
              }
            }
          }
          #[allow(clippy::all)]
          pub fn add_components(entity: EntityId,data: &Entity,){
            
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            unsafe {
              let mut cleanup_list = Vec::new();
              let super::types::EntityId{ id0:id00, id1:id10, } = entity;
              let vec71 = data;
              let len71 = vec71.len() as i32;
              let layout71 = alloc::Layout::from_size_align_unchecked(vec71.len() * 96, 8);
              let result71 = if layout71.size() != 0
              {
                let ptr = alloc::alloc(layout71);
                if ptr.is_null()
                {
                  alloc::handle_alloc_error(layout71);
                }
                ptr
              }else {
                core::ptr::null_mut()
              };
              for (i, e) in vec71.into_iter().enumerate() {
                let base = result71 as i32 + (i as i32) * 96;
                {
                  let (t1_0, t1_1, ) = e;
                  *((base + 0) as *mut i32) = wit_bindgen::rt::as_i32(t1_0);
                  match t1_1 {
                    Value::TypeEmpty(e) => {
                      *((base + 8) as *mut u8) = (0i32) as u8;
                      let () = e;
                      
                    },
                    Value::TypeBool(e) => {
                      *((base + 8) as *mut u8) = (1i32) as u8;
                      *((base + 16) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                      
                    },
                    Value::TypeEntityId(e) => {
                      *((base + 8) as *mut u8) = (2i32) as u8;
                      let super::types::EntityId{ id0:id03, id1:id13, } = e;
                      *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(id03);
                      *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(id13);
                      
                    },
                    Value::TypeF32(e) => {
                      *((base + 8) as *mut u8) = (3i32) as u8;
                      *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(e);
                      
                    },
                    Value::TypeF64(e) => {
                      *((base + 8) as *mut u8) = (4i32) as u8;
                      *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                      
                    },
                    Value::TypeMat4(e) => {
                      *((base + 8) as *mut u8) = (5i32) as u8;
                      let super::types::Mat4{ x:x4, y:y4, z:z4, w:w4, } = e;
                      let super::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = x4;
                      *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x5);
                      *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y5);
                      *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z5);
                      *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w5);
                      let super::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = y4;
                      *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(x6);
                      *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(y6);
                      *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(z6);
                      *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(w6);
                      let super::types::Vec4{ x:x7, y:y7, z:z7, w:w7, } = z4;
                      *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(x7);
                      *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(y7);
                      *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(z7);
                      *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(w7);
                      let super::types::Vec4{ x:x8, y:y8, z:z8, w:w8, } = w4;
                      *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(x8);
                      *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(y8);
                      *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(z8);
                      *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(w8);
                      
                    },
                    Value::TypeI32(e) => {
                      *((base + 8) as *mut u8) = (6i32) as u8;
                      *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                      
                    },
                    Value::TypeQuat(e) => {
                      *((base + 8) as *mut u8) = (7i32) as u8;
                      let super::types::Quat{ x:x9, y:y9, z:z9, w:w9, } = e;
                      *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x9);
                      *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y9);
                      *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z9);
                      *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w9);
                      
                    },
                    Value::TypeString(e) => {
                      *((base + 8) as *mut u8) = (8i32) as u8;
                      let vec10 = e;
                      let ptr10 = vec10.as_ptr() as i32;
                      let len10 = vec10.len() as i32;
                      *((base + 20) as *mut i32) = len10;
                      *((base + 16) as *mut i32) = ptr10;
                      
                    },
                    Value::TypeU8(e) => {
                      *((base + 8) as *mut u8) = (9i32) as u8;
                      *((base + 16) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                      
                    },
                    Value::TypeU32(e) => {
                      *((base + 8) as *mut u8) = (10i32) as u8;
                      *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                      
                    },
                    Value::TypeU64(e) => {
                      *((base + 8) as *mut u8) = (11i32) as u8;
                      *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                      
                    },
                    Value::TypeVec2(e) => {
                      *((base + 8) as *mut u8) = (12i32) as u8;
                      let super::types::Vec2{ x:x11, y:y11, } = e;
                      *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x11);
                      *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y11);
                      
                    },
                    Value::TypeVec3(e) => {
                      *((base + 8) as *mut u8) = (13i32) as u8;
                      let super::types::Vec3{ x:x12, y:y12, z:z12, } = e;
                      *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x12);
                      *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y12);
                      *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z12);
                      
                    },
                    Value::TypeVec4(e) => {
                      *((base + 8) as *mut u8) = (14i32) as u8;
                      let super::types::Vec4{ x:x13, y:y13, z:z13, w:w13, } = e;
                      *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x13);
                      *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y13);
                      *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z13);
                      *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w13);
                      
                    },
                    Value::TypeUvec2(e) => {
                      *((base + 8) as *mut u8) = (15i32) as u8;
                      let super::types::Uvec2{ x:x14, y:y14, } = e;
                      *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x14);
                      *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y14);
                      
                    },
                    Value::TypeUvec3(e) => {
                      *((base + 8) as *mut u8) = (16i32) as u8;
                      let super::types::Uvec3{ x:x15, y:y15, z:z15, } = e;
                      *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x15);
                      *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y15);
                      *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z15);
                      
                    },
                    Value::TypeUvec4(e) => {
                      *((base + 8) as *mut u8) = (17i32) as u8;
                      let super::types::Uvec4{ x:x16, y:y16, z:z16, w:w16, } = e;
                      *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x16);
                      *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y16);
                      *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z16);
                      *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(w16);
                      
                    },
                    Value::TypeProceduralMeshHandle(e) => {
                      *((base + 8) as *mut u8) = (18i32) as u8;
                      let super::client_mesh::Handle{ ulid:ulid17, } = e;
                      let (t18_0, t18_1, ) = ulid17;
                      *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t18_0);
                      *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t18_1);
                      
                    },
                    Value::TypeProceduralTextureHandle(e) => {
                      *((base + 8) as *mut u8) = (19i32) as u8;
                      let super::client_texture::Handle{ ulid:ulid19, } = e;
                      let (t20_0, t20_1, ) = ulid19;
                      *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t20_0);
                      *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t20_1);
                      
                    },
                    Value::TypeProceduralSamplerHandle(e) => {
                      *((base + 8) as *mut u8) = (20i32) as u8;
                      let super::client_sampler::Handle{ ulid:ulid21, } = e;
                      let (t22_0, t22_1, ) = ulid21;
                      *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t22_0);
                      *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t22_1);
                      
                    },
                    Value::TypeProceduralMaterialHandle(e) => {
                      *((base + 8) as *mut u8) = (21i32) as u8;
                      let super::client_material::Handle{ ulid:ulid23, } = e;
                      let (t24_0, t24_1, ) = ulid23;
                      *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t24_0);
                      *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t24_1);
                      
                    },
                    Value::TypeVec(e) => {
                      *((base + 8) as *mut u8) = (22i32) as u8;
                      match e {
                        VecValue::TypeEmpty(e) => {
                          *((base + 16) as *mut u8) = (0i32) as u8;
                          let vec25 = e;
                          let ptr25 = vec25.as_ptr() as i32;
                          let len25 = vec25.len() as i32;
                          *((base + 24) as *mut i32) = len25;
                          *((base + 20) as *mut i32) = ptr25;
                          
                        },
                        VecValue::TypeBool(e) => {
                          *((base + 16) as *mut u8) = (1i32) as u8;
                          let vec26 = e;
                          let len26 = vec26.len() as i32;
                          let layout26 = alloc::Layout::from_size_align_unchecked(vec26.len() * 1, 1);
                          let result26 = if layout26.size() != 0
                          {
                            let ptr = alloc::alloc(layout26);
                            if ptr.is_null()
                            {
                              alloc::handle_alloc_error(layout26);
                            }
                            ptr
                          }else {
                            core::ptr::null_mut()
                          };
                          for (i, e) in vec26.into_iter().enumerate() {
                            let base = result26 as i32 + (i as i32) * 1;
                            {
                              *((base + 0) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                              
                            }}
                            *((base + 24) as *mut i32) = len26;
                            *((base + 20) as *mut i32) = result26 as i32;
                            cleanup_list.extend_from_slice(&[(result26, layout26),]);
                            
                          },
                          VecValue::TypeEntityId(e) => {
                            *((base + 16) as *mut u8) = (2i32) as u8;
                            let vec27 = e;
                            let ptr27 = vec27.as_ptr() as i32;
                            let len27 = vec27.len() as i32;
                            *((base + 24) as *mut i32) = len27;
                            *((base + 20) as *mut i32) = ptr27;
                            
                          },
                          VecValue::TypeF32(e) => {
                            *((base + 16) as *mut u8) = (3i32) as u8;
                            let vec28 = e;
                            let ptr28 = vec28.as_ptr() as i32;
                            let len28 = vec28.len() as i32;
                            *((base + 24) as *mut i32) = len28;
                            *((base + 20) as *mut i32) = ptr28;
                            
                          },
                          VecValue::TypeF64(e) => {
                            *((base + 16) as *mut u8) = (4i32) as u8;
                            let vec29 = e;
                            let ptr29 = vec29.as_ptr() as i32;
                            let len29 = vec29.len() as i32;
                            *((base + 24) as *mut i32) = len29;
                            *((base + 20) as *mut i32) = ptr29;
                            
                          },
                          VecValue::TypeMat4(e) => {
                            *((base + 16) as *mut u8) = (5i32) as u8;
                            let vec30 = e;
                            let ptr30 = vec30.as_ptr() as i32;
                            let len30 = vec30.len() as i32;
                            *((base + 24) as *mut i32) = len30;
                            *((base + 20) as *mut i32) = ptr30;
                            
                          },
                          VecValue::TypeI32(e) => {
                            *((base + 16) as *mut u8) = (6i32) as u8;
                            let vec31 = e;
                            let ptr31 = vec31.as_ptr() as i32;
                            let len31 = vec31.len() as i32;
                            *((base + 24) as *mut i32) = len31;
                            *((base + 20) as *mut i32) = ptr31;
                            
                          },
                          VecValue::TypeQuat(e) => {
                            *((base + 16) as *mut u8) = (7i32) as u8;
                            let vec32 = e;
                            let ptr32 = vec32.as_ptr() as i32;
                            let len32 = vec32.len() as i32;
                            *((base + 24) as *mut i32) = len32;
                            *((base + 20) as *mut i32) = ptr32;
                            
                          },
                          VecValue::TypeString(e) => {
                            *((base + 16) as *mut u8) = (8i32) as u8;
                            let vec34 = e;
                            let len34 = vec34.len() as i32;
                            let layout34 = alloc::Layout::from_size_align_unchecked(vec34.len() * 8, 4);
                            let result34 = if layout34.size() != 0
                            {
                              let ptr = alloc::alloc(layout34);
                              if ptr.is_null()
                              {
                                alloc::handle_alloc_error(layout34);
                              }
                              ptr
                            }else {
                              core::ptr::null_mut()
                            };
                            for (i, e) in vec34.into_iter().enumerate() {
                              let base = result34 as i32 + (i as i32) * 8;
                              {
                                let vec33 = e;
                                let ptr33 = vec33.as_ptr() as i32;
                                let len33 = vec33.len() as i32;
                                *((base + 4) as *mut i32) = len33;
                                *((base + 0) as *mut i32) = ptr33;
                                
                              }}
                              *((base + 24) as *mut i32) = len34;
                              *((base + 20) as *mut i32) = result34 as i32;
                              cleanup_list.extend_from_slice(&[(result34, layout34),]);
                              
                            },
                            VecValue::TypeU8(e) => {
                              *((base + 16) as *mut u8) = (9i32) as u8;
                              let vec35 = e;
                              let ptr35 = vec35.as_ptr() as i32;
                              let len35 = vec35.len() as i32;
                              *((base + 24) as *mut i32) = len35;
                              *((base + 20) as *mut i32) = ptr35;
                              
                            },
                            VecValue::TypeU32(e) => {
                              *((base + 16) as *mut u8) = (10i32) as u8;
                              let vec36 = e;
                              let ptr36 = vec36.as_ptr() as i32;
                              let len36 = vec36.len() as i32;
                              *((base + 24) as *mut i32) = len36;
                              *((base + 20) as *mut i32) = ptr36;
                              
                            },
                            VecValue::TypeU64(e) => {
                              *((base + 16) as *mut u8) = (11i32) as u8;
                              let vec37 = e;
                              let ptr37 = vec37.as_ptr() as i32;
                              let len37 = vec37.len() as i32;
                              *((base + 24) as *mut i32) = len37;
                              *((base + 20) as *mut i32) = ptr37;
                              
                            },
                            VecValue::TypeVec2(e) => {
                              *((base + 16) as *mut u8) = (12i32) as u8;
                              let vec38 = e;
                              let ptr38 = vec38.as_ptr() as i32;
                              let len38 = vec38.len() as i32;
                              *((base + 24) as *mut i32) = len38;
                              *((base + 20) as *mut i32) = ptr38;
                              
                            },
                            VecValue::TypeVec3(e) => {
                              *((base + 16) as *mut u8) = (13i32) as u8;
                              let vec39 = e;
                              let ptr39 = vec39.as_ptr() as i32;
                              let len39 = vec39.len() as i32;
                              *((base + 24) as *mut i32) = len39;
                              *((base + 20) as *mut i32) = ptr39;
                              
                            },
                            VecValue::TypeVec4(e) => {
                              *((base + 16) as *mut u8) = (14i32) as u8;
                              let vec40 = e;
                              let ptr40 = vec40.as_ptr() as i32;
                              let len40 = vec40.len() as i32;
                              *((base + 24) as *mut i32) = len40;
                              *((base + 20) as *mut i32) = ptr40;
                              
                            },
                            VecValue::TypeUvec2(e) => {
                              *((base + 16) as *mut u8) = (15i32) as u8;
                              let vec41 = e;
                              let ptr41 = vec41.as_ptr() as i32;
                              let len41 = vec41.len() as i32;
                              *((base + 24) as *mut i32) = len41;
                              *((base + 20) as *mut i32) = ptr41;
                              
                            },
                            VecValue::TypeUvec3(e) => {
                              *((base + 16) as *mut u8) = (16i32) as u8;
                              let vec42 = e;
                              let ptr42 = vec42.as_ptr() as i32;
                              let len42 = vec42.len() as i32;
                              *((base + 24) as *mut i32) = len42;
                              *((base + 20) as *mut i32) = ptr42;
                              
                            },
                            VecValue::TypeUvec4(e) => {
                              *((base + 16) as *mut u8) = (17i32) as u8;
                              let vec43 = e;
                              let ptr43 = vec43.as_ptr() as i32;
                              let len43 = vec43.len() as i32;
                              *((base + 24) as *mut i32) = len43;
                              *((base + 20) as *mut i32) = ptr43;
                              
                            },
                            VecValue::TypeProceduralMeshHandle(e) => {
                              *((base + 16) as *mut u8) = (18i32) as u8;
                              let vec44 = e;
                              let ptr44 = vec44.as_ptr() as i32;
                              let len44 = vec44.len() as i32;
                              *((base + 24) as *mut i32) = len44;
                              *((base + 20) as *mut i32) = ptr44;
                              
                            },
                            VecValue::TypeProceduralTextureHandle(e) => {
                              *((base + 16) as *mut u8) = (19i32) as u8;
                              let vec45 = e;
                              let ptr45 = vec45.as_ptr() as i32;
                              let len45 = vec45.len() as i32;
                              *((base + 24) as *mut i32) = len45;
                              *((base + 20) as *mut i32) = ptr45;
                              
                            },
                            VecValue::TypeProceduralSamplerHandle(e) => {
                              *((base + 16) as *mut u8) = (20i32) as u8;
                              let vec46 = e;
                              let ptr46 = vec46.as_ptr() as i32;
                              let len46 = vec46.len() as i32;
                              *((base + 24) as *mut i32) = len46;
                              *((base + 20) as *mut i32) = ptr46;
                              
                            },
                            VecValue::TypeProceduralMaterialHandle(e) => {
                              *((base + 16) as *mut u8) = (21i32) as u8;
                              let vec47 = e;
                              let ptr47 = vec47.as_ptr() as i32;
                              let len47 = vec47.len() as i32;
                              *((base + 24) as *mut i32) = len47;
                              *((base + 20) as *mut i32) = ptr47;
                              
                            },
                          };
                          
                        },
                        Value::TypeOption(e) => {
                          *((base + 8) as *mut u8) = (23i32) as u8;
                          match e {
                            OptionValue::TypeEmpty(e) => {
                              *((base + 16) as *mut u8) = (0i32) as u8;
                              match e {
                                Some(e) => {
                                  *((base + 24) as *mut u8) = (1i32) as u8;
                                  let () = e;
                                  
                                },
                                None => {
                                  {
                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                    
                                  }
                                },
                              };
                            },
                            OptionValue::TypeBool(e) => {
                              *((base + 16) as *mut u8) = (1i32) as u8;
                              match e {
                                Some(e) => {
                                  *((base + 24) as *mut u8) = (1i32) as u8;
                                  *((base + 25) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                  
                                },
                                None => {
                                  {
                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                    
                                  }
                                },
                              };
                            },
                            OptionValue::TypeEntityId(e) => {
                              *((base + 16) as *mut u8) = (2i32) as u8;
                              match e {
                                Some(e) => {
                                  *((base + 24) as *mut u8) = (1i32) as u8;
                                  let super::types::EntityId{ id0:id049, id1:id149, } = e;
                                  *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(id049);
                                  *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(id149);
                                  
                                },
                                None => {
                                  {
                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                    
                                  }
                                },
                              };
                            },
                            OptionValue::TypeF32(e) => {
                              *((base + 16) as *mut u8) = (3i32) as u8;
                              match e {
                                Some(e) => {
                                  *((base + 24) as *mut u8) = (1i32) as u8;
                                  *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(e);
                                  
                                },
                                None => {
                                  {
                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                    
                                  }
                                },
                              };
                            },
                            OptionValue::TypeF64(e) => {
                              *((base + 16) as *mut u8) = (4i32) as u8;
                              match e {
                                Some(e) => {
                                  *((base + 24) as *mut u8) = (1i32) as u8;
                                  *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                  
                                },
                                None => {
                                  {
                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                    
                                  }
                                },
                              };
                            },
                            OptionValue::TypeMat4(e) => {
                              *((base + 16) as *mut u8) = (5i32) as u8;
                              match e {
                                Some(e) => {
                                  *((base + 24) as *mut u8) = (1i32) as u8;
                                  let super::types::Mat4{ x:x50, y:y50, z:z50, w:w50, } = e;
                                  let super::types::Vec4{ x:x51, y:y51, z:z51, w:w51, } = x50;
                                  *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x51);
                                  *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y51);
                                  *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z51);
                                  *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w51);
                                  let super::types::Vec4{ x:x52, y:y52, z:z52, w:w52, } = y50;
                                  *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(x52);
                                  *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(y52);
                                  *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(z52);
                                  *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(w52);
                                  let super::types::Vec4{ x:x53, y:y53, z:z53, w:w53, } = z50;
                                  *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(x53);
                                  *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(y53);
                                  *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(z53);
                                  *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(w53);
                                  let super::types::Vec4{ x:x54, y:y54, z:z54, w:w54, } = w50;
                                  *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(x54);
                                  *((base + 80) as *mut f32) = wit_bindgen::rt::as_f32(y54);
                                  *((base + 84) as *mut f32) = wit_bindgen::rt::as_f32(z54);
                                  *((base + 88) as *mut f32) = wit_bindgen::rt::as_f32(w54);
                                  
                                },
                                None => {
                                  {
                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                    
                                  }
                                },
                              };
                            },
                            OptionValue::TypeI32(e) => {
                              *((base + 16) as *mut u8) = (6i32) as u8;
                              match e {
                                Some(e) => {
                                  *((base + 24) as *mut u8) = (1i32) as u8;
                                  *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                  
                                },
                                None => {
                                  {
                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                    
                                  }
                                },
                              };
                            },
                            OptionValue::TypeQuat(e) => {
                              *((base + 16) as *mut u8) = (7i32) as u8;
                              match e {
                                Some(e) => {
                                  *((base + 24) as *mut u8) = (1i32) as u8;
                                  let super::types::Quat{ x:x55, y:y55, z:z55, w:w55, } = e;
                                  *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x55);
                                  *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y55);
                                  *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z55);
                                  *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w55);
                                  
                                },
                                None => {
                                  {
                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                    
                                  }
                                },
                              };
                            },
                            OptionValue::TypeString(e) => {
                              *((base + 16) as *mut u8) = (8i32) as u8;
                              match e {
                                Some(e) => {
                                  *((base + 24) as *mut u8) = (1i32) as u8;
                                  let vec56 = e;
                                  let ptr56 = vec56.as_ptr() as i32;
                                  let len56 = vec56.len() as i32;
                                  *((base + 32) as *mut i32) = len56;
                                  *((base + 28) as *mut i32) = ptr56;
                                  
                                },
                                None => {
                                  {
                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                    
                                  }
                                },
                              };
                            },
                            OptionValue::TypeU8(e) => {
                              *((base + 16) as *mut u8) = (9i32) as u8;
                              match e {
                                Some(e) => {
                                  *((base + 24) as *mut u8) = (1i32) as u8;
                                  *((base + 25) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                  
                                },
                                None => {
                                  {
                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                    
                                  }
                                },
                              };
                            },
                            OptionValue::TypeU32(e) => {
                              *((base + 16) as *mut u8) = (10i32) as u8;
                              match e {
                                Some(e) => {
                                  *((base + 24) as *mut u8) = (1i32) as u8;
                                  *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                  
                                },
                                None => {
                                  {
                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                    
                                  }
                                },
                              };
                            },
                            OptionValue::TypeU64(e) => {
                              *((base + 16) as *mut u8) = (11i32) as u8;
                              match e {
                                Some(e) => {
                                  *((base + 24) as *mut u8) = (1i32) as u8;
                                  *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                  
                                },
                                None => {
                                  {
                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                    
                                  }
                                },
                              };
                            },
                            OptionValue::TypeVec2(e) => {
                              *((base + 16) as *mut u8) = (12i32) as u8;
                              match e {
                                Some(e) => {
                                  *((base + 24) as *mut u8) = (1i32) as u8;
                                  let super::types::Vec2{ x:x57, y:y57, } = e;
                                  *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x57);
                                  *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y57);
                                  
                                },
                                None => {
                                  {
                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                    
                                  }
                                },
                              };
                            },
                            OptionValue::TypeVec3(e) => {
                              *((base + 16) as *mut u8) = (13i32) as u8;
                              match e {
                                Some(e) => {
                                  *((base + 24) as *mut u8) = (1i32) as u8;
                                  let super::types::Vec3{ x:x58, y:y58, z:z58, } = e;
                                  *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x58);
                                  *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y58);
                                  *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z58);
                                  
                                },
                                None => {
                                  {
                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                    
                                  }
                                },
                              };
                            },
                            OptionValue::TypeVec4(e) => {
                              *((base + 16) as *mut u8) = (14i32) as u8;
                              match e {
                                Some(e) => {
                                  *((base + 24) as *mut u8) = (1i32) as u8;
                                  let super::types::Vec4{ x:x59, y:y59, z:z59, w:w59, } = e;
                                  *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x59);
                                  *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y59);
                                  *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z59);
                                  *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w59);
                                  
                                },
                                None => {
                                  {
                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                    
                                  }
                                },
                              };
                            },
                            OptionValue::TypeUvec2(e) => {
                              *((base + 16) as *mut u8) = (15i32) as u8;
                              match e {
                                Some(e) => {
                                  *((base + 24) as *mut u8) = (1i32) as u8;
                                  let super::types::Uvec2{ x:x60, y:y60, } = e;
                                  *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x60);
                                  *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y60);
                                  
                                },
                                None => {
                                  {
                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                    
                                  }
                                },
                              };
                            },
                            OptionValue::TypeUvec3(e) => {
                              *((base + 16) as *mut u8) = (16i32) as u8;
                              match e {
                                Some(e) => {
                                  *((base + 24) as *mut u8) = (1i32) as u8;
                                  let super::types::Uvec3{ x:x61, y:y61, z:z61, } = e;
                                  *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x61);
                                  *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y61);
                                  *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z61);
                                  
                                },
                                None => {
                                  {
                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                    
                                  }
                                },
                              };
                            },
                            OptionValue::TypeUvec4(e) => {
                              *((base + 16) as *mut u8) = (17i32) as u8;
                              match e {
                                Some(e) => {
                                  *((base + 24) as *mut u8) = (1i32) as u8;
                                  let super::types::Uvec4{ x:x62, y:y62, z:z62, w:w62, } = e;
                                  *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x62);
                                  *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y62);
                                  *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z62);
                                  *((base + 40) as *mut i32) = wit_bindgen::rt::as_i32(w62);
                                  
                                },
                                None => {
                                  {
                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                    
                                  }
                                },
                              };
                            },
                            OptionValue::TypeProceduralMeshHandle(e) => {
                              *((base + 16) as *mut u8) = (18i32) as u8;
                              match e {
                                Some(e) => {
                                  *((base + 24) as *mut u8) = (1i32) as u8;
                                  let super::client_mesh::Handle{ ulid:ulid63, } = e;
                                  let (t64_0, t64_1, ) = ulid63;
                                  *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t64_0);
                                  *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t64_1);
                                  
                                },
                                None => {
                                  {
                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                    
                                  }
                                },
                              };
                            },
                            OptionValue::TypeProceduralTextureHandle(e) => {
                              *((base + 16) as *mut u8) = (19i32) as u8;
                              match e {
                                Some(e) => {
                                  *((base + 24) as *mut u8) = (1i32) as u8;
                                  let super::client_texture::Handle{ ulid:ulid65, } = e;
                                  let (t66_0, t66_1, ) = ulid65;
                                  *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t66_0);
                                  *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t66_1);
                                  
                                },
                                None => {
                                  {
                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                    
                                  }
                                },
                              };
                            },
                            OptionValue::TypeProceduralSamplerHandle(e) => {
                              *((base + 16) as *mut u8) = (20i32) as u8;
                              match e {
                                Some(e) => {
                                  *((base + 24) as *mut u8) = (1i32) as u8;
                                  let super::client_sampler::Handle{ ulid:ulid67, } = e;
                                  let (t68_0, t68_1, ) = ulid67;
                                  *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t68_0);
                                  *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t68_1);
                                  
                                },
                                None => {
                                  {
                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                    
                                  }
                                },
                              };
                            },
                            OptionValue::TypeProceduralMaterialHandle(e) => {
                              *((base + 16) as *mut u8) = (21i32) as u8;
                              match e {
                                Some(e) => {
                                  *((base + 24) as *mut u8) = (1i32) as u8;
                                  let super::client_material::Handle{ ulid:ulid69, } = e;
                                  let (t70_0, t70_1, ) = ulid69;
                                  *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t70_0);
                                  *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t70_1);
                                  
                                },
                                None => {
                                  {
                                    *((base + 24) as *mut u8) = (0i32) as u8;
                                    
                                  }
                                },
                              };
                            },
                          };
                          
                        },
                      };
                      
                    }}
                    
                    #[link(wasm_import_module = "component")]
                    extern "C" {
                      #[cfg_attr(target_arch = "wasm32", link_name = "add-components")]
                      #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_add-components")]
                      fn wit_import(
                      _: i64, _: i64, _: i32, _: i32, );
                    }
                    wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), result71 as i32, len71);
                    if layout71.size() != 0 {
                      alloc::dealloc(result71, layout71);
                    }
                    for (ptr, layout) in cleanup_list {
                      
                      if layout.size() != 0 {
                        
                        alloc::dealloc(ptr, layout);
                        
                      }
                      
                    }
                  }
                }
                #[allow(clippy::all)]
                pub fn set_component(entity: EntityId,index: u32,value: &Value,){
                  
                  #[allow(unused_imports)]
                  use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                  unsafe {
                    let mut cleanup_list = Vec::new();
                    
                    #[repr(align(8))]
                    struct RetArea([u8; 112]);
                    let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                    let ptr0 = ret_area.as_mut_ptr() as i32;let super::types::EntityId{ id0:id01, id1:id11, } = entity;
                    *((ptr0 + 0) as *mut i64) = wit_bindgen::rt::as_i64(id01);
                    *((ptr0 + 8) as *mut i64) = wit_bindgen::rt::as_i64(id11);
                    *((ptr0 + 16) as *mut i32) = wit_bindgen::rt::as_i32(index);
                    match value {
                      Value::TypeEmpty(e) => {
                        *((ptr0 + 24) as *mut u8) = (0i32) as u8;
                        let () = e;
                        
                      },
                      Value::TypeBool(e) => {
                        *((ptr0 + 24) as *mut u8) = (1i32) as u8;
                        *((ptr0 + 32) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                        
                      },
                      Value::TypeEntityId(e) => {
                        *((ptr0 + 24) as *mut u8) = (2i32) as u8;
                        let super::types::EntityId{ id0:id03, id1:id13, } = e;
                        *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(id03);
                        *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(id13);
                        
                      },
                      Value::TypeF32(e) => {
                        *((ptr0 + 24) as *mut u8) = (3i32) as u8;
                        *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(e);
                        
                      },
                      Value::TypeF64(e) => {
                        *((ptr0 + 24) as *mut u8) = (4i32) as u8;
                        *((ptr0 + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                        
                      },
                      Value::TypeMat4(e) => {
                        *((ptr0 + 24) as *mut u8) = (5i32) as u8;
                        let super::types::Mat4{ x:x4, y:y4, z:z4, w:w4, } = e;
                        let super::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = x4;
                        *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x5);
                        *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y5);
                        *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z5);
                        *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w5);
                        let super::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = y4;
                        *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(x6);
                        *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(y6);
                        *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(z6);
                        *((ptr0 + 60) as *mut f32) = wit_bindgen::rt::as_f32(w6);
                        let super::types::Vec4{ x:x7, y:y7, z:z7, w:w7, } = z4;
                        *((ptr0 + 64) as *mut f32) = wit_bindgen::rt::as_f32(x7);
                        *((ptr0 + 68) as *mut f32) = wit_bindgen::rt::as_f32(y7);
                        *((ptr0 + 72) as *mut f32) = wit_bindgen::rt::as_f32(z7);
                        *((ptr0 + 76) as *mut f32) = wit_bindgen::rt::as_f32(w7);
                        let super::types::Vec4{ x:x8, y:y8, z:z8, w:w8, } = w4;
                        *((ptr0 + 80) as *mut f32) = wit_bindgen::rt::as_f32(x8);
                        *((ptr0 + 84) as *mut f32) = wit_bindgen::rt::as_f32(y8);
                        *((ptr0 + 88) as *mut f32) = wit_bindgen::rt::as_f32(z8);
                        *((ptr0 + 92) as *mut f32) = wit_bindgen::rt::as_f32(w8);
                        
                      },
                      Value::TypeI32(e) => {
                        *((ptr0 + 24) as *mut u8) = (6i32) as u8;
                        *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(e);
                        
                      },
                      Value::TypeQuat(e) => {
                        *((ptr0 + 24) as *mut u8) = (7i32) as u8;
                        let super::types::Quat{ x:x9, y:y9, z:z9, w:w9, } = e;
                        *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x9);
                        *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y9);
                        *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z9);
                        *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w9);
                        
                      },
                      Value::TypeString(e) => {
                        *((ptr0 + 24) as *mut u8) = (8i32) as u8;
                        let vec10 = e;
                        let ptr10 = vec10.as_ptr() as i32;
                        let len10 = vec10.len() as i32;
                        *((ptr0 + 36) as *mut i32) = len10;
                        *((ptr0 + 32) as *mut i32) = ptr10;
                        
                      },
                      Value::TypeU8(e) => {
                        *((ptr0 + 24) as *mut u8) = (9i32) as u8;
                        *((ptr0 + 32) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                        
                      },
                      Value::TypeU32(e) => {
                        *((ptr0 + 24) as *mut u8) = (10i32) as u8;
                        *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(e);
                        
                      },
                      Value::TypeU64(e) => {
                        *((ptr0 + 24) as *mut u8) = (11i32) as u8;
                        *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                        
                      },
                      Value::TypeVec2(e) => {
                        *((ptr0 + 24) as *mut u8) = (12i32) as u8;
                        let super::types::Vec2{ x:x11, y:y11, } = e;
                        *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x11);
                        *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y11);
                        
                      },
                      Value::TypeVec3(e) => {
                        *((ptr0 + 24) as *mut u8) = (13i32) as u8;
                        let super::types::Vec3{ x:x12, y:y12, z:z12, } = e;
                        *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x12);
                        *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y12);
                        *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z12);
                        
                      },
                      Value::TypeVec4(e) => {
                        *((ptr0 + 24) as *mut u8) = (14i32) as u8;
                        let super::types::Vec4{ x:x13, y:y13, z:z13, w:w13, } = e;
                        *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x13);
                        *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y13);
                        *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z13);
                        *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w13);
                        
                      },
                      Value::TypeUvec2(e) => {
                        *((ptr0 + 24) as *mut u8) = (15i32) as u8;
                        let super::types::Uvec2{ x:x14, y:y14, } = e;
                        *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x14);
                        *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y14);
                        
                      },
                      Value::TypeUvec3(e) => {
                        *((ptr0 + 24) as *mut u8) = (16i32) as u8;
                        let super::types::Uvec3{ x:x15, y:y15, z:z15, } = e;
                        *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x15);
                        *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y15);
                        *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z15);
                        
                      },
                      Value::TypeUvec4(e) => {
                        *((ptr0 + 24) as *mut u8) = (17i32) as u8;
                        let super::types::Uvec4{ x:x16, y:y16, z:z16, w:w16, } = e;
                        *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x16);
                        *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y16);
                        *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z16);
                        *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(w16);
                        
                      },
                      Value::TypeProceduralMeshHandle(e) => {
                        *((ptr0 + 24) as *mut u8) = (18i32) as u8;
                        let super::client_mesh::Handle{ ulid:ulid17, } = e;
                        let (t18_0, t18_1, ) = ulid17;
                        *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t18_0);
                        *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t18_1);
                        
                      },
                      Value::TypeProceduralTextureHandle(e) => {
                        *((ptr0 + 24) as *mut u8) = (19i32) as u8;
                        let super::client_texture::Handle{ ulid:ulid19, } = e;
                        let (t20_0, t20_1, ) = ulid19;
                        *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t20_0);
                        *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t20_1);
                        
                      },
                      Value::TypeProceduralSamplerHandle(e) => {
                        *((ptr0 + 24) as *mut u8) = (20i32) as u8;
                        let super::client_sampler::Handle{ ulid:ulid21, } = e;
                        let (t22_0, t22_1, ) = ulid21;
                        *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t22_0);
                        *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t22_1);
                        
                      },
                      Value::TypeProceduralMaterialHandle(e) => {
                        *((ptr0 + 24) as *mut u8) = (21i32) as u8;
                        let super::client_material::Handle{ ulid:ulid23, } = e;
                        let (t24_0, t24_1, ) = ulid23;
                        *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t24_0);
                        *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t24_1);
                        
                      },
                      Value::TypeVec(e) => {
                        *((ptr0 + 24) as *mut u8) = (22i32) as u8;
                        match e {
                          VecValue::TypeEmpty(e) => {
                            *((ptr0 + 32) as *mut u8) = (0i32) as u8;
                            let vec25 = e;
                            let ptr25 = vec25.as_ptr() as i32;
                            let len25 = vec25.len() as i32;
                            *((ptr0 + 40) as *mut i32) = len25;
                            *((ptr0 + 36) as *mut i32) = ptr25;
                            
                          },
                          VecValue::TypeBool(e) => {
                            *((ptr0 + 32) as *mut u8) = (1i32) as u8;
                            let vec26 = e;
                            let len26 = vec26.len() as i32;
                            let layout26 = alloc::Layout::from_size_align_unchecked(vec26.len() * 1, 1);
                            let result26 = if layout26.size() != 0
                            {
                              let ptr = alloc::alloc(layout26);
                              if ptr.is_null()
                              {
                                alloc::handle_alloc_error(layout26);
                              }
                              ptr
                            }else {
                              core::ptr::null_mut()
                            };
                            for (i, e) in vec26.into_iter().enumerate() {
                              let base = result26 as i32 + (i as i32) * 1;
                              {
                                *((base + 0) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                
                              }}
                              *((ptr0 + 40) as *mut i32) = len26;
                              *((ptr0 + 36) as *mut i32) = result26 as i32;
                              cleanup_list.extend_from_slice(&[(result26, layout26),]);
                              
                            },
                            VecValue::TypeEntityId(e) => {
                              *((ptr0 + 32) as *mut u8) = (2i32) as u8;
                              let vec27 = e;
                              let ptr27 = vec27.as_ptr() as i32;
                              let len27 = vec27.len() as i32;
                              *((ptr0 + 40) as *mut i32) = len27;
                              *((ptr0 + 36) as *mut i32) = ptr27;
                              
                            },
                            VecValue::TypeF32(e) => {
                              *((ptr0 + 32) as *mut u8) = (3i32) as u8;
                              let vec28 = e;
                              let ptr28 = vec28.as_ptr() as i32;
                              let len28 = vec28.len() as i32;
                              *((ptr0 + 40) as *mut i32) = len28;
                              *((ptr0 + 36) as *mut i32) = ptr28;
                              
                            },
                            VecValue::TypeF64(e) => {
                              *((ptr0 + 32) as *mut u8) = (4i32) as u8;
                              let vec29 = e;
                              let ptr29 = vec29.as_ptr() as i32;
                              let len29 = vec29.len() as i32;
                              *((ptr0 + 40) as *mut i32) = len29;
                              *((ptr0 + 36) as *mut i32) = ptr29;
                              
                            },
                            VecValue::TypeMat4(e) => {
                              *((ptr0 + 32) as *mut u8) = (5i32) as u8;
                              let vec30 = e;
                              let ptr30 = vec30.as_ptr() as i32;
                              let len30 = vec30.len() as i32;
                              *((ptr0 + 40) as *mut i32) = len30;
                              *((ptr0 + 36) as *mut i32) = ptr30;
                              
                            },
                            VecValue::TypeI32(e) => {
                              *((ptr0 + 32) as *mut u8) = (6i32) as u8;
                              let vec31 = e;
                              let ptr31 = vec31.as_ptr() as i32;
                              let len31 = vec31.len() as i32;
                              *((ptr0 + 40) as *mut i32) = len31;
                              *((ptr0 + 36) as *mut i32) = ptr31;
                              
                            },
                            VecValue::TypeQuat(e) => {
                              *((ptr0 + 32) as *mut u8) = (7i32) as u8;
                              let vec32 = e;
                              let ptr32 = vec32.as_ptr() as i32;
                              let len32 = vec32.len() as i32;
                              *((ptr0 + 40) as *mut i32) = len32;
                              *((ptr0 + 36) as *mut i32) = ptr32;
                              
                            },
                            VecValue::TypeString(e) => {
                              *((ptr0 + 32) as *mut u8) = (8i32) as u8;
                              let vec34 = e;
                              let len34 = vec34.len() as i32;
                              let layout34 = alloc::Layout::from_size_align_unchecked(vec34.len() * 8, 4);
                              let result34 = if layout34.size() != 0
                              {
                                let ptr = alloc::alloc(layout34);
                                if ptr.is_null()
                                {
                                  alloc::handle_alloc_error(layout34);
                                }
                                ptr
                              }else {
                                core::ptr::null_mut()
                              };
                              for (i, e) in vec34.into_iter().enumerate() {
                                let base = result34 as i32 + (i as i32) * 8;
                                {
                                  let vec33 = e;
                                  let ptr33 = vec33.as_ptr() as i32;
                                  let len33 = vec33.len() as i32;
                                  *((base + 4) as *mut i32) = len33;
                                  *((base + 0) as *mut i32) = ptr33;
                                  
                                }}
                                *((ptr0 + 40) as *mut i32) = len34;
                                *((ptr0 + 36) as *mut i32) = result34 as i32;
                                cleanup_list.extend_from_slice(&[(result34, layout34),]);
                                
                              },
                              VecValue::TypeU8(e) => {
                                *((ptr0 + 32) as *mut u8) = (9i32) as u8;
                                let vec35 = e;
                                let ptr35 = vec35.as_ptr() as i32;
                                let len35 = vec35.len() as i32;
                                *((ptr0 + 40) as *mut i32) = len35;
                                *((ptr0 + 36) as *mut i32) = ptr35;
                                
                              },
                              VecValue::TypeU32(e) => {
                                *((ptr0 + 32) as *mut u8) = (10i32) as u8;
                                let vec36 = e;
                                let ptr36 = vec36.as_ptr() as i32;
                                let len36 = vec36.len() as i32;
                                *((ptr0 + 40) as *mut i32) = len36;
                                *((ptr0 + 36) as *mut i32) = ptr36;
                                
                              },
                              VecValue::TypeU64(e) => {
                                *((ptr0 + 32) as *mut u8) = (11i32) as u8;
                                let vec37 = e;
                                let ptr37 = vec37.as_ptr() as i32;
                                let len37 = vec37.len() as i32;
                                *((ptr0 + 40) as *mut i32) = len37;
                                *((ptr0 + 36) as *mut i32) = ptr37;
                                
                              },
                              VecValue::TypeVec2(e) => {
                                *((ptr0 + 32) as *mut u8) = (12i32) as u8;
                                let vec38 = e;
                                let ptr38 = vec38.as_ptr() as i32;
                                let len38 = vec38.len() as i32;
                                *((ptr0 + 40) as *mut i32) = len38;
                                *((ptr0 + 36) as *mut i32) = ptr38;
                                
                              },
                              VecValue::TypeVec3(e) => {
                                *((ptr0 + 32) as *mut u8) = (13i32) as u8;
                                let vec39 = e;
                                let ptr39 = vec39.as_ptr() as i32;
                                let len39 = vec39.len() as i32;
                                *((ptr0 + 40) as *mut i32) = len39;
                                *((ptr0 + 36) as *mut i32) = ptr39;
                                
                              },
                              VecValue::TypeVec4(e) => {
                                *((ptr0 + 32) as *mut u8) = (14i32) as u8;
                                let vec40 = e;
                                let ptr40 = vec40.as_ptr() as i32;
                                let len40 = vec40.len() as i32;
                                *((ptr0 + 40) as *mut i32) = len40;
                                *((ptr0 + 36) as *mut i32) = ptr40;
                                
                              },
                              VecValue::TypeUvec2(e) => {
                                *((ptr0 + 32) as *mut u8) = (15i32) as u8;
                                let vec41 = e;
                                let ptr41 = vec41.as_ptr() as i32;
                                let len41 = vec41.len() as i32;
                                *((ptr0 + 40) as *mut i32) = len41;
                                *((ptr0 + 36) as *mut i32) = ptr41;
                                
                              },
                              VecValue::TypeUvec3(e) => {
                                *((ptr0 + 32) as *mut u8) = (16i32) as u8;
                                let vec42 = e;
                                let ptr42 = vec42.as_ptr() as i32;
                                let len42 = vec42.len() as i32;
                                *((ptr0 + 40) as *mut i32) = len42;
                                *((ptr0 + 36) as *mut i32) = ptr42;
                                
                              },
                              VecValue::TypeUvec4(e) => {
                                *((ptr0 + 32) as *mut u8) = (17i32) as u8;
                                let vec43 = e;
                                let ptr43 = vec43.as_ptr() as i32;
                                let len43 = vec43.len() as i32;
                                *((ptr0 + 40) as *mut i32) = len43;
                                *((ptr0 + 36) as *mut i32) = ptr43;
                                
                              },
                              VecValue::TypeProceduralMeshHandle(e) => {
                                *((ptr0 + 32) as *mut u8) = (18i32) as u8;
                                let vec44 = e;
                                let ptr44 = vec44.as_ptr() as i32;
                                let len44 = vec44.len() as i32;
                                *((ptr0 + 40) as *mut i32) = len44;
                                *((ptr0 + 36) as *mut i32) = ptr44;
                                
                              },
                              VecValue::TypeProceduralTextureHandle(e) => {
                                *((ptr0 + 32) as *mut u8) = (19i32) as u8;
                                let vec45 = e;
                                let ptr45 = vec45.as_ptr() as i32;
                                let len45 = vec45.len() as i32;
                                *((ptr0 + 40) as *mut i32) = len45;
                                *((ptr0 + 36) as *mut i32) = ptr45;
                                
                              },
                              VecValue::TypeProceduralSamplerHandle(e) => {
                                *((ptr0 + 32) as *mut u8) = (20i32) as u8;
                                let vec46 = e;
                                let ptr46 = vec46.as_ptr() as i32;
                                let len46 = vec46.len() as i32;
                                *((ptr0 + 40) as *mut i32) = len46;
                                *((ptr0 + 36) as *mut i32) = ptr46;
                                
                              },
                              VecValue::TypeProceduralMaterialHandle(e) => {
                                *((ptr0 + 32) as *mut u8) = (21i32) as u8;
                                let vec47 = e;
                                let ptr47 = vec47.as_ptr() as i32;
                                let len47 = vec47.len() as i32;
                                *((ptr0 + 40) as *mut i32) = len47;
                                *((ptr0 + 36) as *mut i32) = ptr47;
                                
                              },
                            };
                            
                          },
                          Value::TypeOption(e) => {
                            *((ptr0 + 24) as *mut u8) = (23i32) as u8;
                            match e {
                              OptionValue::TypeEmpty(e) => {
                                *((ptr0 + 32) as *mut u8) = (0i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                    let () = e;
                                    
                                  },
                                  None => {
                                    {
                                      *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeBool(e) => {
                                *((ptr0 + 32) as *mut u8) = (1i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                    *((ptr0 + 41) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                    
                                  },
                                  None => {
                                    {
                                      *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeEntityId(e) => {
                                *((ptr0 + 32) as *mut u8) = (2i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                    let super::types::EntityId{ id0:id049, id1:id149, } = e;
                                    *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(id049);
                                    *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(id149);
                                    
                                  },
                                  None => {
                                    {
                                      *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeF32(e) => {
                                *((ptr0 + 32) as *mut u8) = (3i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                    *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(e);
                                    
                                  },
                                  None => {
                                    {
                                      *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeF64(e) => {
                                *((ptr0 + 32) as *mut u8) = (4i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                    *((ptr0 + 48) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                    
                                  },
                                  None => {
                                    {
                                      *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeMat4(e) => {
                                *((ptr0 + 32) as *mut u8) = (5i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                    let super::types::Mat4{ x:x50, y:y50, z:z50, w:w50, } = e;
                                    let super::types::Vec4{ x:x51, y:y51, z:z51, w:w51, } = x50;
                                    *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x51);
                                    *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y51);
                                    *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z51);
                                    *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w51);
                                    let super::types::Vec4{ x:x52, y:y52, z:z52, w:w52, } = y50;
                                    *((ptr0 + 60) as *mut f32) = wit_bindgen::rt::as_f32(x52);
                                    *((ptr0 + 64) as *mut f32) = wit_bindgen::rt::as_f32(y52);
                                    *((ptr0 + 68) as *mut f32) = wit_bindgen::rt::as_f32(z52);
                                    *((ptr0 + 72) as *mut f32) = wit_bindgen::rt::as_f32(w52);
                                    let super::types::Vec4{ x:x53, y:y53, z:z53, w:w53, } = z50;
                                    *((ptr0 + 76) as *mut f32) = wit_bindgen::rt::as_f32(x53);
                                    *((ptr0 + 80) as *mut f32) = wit_bindgen::rt::as_f32(y53);
                                    *((ptr0 + 84) as *mut f32) = wit_bindgen::rt::as_f32(z53);
                                    *((ptr0 + 88) as *mut f32) = wit_bindgen::rt::as_f32(w53);
                                    let super::types::Vec4{ x:x54, y:y54, z:z54, w:w54, } = w50;
                                    *((ptr0 + 92) as *mut f32) = wit_bindgen::rt::as_f32(x54);
                                    *((ptr0 + 96) as *mut f32) = wit_bindgen::rt::as_f32(y54);
                                    *((ptr0 + 100) as *mut f32) = wit_bindgen::rt::as_f32(z54);
                                    *((ptr0 + 104) as *mut f32) = wit_bindgen::rt::as_f32(w54);
                                    
                                  },
                                  None => {
                                    {
                                      *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeI32(e) => {
                                *((ptr0 + 32) as *mut u8) = (6i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                    *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                    
                                  },
                                  None => {
                                    {
                                      *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeQuat(e) => {
                                *((ptr0 + 32) as *mut u8) = (7i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                    let super::types::Quat{ x:x55, y:y55, z:z55, w:w55, } = e;
                                    *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x55);
                                    *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y55);
                                    *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z55);
                                    *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w55);
                                    
                                  },
                                  None => {
                                    {
                                      *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeString(e) => {
                                *((ptr0 + 32) as *mut u8) = (8i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                    let vec56 = e;
                                    let ptr56 = vec56.as_ptr() as i32;
                                    let len56 = vec56.len() as i32;
                                    *((ptr0 + 48) as *mut i32) = len56;
                                    *((ptr0 + 44) as *mut i32) = ptr56;
                                    
                                  },
                                  None => {
                                    {
                                      *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeU8(e) => {
                                *((ptr0 + 32) as *mut u8) = (9i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                    *((ptr0 + 41) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                    
                                  },
                                  None => {
                                    {
                                      *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeU32(e) => {
                                *((ptr0 + 32) as *mut u8) = (10i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                    *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                    
                                  },
                                  None => {
                                    {
                                      *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeU64(e) => {
                                *((ptr0 + 32) as *mut u8) = (11i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                    *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                    
                                  },
                                  None => {
                                    {
                                      *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeVec2(e) => {
                                *((ptr0 + 32) as *mut u8) = (12i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                    let super::types::Vec2{ x:x57, y:y57, } = e;
                                    *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x57);
                                    *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y57);
                                    
                                  },
                                  None => {
                                    {
                                      *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeVec3(e) => {
                                *((ptr0 + 32) as *mut u8) = (13i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                    let super::types::Vec3{ x:x58, y:y58, z:z58, } = e;
                                    *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x58);
                                    *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y58);
                                    *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z58);
                                    
                                  },
                                  None => {
                                    {
                                      *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeVec4(e) => {
                                *((ptr0 + 32) as *mut u8) = (14i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                    let super::types::Vec4{ x:x59, y:y59, z:z59, w:w59, } = e;
                                    *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x59);
                                    *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y59);
                                    *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z59);
                                    *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w59);
                                    
                                  },
                                  None => {
                                    {
                                      *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeUvec2(e) => {
                                *((ptr0 + 32) as *mut u8) = (15i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                    let super::types::Uvec2{ x:x60, y:y60, } = e;
                                    *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x60);
                                    *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y60);
                                    
                                  },
                                  None => {
                                    {
                                      *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeUvec3(e) => {
                                *((ptr0 + 32) as *mut u8) = (16i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                    let super::types::Uvec3{ x:x61, y:y61, z:z61, } = e;
                                    *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x61);
                                    *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y61);
                                    *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z61);
                                    
                                  },
                                  None => {
                                    {
                                      *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeUvec4(e) => {
                                *((ptr0 + 32) as *mut u8) = (17i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                    let super::types::Uvec4{ x:x62, y:y62, z:z62, w:w62, } = e;
                                    *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x62);
                                    *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y62);
                                    *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z62);
                                    *((ptr0 + 56) as *mut i32) = wit_bindgen::rt::as_i32(w62);
                                    
                                  },
                                  None => {
                                    {
                                      *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeProceduralMeshHandle(e) => {
                                *((ptr0 + 32) as *mut u8) = (18i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                    let super::client_mesh::Handle{ ulid:ulid63, } = e;
                                    let (t64_0, t64_1, ) = ulid63;
                                    *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t64_0);
                                    *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t64_1);
                                    
                                  },
                                  None => {
                                    {
                                      *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeProceduralTextureHandle(e) => {
                                *((ptr0 + 32) as *mut u8) = (19i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                    let super::client_texture::Handle{ ulid:ulid65, } = e;
                                    let (t66_0, t66_1, ) = ulid65;
                                    *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t66_0);
                                    *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t66_1);
                                    
                                  },
                                  None => {
                                    {
                                      *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeProceduralSamplerHandle(e) => {
                                *((ptr0 + 32) as *mut u8) = (20i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                    let super::client_sampler::Handle{ ulid:ulid67, } = e;
                                    let (t68_0, t68_1, ) = ulid67;
                                    *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t68_0);
                                    *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t68_1);
                                    
                                  },
                                  None => {
                                    {
                                      *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeProceduralMaterialHandle(e) => {
                                *((ptr0 + 32) as *mut u8) = (21i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                    let super::client_material::Handle{ ulid:ulid69, } = e;
                                    let (t70_0, t70_1, ) = ulid69;
                                    *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t70_0);
                                    *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t70_1);
                                    
                                  },
                                  None => {
                                    {
                                      *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                            };
                            
                          },
                        };
                        
                        #[link(wasm_import_module = "component")]
                        extern "C" {
                          #[cfg_attr(target_arch = "wasm32", link_name = "set-component")]
                          #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_set-component")]
                          fn wit_import(
                          _: i32, );
                        }
                        wit_import(ptr0);
                        for (ptr, layout) in cleanup_list {
                          
                          if layout.size() != 0 {
                            
                            alloc::dealloc(ptr, layout);
                            
                          }
                          
                        }
                      }
                    }
                    #[allow(clippy::all)]
                    pub fn set_components(entity: EntityId,data: &Entity,){
                      
                      #[allow(unused_imports)]
                      use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                      unsafe {
                        let mut cleanup_list = Vec::new();
                        let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                        let vec71 = data;
                        let len71 = vec71.len() as i32;
                        let layout71 = alloc::Layout::from_size_align_unchecked(vec71.len() * 96, 8);
                        let result71 = if layout71.size() != 0
                        {
                          let ptr = alloc::alloc(layout71);
                          if ptr.is_null()
                          {
                            alloc::handle_alloc_error(layout71);
                          }
                          ptr
                        }else {
                          core::ptr::null_mut()
                        };
                        for (i, e) in vec71.into_iter().enumerate() {
                          let base = result71 as i32 + (i as i32) * 96;
                          {
                            let (t1_0, t1_1, ) = e;
                            *((base + 0) as *mut i32) = wit_bindgen::rt::as_i32(t1_0);
                            match t1_1 {
                              Value::TypeEmpty(e) => {
                                *((base + 8) as *mut u8) = (0i32) as u8;
                                let () = e;
                                
                              },
                              Value::TypeBool(e) => {
                                *((base + 8) as *mut u8) = (1i32) as u8;
                                *((base + 16) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                
                              },
                              Value::TypeEntityId(e) => {
                                *((base + 8) as *mut u8) = (2i32) as u8;
                                let super::types::EntityId{ id0:id03, id1:id13, } = e;
                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(id03);
                                *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(id13);
                                
                              },
                              Value::TypeF32(e) => {
                                *((base + 8) as *mut u8) = (3i32) as u8;
                                *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(e);
                                
                              },
                              Value::TypeF64(e) => {
                                *((base + 8) as *mut u8) = (4i32) as u8;
                                *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                
                              },
                              Value::TypeMat4(e) => {
                                *((base + 8) as *mut u8) = (5i32) as u8;
                                let super::types::Mat4{ x:x4, y:y4, z:z4, w:w4, } = e;
                                let super::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = x4;
                                *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x5);
                                *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y5);
                                *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z5);
                                *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w5);
                                let super::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = y4;
                                *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(x6);
                                *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(y6);
                                *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(z6);
                                *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(w6);
                                let super::types::Vec4{ x:x7, y:y7, z:z7, w:w7, } = z4;
                                *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(x7);
                                *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(y7);
                                *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(z7);
                                *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(w7);
                                let super::types::Vec4{ x:x8, y:y8, z:z8, w:w8, } = w4;
                                *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(x8);
                                *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(y8);
                                *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(z8);
                                *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(w8);
                                
                              },
                              Value::TypeI32(e) => {
                                *((base + 8) as *mut u8) = (6i32) as u8;
                                *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                
                              },
                              Value::TypeQuat(e) => {
                                *((base + 8) as *mut u8) = (7i32) as u8;
                                let super::types::Quat{ x:x9, y:y9, z:z9, w:w9, } = e;
                                *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x9);
                                *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y9);
                                *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z9);
                                *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w9);
                                
                              },
                              Value::TypeString(e) => {
                                *((base + 8) as *mut u8) = (8i32) as u8;
                                let vec10 = e;
                                let ptr10 = vec10.as_ptr() as i32;
                                let len10 = vec10.len() as i32;
                                *((base + 20) as *mut i32) = len10;
                                *((base + 16) as *mut i32) = ptr10;
                                
                              },
                              Value::TypeU8(e) => {
                                *((base + 8) as *mut u8) = (9i32) as u8;
                                *((base + 16) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                
                              },
                              Value::TypeU32(e) => {
                                *((base + 8) as *mut u8) = (10i32) as u8;
                                *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                
                              },
                              Value::TypeU64(e) => {
                                *((base + 8) as *mut u8) = (11i32) as u8;
                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                
                              },
                              Value::TypeVec2(e) => {
                                *((base + 8) as *mut u8) = (12i32) as u8;
                                let super::types::Vec2{ x:x11, y:y11, } = e;
                                *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x11);
                                *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y11);
                                
                              },
                              Value::TypeVec3(e) => {
                                *((base + 8) as *mut u8) = (13i32) as u8;
                                let super::types::Vec3{ x:x12, y:y12, z:z12, } = e;
                                *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x12);
                                *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y12);
                                *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z12);
                                
                              },
                              Value::TypeVec4(e) => {
                                *((base + 8) as *mut u8) = (14i32) as u8;
                                let super::types::Vec4{ x:x13, y:y13, z:z13, w:w13, } = e;
                                *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x13);
                                *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y13);
                                *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z13);
                                *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w13);
                                
                              },
                              Value::TypeUvec2(e) => {
                                *((base + 8) as *mut u8) = (15i32) as u8;
                                let super::types::Uvec2{ x:x14, y:y14, } = e;
                                *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x14);
                                *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y14);
                                
                              },
                              Value::TypeUvec3(e) => {
                                *((base + 8) as *mut u8) = (16i32) as u8;
                                let super::types::Uvec3{ x:x15, y:y15, z:z15, } = e;
                                *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x15);
                                *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y15);
                                *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z15);
                                
                              },
                              Value::TypeUvec4(e) => {
                                *((base + 8) as *mut u8) = (17i32) as u8;
                                let super::types::Uvec4{ x:x16, y:y16, z:z16, w:w16, } = e;
                                *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x16);
                                *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y16);
                                *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z16);
                                *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(w16);
                                
                              },
                              Value::TypeProceduralMeshHandle(e) => {
                                *((base + 8) as *mut u8) = (18i32) as u8;
                                let super::client_mesh::Handle{ ulid:ulid17, } = e;
                                let (t18_0, t18_1, ) = ulid17;
                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t18_0);
                                *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t18_1);
                                
                              },
                              Value::TypeProceduralTextureHandle(e) => {
                                *((base + 8) as *mut u8) = (19i32) as u8;
                                let super::client_texture::Handle{ ulid:ulid19, } = e;
                                let (t20_0, t20_1, ) = ulid19;
                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t20_0);
                                *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t20_1);
                                
                              },
                              Value::TypeProceduralSamplerHandle(e) => {
                                *((base + 8) as *mut u8) = (20i32) as u8;
                                let super::client_sampler::Handle{ ulid:ulid21, } = e;
                                let (t22_0, t22_1, ) = ulid21;
                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t22_0);
                                *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t22_1);
                                
                              },
                              Value::TypeProceduralMaterialHandle(e) => {
                                *((base + 8) as *mut u8) = (21i32) as u8;
                                let super::client_material::Handle{ ulid:ulid23, } = e;
                                let (t24_0, t24_1, ) = ulid23;
                                *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t24_0);
                                *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t24_1);
                                
                              },
                              Value::TypeVec(e) => {
                                *((base + 8) as *mut u8) = (22i32) as u8;
                                match e {
                                  VecValue::TypeEmpty(e) => {
                                    *((base + 16) as *mut u8) = (0i32) as u8;
                                    let vec25 = e;
                                    let ptr25 = vec25.as_ptr() as i32;
                                    let len25 = vec25.len() as i32;
                                    *((base + 24) as *mut i32) = len25;
                                    *((base + 20) as *mut i32) = ptr25;
                                    
                                  },
                                  VecValue::TypeBool(e) => {
                                    *((base + 16) as *mut u8) = (1i32) as u8;
                                    let vec26 = e;
                                    let len26 = vec26.len() as i32;
                                    let layout26 = alloc::Layout::from_size_align_unchecked(vec26.len() * 1, 1);
                                    let result26 = if layout26.size() != 0
                                    {
                                      let ptr = alloc::alloc(layout26);
                                      if ptr.is_null()
                                      {
                                        alloc::handle_alloc_error(layout26);
                                      }
                                      ptr
                                    }else {
                                      core::ptr::null_mut()
                                    };
                                    for (i, e) in vec26.into_iter().enumerate() {
                                      let base = result26 as i32 + (i as i32) * 1;
                                      {
                                        *((base + 0) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                        
                                      }}
                                      *((base + 24) as *mut i32) = len26;
                                      *((base + 20) as *mut i32) = result26 as i32;
                                      cleanup_list.extend_from_slice(&[(result26, layout26),]);
                                      
                                    },
                                    VecValue::TypeEntityId(e) => {
                                      *((base + 16) as *mut u8) = (2i32) as u8;
                                      let vec27 = e;
                                      let ptr27 = vec27.as_ptr() as i32;
                                      let len27 = vec27.len() as i32;
                                      *((base + 24) as *mut i32) = len27;
                                      *((base + 20) as *mut i32) = ptr27;
                                      
                                    },
                                    VecValue::TypeF32(e) => {
                                      *((base + 16) as *mut u8) = (3i32) as u8;
                                      let vec28 = e;
                                      let ptr28 = vec28.as_ptr() as i32;
                                      let len28 = vec28.len() as i32;
                                      *((base + 24) as *mut i32) = len28;
                                      *((base + 20) as *mut i32) = ptr28;
                                      
                                    },
                                    VecValue::TypeF64(e) => {
                                      *((base + 16) as *mut u8) = (4i32) as u8;
                                      let vec29 = e;
                                      let ptr29 = vec29.as_ptr() as i32;
                                      let len29 = vec29.len() as i32;
                                      *((base + 24) as *mut i32) = len29;
                                      *((base + 20) as *mut i32) = ptr29;
                                      
                                    },
                                    VecValue::TypeMat4(e) => {
                                      *((base + 16) as *mut u8) = (5i32) as u8;
                                      let vec30 = e;
                                      let ptr30 = vec30.as_ptr() as i32;
                                      let len30 = vec30.len() as i32;
                                      *((base + 24) as *mut i32) = len30;
                                      *((base + 20) as *mut i32) = ptr30;
                                      
                                    },
                                    VecValue::TypeI32(e) => {
                                      *((base + 16) as *mut u8) = (6i32) as u8;
                                      let vec31 = e;
                                      let ptr31 = vec31.as_ptr() as i32;
                                      let len31 = vec31.len() as i32;
                                      *((base + 24) as *mut i32) = len31;
                                      *((base + 20) as *mut i32) = ptr31;
                                      
                                    },
                                    VecValue::TypeQuat(e) => {
                                      *((base + 16) as *mut u8) = (7i32) as u8;
                                      let vec32 = e;
                                      let ptr32 = vec32.as_ptr() as i32;
                                      let len32 = vec32.len() as i32;
                                      *((base + 24) as *mut i32) = len32;
                                      *((base + 20) as *mut i32) = ptr32;
                                      
                                    },
                                    VecValue::TypeString(e) => {
                                      *((base + 16) as *mut u8) = (8i32) as u8;
                                      let vec34 = e;
                                      let len34 = vec34.len() as i32;
                                      let layout34 = alloc::Layout::from_size_align_unchecked(vec34.len() * 8, 4);
                                      let result34 = if layout34.size() != 0
                                      {
                                        let ptr = alloc::alloc(layout34);
                                        if ptr.is_null()
                                        {
                                          alloc::handle_alloc_error(layout34);
                                        }
                                        ptr
                                      }else {
                                        core::ptr::null_mut()
                                      };
                                      for (i, e) in vec34.into_iter().enumerate() {
                                        let base = result34 as i32 + (i as i32) * 8;
                                        {
                                          let vec33 = e;
                                          let ptr33 = vec33.as_ptr() as i32;
                                          let len33 = vec33.len() as i32;
                                          *((base + 4) as *mut i32) = len33;
                                          *((base + 0) as *mut i32) = ptr33;
                                          
                                        }}
                                        *((base + 24) as *mut i32) = len34;
                                        *((base + 20) as *mut i32) = result34 as i32;
                                        cleanup_list.extend_from_slice(&[(result34, layout34),]);
                                        
                                      },
                                      VecValue::TypeU8(e) => {
                                        *((base + 16) as *mut u8) = (9i32) as u8;
                                        let vec35 = e;
                                        let ptr35 = vec35.as_ptr() as i32;
                                        let len35 = vec35.len() as i32;
                                        *((base + 24) as *mut i32) = len35;
                                        *((base + 20) as *mut i32) = ptr35;
                                        
                                      },
                                      VecValue::TypeU32(e) => {
                                        *((base + 16) as *mut u8) = (10i32) as u8;
                                        let vec36 = e;
                                        let ptr36 = vec36.as_ptr() as i32;
                                        let len36 = vec36.len() as i32;
                                        *((base + 24) as *mut i32) = len36;
                                        *((base + 20) as *mut i32) = ptr36;
                                        
                                      },
                                      VecValue::TypeU64(e) => {
                                        *((base + 16) as *mut u8) = (11i32) as u8;
                                        let vec37 = e;
                                        let ptr37 = vec37.as_ptr() as i32;
                                        let len37 = vec37.len() as i32;
                                        *((base + 24) as *mut i32) = len37;
                                        *((base + 20) as *mut i32) = ptr37;
                                        
                                      },
                                      VecValue::TypeVec2(e) => {
                                        *((base + 16) as *mut u8) = (12i32) as u8;
                                        let vec38 = e;
                                        let ptr38 = vec38.as_ptr() as i32;
                                        let len38 = vec38.len() as i32;
                                        *((base + 24) as *mut i32) = len38;
                                        *((base + 20) as *mut i32) = ptr38;
                                        
                                      },
                                      VecValue::TypeVec3(e) => {
                                        *((base + 16) as *mut u8) = (13i32) as u8;
                                        let vec39 = e;
                                        let ptr39 = vec39.as_ptr() as i32;
                                        let len39 = vec39.len() as i32;
                                        *((base + 24) as *mut i32) = len39;
                                        *((base + 20) as *mut i32) = ptr39;
                                        
                                      },
                                      VecValue::TypeVec4(e) => {
                                        *((base + 16) as *mut u8) = (14i32) as u8;
                                        let vec40 = e;
                                        let ptr40 = vec40.as_ptr() as i32;
                                        let len40 = vec40.len() as i32;
                                        *((base + 24) as *mut i32) = len40;
                                        *((base + 20) as *mut i32) = ptr40;
                                        
                                      },
                                      VecValue::TypeUvec2(e) => {
                                        *((base + 16) as *mut u8) = (15i32) as u8;
                                        let vec41 = e;
                                        let ptr41 = vec41.as_ptr() as i32;
                                        let len41 = vec41.len() as i32;
                                        *((base + 24) as *mut i32) = len41;
                                        *((base + 20) as *mut i32) = ptr41;
                                        
                                      },
                                      VecValue::TypeUvec3(e) => {
                                        *((base + 16) as *mut u8) = (16i32) as u8;
                                        let vec42 = e;
                                        let ptr42 = vec42.as_ptr() as i32;
                                        let len42 = vec42.len() as i32;
                                        *((base + 24) as *mut i32) = len42;
                                        *((base + 20) as *mut i32) = ptr42;
                                        
                                      },
                                      VecValue::TypeUvec4(e) => {
                                        *((base + 16) as *mut u8) = (17i32) as u8;
                                        let vec43 = e;
                                        let ptr43 = vec43.as_ptr() as i32;
                                        let len43 = vec43.len() as i32;
                                        *((base + 24) as *mut i32) = len43;
                                        *((base + 20) as *mut i32) = ptr43;
                                        
                                      },
                                      VecValue::TypeProceduralMeshHandle(e) => {
                                        *((base + 16) as *mut u8) = (18i32) as u8;
                                        let vec44 = e;
                                        let ptr44 = vec44.as_ptr() as i32;
                                        let len44 = vec44.len() as i32;
                                        *((base + 24) as *mut i32) = len44;
                                        *((base + 20) as *mut i32) = ptr44;
                                        
                                      },
                                      VecValue::TypeProceduralTextureHandle(e) => {
                                        *((base + 16) as *mut u8) = (19i32) as u8;
                                        let vec45 = e;
                                        let ptr45 = vec45.as_ptr() as i32;
                                        let len45 = vec45.len() as i32;
                                        *((base + 24) as *mut i32) = len45;
                                        *((base + 20) as *mut i32) = ptr45;
                                        
                                      },
                                      VecValue::TypeProceduralSamplerHandle(e) => {
                                        *((base + 16) as *mut u8) = (20i32) as u8;
                                        let vec46 = e;
                                        let ptr46 = vec46.as_ptr() as i32;
                                        let len46 = vec46.len() as i32;
                                        *((base + 24) as *mut i32) = len46;
                                        *((base + 20) as *mut i32) = ptr46;
                                        
                                      },
                                      VecValue::TypeProceduralMaterialHandle(e) => {
                                        *((base + 16) as *mut u8) = (21i32) as u8;
                                        let vec47 = e;
                                        let ptr47 = vec47.as_ptr() as i32;
                                        let len47 = vec47.len() as i32;
                                        *((base + 24) as *mut i32) = len47;
                                        *((base + 20) as *mut i32) = ptr47;
                                        
                                      },
                                    };
                                    
                                  },
                                  Value::TypeOption(e) => {
                                    *((base + 8) as *mut u8) = (23i32) as u8;
                                    match e {
                                      OptionValue::TypeEmpty(e) => {
                                        *((base + 16) as *mut u8) = (0i32) as u8;
                                        match e {
                                          Some(e) => {
                                            *((base + 24) as *mut u8) = (1i32) as u8;
                                            let () = e;
                                            
                                          },
                                          None => {
                                            {
                                              *((base + 24) as *mut u8) = (0i32) as u8;
                                              
                                            }
                                          },
                                        };
                                      },
                                      OptionValue::TypeBool(e) => {
                                        *((base + 16) as *mut u8) = (1i32) as u8;
                                        match e {
                                          Some(e) => {
                                            *((base + 24) as *mut u8) = (1i32) as u8;
                                            *((base + 25) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                            
                                          },
                                          None => {
                                            {
                                              *((base + 24) as *mut u8) = (0i32) as u8;
                                              
                                            }
                                          },
                                        };
                                      },
                                      OptionValue::TypeEntityId(e) => {
                                        *((base + 16) as *mut u8) = (2i32) as u8;
                                        match e {
                                          Some(e) => {
                                            *((base + 24) as *mut u8) = (1i32) as u8;
                                            let super::types::EntityId{ id0:id049, id1:id149, } = e;
                                            *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(id049);
                                            *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(id149);
                                            
                                          },
                                          None => {
                                            {
                                              *((base + 24) as *mut u8) = (0i32) as u8;
                                              
                                            }
                                          },
                                        };
                                      },
                                      OptionValue::TypeF32(e) => {
                                        *((base + 16) as *mut u8) = (3i32) as u8;
                                        match e {
                                          Some(e) => {
                                            *((base + 24) as *mut u8) = (1i32) as u8;
                                            *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(e);
                                            
                                          },
                                          None => {
                                            {
                                              *((base + 24) as *mut u8) = (0i32) as u8;
                                              
                                            }
                                          },
                                        };
                                      },
                                      OptionValue::TypeF64(e) => {
                                        *((base + 16) as *mut u8) = (4i32) as u8;
                                        match e {
                                          Some(e) => {
                                            *((base + 24) as *mut u8) = (1i32) as u8;
                                            *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                            
                                          },
                                          None => {
                                            {
                                              *((base + 24) as *mut u8) = (0i32) as u8;
                                              
                                            }
                                          },
                                        };
                                      },
                                      OptionValue::TypeMat4(e) => {
                                        *((base + 16) as *mut u8) = (5i32) as u8;
                                        match e {
                                          Some(e) => {
                                            *((base + 24) as *mut u8) = (1i32) as u8;
                                            let super::types::Mat4{ x:x50, y:y50, z:z50, w:w50, } = e;
                                            let super::types::Vec4{ x:x51, y:y51, z:z51, w:w51, } = x50;
                                            *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x51);
                                            *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y51);
                                            *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z51);
                                            *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w51);
                                            let super::types::Vec4{ x:x52, y:y52, z:z52, w:w52, } = y50;
                                            *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(x52);
                                            *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(y52);
                                            *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(z52);
                                            *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(w52);
                                            let super::types::Vec4{ x:x53, y:y53, z:z53, w:w53, } = z50;
                                            *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(x53);
                                            *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(y53);
                                            *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(z53);
                                            *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(w53);
                                            let super::types::Vec4{ x:x54, y:y54, z:z54, w:w54, } = w50;
                                            *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(x54);
                                            *((base + 80) as *mut f32) = wit_bindgen::rt::as_f32(y54);
                                            *((base + 84) as *mut f32) = wit_bindgen::rt::as_f32(z54);
                                            *((base + 88) as *mut f32) = wit_bindgen::rt::as_f32(w54);
                                            
                                          },
                                          None => {
                                            {
                                              *((base + 24) as *mut u8) = (0i32) as u8;
                                              
                                            }
                                          },
                                        };
                                      },
                                      OptionValue::TypeI32(e) => {
                                        *((base + 16) as *mut u8) = (6i32) as u8;
                                        match e {
                                          Some(e) => {
                                            *((base + 24) as *mut u8) = (1i32) as u8;
                                            *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                            
                                          },
                                          None => {
                                            {
                                              *((base + 24) as *mut u8) = (0i32) as u8;
                                              
                                            }
                                          },
                                        };
                                      },
                                      OptionValue::TypeQuat(e) => {
                                        *((base + 16) as *mut u8) = (7i32) as u8;
                                        match e {
                                          Some(e) => {
                                            *((base + 24) as *mut u8) = (1i32) as u8;
                                            let super::types::Quat{ x:x55, y:y55, z:z55, w:w55, } = e;
                                            *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x55);
                                            *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y55);
                                            *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z55);
                                            *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w55);
                                            
                                          },
                                          None => {
                                            {
                                              *((base + 24) as *mut u8) = (0i32) as u8;
                                              
                                            }
                                          },
                                        };
                                      },
                                      OptionValue::TypeString(e) => {
                                        *((base + 16) as *mut u8) = (8i32) as u8;
                                        match e {
                                          Some(e) => {
                                            *((base + 24) as *mut u8) = (1i32) as u8;
                                            let vec56 = e;
                                            let ptr56 = vec56.as_ptr() as i32;
                                            let len56 = vec56.len() as i32;
                                            *((base + 32) as *mut i32) = len56;
                                            *((base + 28) as *mut i32) = ptr56;
                                            
                                          },
                                          None => {
                                            {
                                              *((base + 24) as *mut u8) = (0i32) as u8;
                                              
                                            }
                                          },
                                        };
                                      },
                                      OptionValue::TypeU8(e) => {
                                        *((base + 16) as *mut u8) = (9i32) as u8;
                                        match e {
                                          Some(e) => {
                                            *((base + 24) as *mut u8) = (1i32) as u8;
                                            *((base + 25) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                            
                                          },
                                          None => {
                                            {
                                              *((base + 24) as *mut u8) = (0i32) as u8;
                                              
                                            }
                                          },
                                        };
                                      },
                                      OptionValue::TypeU32(e) => {
                                        *((base + 16) as *mut u8) = (10i32) as u8;
                                        match e {
                                          Some(e) => {
                                            *((base + 24) as *mut u8) = (1i32) as u8;
                                            *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                            
                                          },
                                          None => {
                                            {
                                              *((base + 24) as *mut u8) = (0i32) as u8;
                                              
                                            }
                                          },
                                        };
                                      },
                                      OptionValue::TypeU64(e) => {
                                        *((base + 16) as *mut u8) = (11i32) as u8;
                                        match e {
                                          Some(e) => {
                                            *((base + 24) as *mut u8) = (1i32) as u8;
                                            *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                            
                                          },
                                          None => {
                                            {
                                              *((base + 24) as *mut u8) = (0i32) as u8;
                                              
                                            }
                                          },
                                        };
                                      },
                                      OptionValue::TypeVec2(e) => {
                                        *((base + 16) as *mut u8) = (12i32) as u8;
                                        match e {
                                          Some(e) => {
                                            *((base + 24) as *mut u8) = (1i32) as u8;
                                            let super::types::Vec2{ x:x57, y:y57, } = e;
                                            *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x57);
                                            *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y57);
                                            
                                          },
                                          None => {
                                            {
                                              *((base + 24) as *mut u8) = (0i32) as u8;
                                              
                                            }
                                          },
                                        };
                                      },
                                      OptionValue::TypeVec3(e) => {
                                        *((base + 16) as *mut u8) = (13i32) as u8;
                                        match e {
                                          Some(e) => {
                                            *((base + 24) as *mut u8) = (1i32) as u8;
                                            let super::types::Vec3{ x:x58, y:y58, z:z58, } = e;
                                            *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x58);
                                            *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y58);
                                            *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z58);
                                            
                                          },
                                          None => {
                                            {
                                              *((base + 24) as *mut u8) = (0i32) as u8;
                                              
                                            }
                                          },
                                        };
                                      },
                                      OptionValue::TypeVec4(e) => {
                                        *((base + 16) as *mut u8) = (14i32) as u8;
                                        match e {
                                          Some(e) => {
                                            *((base + 24) as *mut u8) = (1i32) as u8;
                                            let super::types::Vec4{ x:x59, y:y59, z:z59, w:w59, } = e;
                                            *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x59);
                                            *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y59);
                                            *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z59);
                                            *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w59);
                                            
                                          },
                                          None => {
                                            {
                                              *((base + 24) as *mut u8) = (0i32) as u8;
                                              
                                            }
                                          },
                                        };
                                      },
                                      OptionValue::TypeUvec2(e) => {
                                        *((base + 16) as *mut u8) = (15i32) as u8;
                                        match e {
                                          Some(e) => {
                                            *((base + 24) as *mut u8) = (1i32) as u8;
                                            let super::types::Uvec2{ x:x60, y:y60, } = e;
                                            *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x60);
                                            *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y60);
                                            
                                          },
                                          None => {
                                            {
                                              *((base + 24) as *mut u8) = (0i32) as u8;
                                              
                                            }
                                          },
                                        };
                                      },
                                      OptionValue::TypeUvec3(e) => {
                                        *((base + 16) as *mut u8) = (16i32) as u8;
                                        match e {
                                          Some(e) => {
                                            *((base + 24) as *mut u8) = (1i32) as u8;
                                            let super::types::Uvec3{ x:x61, y:y61, z:z61, } = e;
                                            *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x61);
                                            *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y61);
                                            *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z61);
                                            
                                          },
                                          None => {
                                            {
                                              *((base + 24) as *mut u8) = (0i32) as u8;
                                              
                                            }
                                          },
                                        };
                                      },
                                      OptionValue::TypeUvec4(e) => {
                                        *((base + 16) as *mut u8) = (17i32) as u8;
                                        match e {
                                          Some(e) => {
                                            *((base + 24) as *mut u8) = (1i32) as u8;
                                            let super::types::Uvec4{ x:x62, y:y62, z:z62, w:w62, } = e;
                                            *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x62);
                                            *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y62);
                                            *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z62);
                                            *((base + 40) as *mut i32) = wit_bindgen::rt::as_i32(w62);
                                            
                                          },
                                          None => {
                                            {
                                              *((base + 24) as *mut u8) = (0i32) as u8;
                                              
                                            }
                                          },
                                        };
                                      },
                                      OptionValue::TypeProceduralMeshHandle(e) => {
                                        *((base + 16) as *mut u8) = (18i32) as u8;
                                        match e {
                                          Some(e) => {
                                            *((base + 24) as *mut u8) = (1i32) as u8;
                                            let super::client_mesh::Handle{ ulid:ulid63, } = e;
                                            let (t64_0, t64_1, ) = ulid63;
                                            *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t64_0);
                                            *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t64_1);
                                            
                                          },
                                          None => {
                                            {
                                              *((base + 24) as *mut u8) = (0i32) as u8;
                                              
                                            }
                                          },
                                        };
                                      },
                                      OptionValue::TypeProceduralTextureHandle(e) => {
                                        *((base + 16) as *mut u8) = (19i32) as u8;
                                        match e {
                                          Some(e) => {
                                            *((base + 24) as *mut u8) = (1i32) as u8;
                                            let super::client_texture::Handle{ ulid:ulid65, } = e;
                                            let (t66_0, t66_1, ) = ulid65;
                                            *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t66_0);
                                            *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t66_1);
                                            
                                          },
                                          None => {
                                            {
                                              *((base + 24) as *mut u8) = (0i32) as u8;
                                              
                                            }
                                          },
                                        };
                                      },
                                      OptionValue::TypeProceduralSamplerHandle(e) => {
                                        *((base + 16) as *mut u8) = (20i32) as u8;
                                        match e {
                                          Some(e) => {
                                            *((base + 24) as *mut u8) = (1i32) as u8;
                                            let super::client_sampler::Handle{ ulid:ulid67, } = e;
                                            let (t68_0, t68_1, ) = ulid67;
                                            *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t68_0);
                                            *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t68_1);
                                            
                                          },
                                          None => {
                                            {
                                              *((base + 24) as *mut u8) = (0i32) as u8;
                                              
                                            }
                                          },
                                        };
                                      },
                                      OptionValue::TypeProceduralMaterialHandle(e) => {
                                        *((base + 16) as *mut u8) = (21i32) as u8;
                                        match e {
                                          Some(e) => {
                                            *((base + 24) as *mut u8) = (1i32) as u8;
                                            let super::client_material::Handle{ ulid:ulid69, } = e;
                                            let (t70_0, t70_1, ) = ulid69;
                                            *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t70_0);
                                            *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t70_1);
                                            
                                          },
                                          None => {
                                            {
                                              *((base + 24) as *mut u8) = (0i32) as u8;
                                              
                                            }
                                          },
                                        };
                                      },
                                    };
                                    
                                  },
                                };
                                
                              }}
                              
                              #[link(wasm_import_module = "component")]
                              extern "C" {
                                #[cfg_attr(target_arch = "wasm32", link_name = "set-components")]
                                #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_set-components")]
                                fn wit_import(
                                _: i64, _: i64, _: i32, _: i32, );
                              }
                              wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), result71 as i32, len71);
                              if layout71.size() != 0 {
                                alloc::dealloc(result71, layout71);
                              }
                              for (ptr, layout) in cleanup_list {
                                
                                if layout.size() != 0 {
                                  
                                  alloc::dealloc(ptr, layout);
                                  
                                }
                                
                              }
                            }
                          }
                          #[allow(clippy::all)]
                          pub fn has_component(entity: EntityId,index: u32,) -> bool{
                            
                            #[allow(unused_imports)]
                            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                            unsafe {
                              let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                              
                              #[link(wasm_import_module = "component")]
                              extern "C" {
                                #[cfg_attr(target_arch = "wasm32", link_name = "has-component")]
                                #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_has-component")]
                                fn wit_import(
                                _: i64, _: i64, _: i32, ) -> i32;
                              }
                              let ret = wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_i32(index));
                              {
                                #[cfg(not(debug_assertions))]
                                { core::mem::transmute::<u8, bool>(ret as u8) }
                                #[cfg(debug_assertions)]
                                {
                                  match ret {
                                    0 => false,
                                    1 => true,
                                    _ => panic!("invalid bool discriminant"),
                                  }
                                }
                              }
                            }
                          }
                          #[allow(clippy::all)]
                          pub fn has_components(entity: EntityId,indices: &[u32],) -> bool{
                            
                            #[allow(unused_imports)]
                            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                            unsafe {
                              let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                              let vec1 = indices;
                              let ptr1 = vec1.as_ptr() as i32;
                              let len1 = vec1.len() as i32;
                              
                              #[link(wasm_import_module = "component")]
                              extern "C" {
                                #[cfg_attr(target_arch = "wasm32", link_name = "has-components")]
                                #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_has-components")]
                                fn wit_import(
                                _: i64, _: i64, _: i32, _: i32, ) -> i32;
                              }
                              let ret = wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), ptr1, len1);
                              {
                                #[cfg(not(debug_assertions))]
                                { core::mem::transmute::<u8, bool>(ret as u8) }
                                #[cfg(debug_assertions)]
                                {
                                  match ret {
                                    0 => false,
                                    1 => true,
                                    _ => panic!("invalid bool discriminant"),
                                  }
                                }
                              }
                            }
                          }
                          #[allow(clippy::all)]
                          pub fn remove_component(entity: EntityId,index: u32,){
                            
                            #[allow(unused_imports)]
                            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                            unsafe {
                              let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                              
                              #[link(wasm_import_module = "component")]
                              extern "C" {
                                #[cfg_attr(target_arch = "wasm32", link_name = "remove-component")]
                                #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_remove-component")]
                                fn wit_import(
                                _: i64, _: i64, _: i32, );
                              }
                              wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_i32(index));
                            }
                          }
                          #[allow(clippy::all)]
                          pub fn remove_components(entity: EntityId,indices: &[u32],){
                            
                            #[allow(unused_imports)]
                            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                            unsafe {
                              let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                              let vec1 = indices;
                              let ptr1 = vec1.as_ptr() as i32;
                              let len1 = vec1.len() as i32;
                              
                              #[link(wasm_import_module = "component")]
                              extern "C" {
                                #[cfg_attr(target_arch = "wasm32", link_name = "remove-components")]
                                #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_remove-components")]
                                fn wit_import(
                                _: i64, _: i64, _: i32, _: i32, );
                              }
                              wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), ptr1, len1);
                            }
                          }
                          #[allow(clippy::all)]
                          pub fn query(q: QueryBuild<'_,>,t: QueryEvent,) -> u64{
                            
                            #[allow(unused_imports)]
                            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                            unsafe {
                              let QueryBuild{ components:components0, include:include0, exclude:exclude0, changed:changed0, } = q;
                              let vec1 = components0;
                              let ptr1 = vec1.as_ptr() as i32;
                              let len1 = vec1.len() as i32;
                              let vec2 = include0;
                              let ptr2 = vec2.as_ptr() as i32;
                              let len2 = vec2.len() as i32;
                              let vec3 = exclude0;
                              let ptr3 = vec3.as_ptr() as i32;
                              let len3 = vec3.len() as i32;
                              let vec4 = changed0;
                              let ptr4 = vec4.as_ptr() as i32;
                              let len4 = vec4.len() as i32;
                              
                              #[link(wasm_import_module = "component")]
                              extern "C" {
                                #[cfg_attr(target_arch = "wasm32", link_name = "query")]
                                #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_query")]
                                fn wit_import(
                                _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ) -> i64;
                              }
                              let ret = wit_import(ptr1, len1, ptr2, len2, ptr3, len3, ptr4, len4, match t {
                                QueryEvent::Frame => 0,
                                QueryEvent::Spawn => 1,
                                QueryEvent::Despawn => 2,
                              });
                              ret as u64
                            }
                          }
                          #[allow(clippy::all)]
                          pub fn query_eval(q: u64,) -> wit_bindgen::rt::vec::Vec::<(EntityId,wit_bindgen::rt::vec::Vec::<Value>,)>{
                            
                            #[allow(unused_imports)]
                            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                            unsafe {
                              
                              #[repr(align(4))]
                              struct RetArea([u8; 8]);
                              let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                              let ptr0 = ret_area.as_mut_ptr() as i32;
                              #[link(wasm_import_module = "component")]
                              extern "C" {
                                #[cfg_attr(target_arch = "wasm32", link_name = "query-eval")]
                                #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_query-eval")]
                                fn wit_import(
                                _: i64, _: i32, );
                              }
                              wit_import(wit_bindgen::rt::as_i64(q), ptr0);
                              let base27 = *((ptr0 + 0) as *const i32);
                              let len27 = *((ptr0 + 4) as *const i32);
                              let mut result27 = Vec::with_capacity(len27 as usize);
                              for i in 0..len27 {
                                let base = base27 + i *24;
                                result27.push({
                                  let base26 = *((base + 16) as *const i32);
                                  let len26 = *((base + 20) as *const i32);
                                  let mut result26 = Vec::with_capacity(len26 as usize);
                                  for i in 0..len26 {
                                    let base = base26 + i *88;
                                    result26.push({{match i32::from(*((base + 0) as *const u8)) {
                                      0 => Value::TypeEmpty(()),
                                      1 => Value::TypeBool({
                                        #[cfg(not(debug_assertions))]
                                        { core::mem::transmute::<u8, bool>(i32::from(*((base + 8) as *const u8)) as u8) }
                                        #[cfg(debug_assertions)]
                                        {
                                          match i32::from(*((base + 8) as *const u8)) {
                                            0 => false,
                                            1 => true,
                                            _ => panic!("invalid bool discriminant"),
                                          }
                                        }
                                      }),
                                      2 => Value::TypeEntityId(super::types::EntityId{id0:*((base + 8) as *const i64) as u64, id1:*((base + 16) as *const i64) as u64, }),
                                      3 => Value::TypeF32(*((base + 8) as *const f32)),
                                      4 => Value::TypeF64(*((base + 8) as *const f64)),
                                      5 => Value::TypeMat4(super::types::Mat4{x:super::types::Vec4{x:*((base + 8) as *const f32), y:*((base + 12) as *const f32), z:*((base + 16) as *const f32), w:*((base + 20) as *const f32), }, y:super::types::Vec4{x:*((base + 24) as *const f32), y:*((base + 28) as *const f32), z:*((base + 32) as *const f32), w:*((base + 36) as *const f32), }, z:super::types::Vec4{x:*((base + 40) as *const f32), y:*((base + 44) as *const f32), z:*((base + 48) as *const f32), w:*((base + 52) as *const f32), }, w:super::types::Vec4{x:*((base + 56) as *const f32), y:*((base + 60) as *const f32), z:*((base + 64) as *const f32), w:*((base + 68) as *const f32), }, }),
                                      6 => Value::TypeI32(*((base + 8) as *const i32)),
                                      7 => Value::TypeQuat(super::types::Quat{x:*((base + 8) as *const f32), y:*((base + 12) as *const f32), z:*((base + 16) as *const f32), w:*((base + 20) as *const f32), }),
                                      8 => Value::TypeString({
                                        let len1 = *((base + 12) as *const i32) as usize;
                                        
                                        {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 8) as *const i32) as *mut _, len1, len1))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 8) as *const i32) as *mut _, len1, len1)).unwrap()}}
                                      }),
                                      9 => Value::TypeU8(i32::from(*((base + 8) as *const u8)) as u8),
                                      10 => Value::TypeU32(*((base + 8) as *const i32) as u32),
                                      11 => Value::TypeU64(*((base + 8) as *const i64) as u64),
                                      12 => Value::TypeVec2(super::types::Vec2{x:*((base + 8) as *const f32), y:*((base + 12) as *const f32), }),
                                      13 => Value::TypeVec3(super::types::Vec3{x:*((base + 8) as *const f32), y:*((base + 12) as *const f32), z:*((base + 16) as *const f32), }),
                                      14 => Value::TypeVec4(super::types::Vec4{x:*((base + 8) as *const f32), y:*((base + 12) as *const f32), z:*((base + 16) as *const f32), w:*((base + 20) as *const f32), }),
                                      15 => Value::TypeUvec2(super::types::Uvec2{x:*((base + 8) as *const i32) as u32, y:*((base + 12) as *const i32) as u32, }),
                                      16 => Value::TypeUvec3(super::types::Uvec3{x:*((base + 8) as *const i32) as u32, y:*((base + 12) as *const i32) as u32, z:*((base + 16) as *const i32) as u32, }),
                                      17 => Value::TypeUvec4(super::types::Uvec4{x:*((base + 8) as *const i32) as u32, y:*((base + 12) as *const i32) as u32, z:*((base + 16) as *const i32) as u32, w:*((base + 20) as *const i32) as u32, }),
                                      18 => Value::TypeProceduralMeshHandle(super::client_mesh::Handle{ulid:(*((base + 8) as *const i64) as u64, *((base + 16) as *const i64) as u64), }),
                                      19 => Value::TypeProceduralTextureHandle(super::client_texture::Handle{ulid:(*((base + 8) as *const i64) as u64, *((base + 16) as *const i64) as u64), }),
                                      20 => Value::TypeProceduralSamplerHandle(super::client_sampler::Handle{ulid:(*((base + 8) as *const i64) as u64, *((base + 16) as *const i64) as u64), }),
                                      21 => Value::TypeProceduralMaterialHandle(super::client_material::Handle{ulid:(*((base + 8) as *const i64) as u64, *((base + 16) as *const i64) as u64), }),
                                      22 => Value::TypeVec({{match i32::from(*((base + 8) as *const u8)) {
                                        0 => VecValue::TypeEmpty({
                                          let len2 = *((base + 16) as *const i32) as usize;
                                          
                                          Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len2, len2)
                                        }),
                                        1 => VecValue::TypeBool({
                                          let base3 = *((base + 12) as *const i32);
                                          let len3 = *((base + 16) as *const i32);
                                          let mut result3 = Vec::with_capacity(len3 as usize);
                                          for i in 0..len3 {
                                            let base = base3 + i *1;
                                            result3.push({
                                              #[cfg(not(debug_assertions))]
                                              { core::mem::transmute::<u8, bool>(i32::from(*((base + 0) as *const u8)) as u8) }
                                              #[cfg(debug_assertions)]
                                              {
                                                match i32::from(*((base + 0) as *const u8)) {
                                                  0 => false,
                                                  1 => true,
                                                  _ => panic!("invalid bool discriminant"),
                                                }
                                              }
                                            });
                                          }
                                          wit_bindgen::rt::dealloc(base3, (len3 as usize) * 1, 1);
                                          
                                          result3
                                        }),
                                        2 => VecValue::TypeEntityId({
                                          let len4 = *((base + 16) as *const i32) as usize;
                                          
                                          Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len4, len4)
                                        }),
                                        3 => VecValue::TypeF32({
                                          let len5 = *((base + 16) as *const i32) as usize;
                                          
                                          Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len5, len5)
                                        }),
                                        4 => VecValue::TypeF64({
                                          let len6 = *((base + 16) as *const i32) as usize;
                                          
                                          Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len6, len6)
                                        }),
                                        5 => VecValue::TypeMat4({
                                          let len7 = *((base + 16) as *const i32) as usize;
                                          
                                          Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len7, len7)
                                        }),
                                        6 => VecValue::TypeI32({
                                          let len8 = *((base + 16) as *const i32) as usize;
                                          
                                          Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len8, len8)
                                        }),
                                        7 => VecValue::TypeQuat({
                                          let len9 = *((base + 16) as *const i32) as usize;
                                          
                                          Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len9, len9)
                                        }),
                                        8 => VecValue::TypeString({
                                          let base11 = *((base + 12) as *const i32);
                                          let len11 = *((base + 16) as *const i32);
                                          let mut result11 = Vec::with_capacity(len11 as usize);
                                          for i in 0..len11 {
                                            let base = base11 + i *8;
                                            result11.push({
                                              let len10 = *((base + 4) as *const i32) as usize;
                                              
                                              {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len10, len10))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len10, len10)).unwrap()}}
                                            });
                                          }
                                          wit_bindgen::rt::dealloc(base11, (len11 as usize) * 8, 4);
                                          
                                          result11
                                        }),
                                        9 => VecValue::TypeU8({
                                          let len12 = *((base + 16) as *const i32) as usize;
                                          
                                          Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len12, len12)
                                        }),
                                        10 => VecValue::TypeU32({
                                          let len13 = *((base + 16) as *const i32) as usize;
                                          
                                          Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len13, len13)
                                        }),
                                        11 => VecValue::TypeU64({
                                          let len14 = *((base + 16) as *const i32) as usize;
                                          
                                          Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len14, len14)
                                        }),
                                        12 => VecValue::TypeVec2({
                                          let len15 = *((base + 16) as *const i32) as usize;
                                          
                                          Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len15, len15)
                                        }),
                                        13 => VecValue::TypeVec3({
                                          let len16 = *((base + 16) as *const i32) as usize;
                                          
                                          Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len16, len16)
                                        }),
                                        14 => VecValue::TypeVec4({
                                          let len17 = *((base + 16) as *const i32) as usize;
                                          
                                          Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len17, len17)
                                        }),
                                        15 => VecValue::TypeUvec2({
                                          let len18 = *((base + 16) as *const i32) as usize;
                                          
                                          Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len18, len18)
                                        }),
                                        16 => VecValue::TypeUvec3({
                                          let len19 = *((base + 16) as *const i32) as usize;
                                          
                                          Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len19, len19)
                                        }),
                                        17 => VecValue::TypeUvec4({
                                          let len20 = *((base + 16) as *const i32) as usize;
                                          
                                          Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len20, len20)
                                        }),
                                        18 => VecValue::TypeProceduralMeshHandle({
                                          let len21 = *((base + 16) as *const i32) as usize;
                                          
                                          Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len21, len21)
                                        }),
                                        19 => VecValue::TypeProceduralTextureHandle({
                                          let len22 = *((base + 16) as *const i32) as usize;
                                          
                                          Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len22, len22)
                                        }),
                                        20 => VecValue::TypeProceduralSamplerHandle({
                                          let len23 = *((base + 16) as *const i32) as usize;
                                          
                                          Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len23, len23)
                                        }),
                                        #[cfg(debug_assertions)]21 => VecValue::TypeProceduralMaterialHandle({
                                          let len24 = *((base + 16) as *const i32) as usize;
                                          
                                          Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len24, len24)
                                        }),
                                        #[cfg(not(debug_assertions))]_ => VecValue::TypeProceduralMaterialHandle({
                                          let len24 = *((base + 16) as *const i32) as usize;
                                          
                                          Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len24, len24)
                                        }),
                                        #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                      }}}),
                                      #[cfg(debug_assertions)]23 => Value::TypeOption({{match i32::from(*((base + 8) as *const u8)) {
                                        0 => OptionValue::TypeEmpty(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(()),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        1 => OptionValue::TypeBool(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some({
                                            #[cfg(not(debug_assertions))]
                                            { core::mem::transmute::<u8, bool>(i32::from(*((base + 17) as *const u8)) as u8) }
                                            #[cfg(debug_assertions)]
                                            {
                                              match i32::from(*((base + 17) as *const u8)) {
                                                0 => false,
                                                1 => true,
                                                _ => panic!("invalid bool discriminant"),
                                              }
                                            }
                                          }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        2 => OptionValue::TypeEntityId(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::types::EntityId{id0:*((base + 24) as *const i64) as u64, id1:*((base + 32) as *const i64) as u64, }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        3 => OptionValue::TypeF32(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(*((base + 20) as *const f32)),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        4 => OptionValue::TypeF64(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(*((base + 24) as *const f64)),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        5 => OptionValue::TypeMat4(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::types::Mat4{x:super::types::Vec4{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }, y:super::types::Vec4{x:*((base + 36) as *const f32), y:*((base + 40) as *const f32), z:*((base + 44) as *const f32), w:*((base + 48) as *const f32), }, z:super::types::Vec4{x:*((base + 52) as *const f32), y:*((base + 56) as *const f32), z:*((base + 60) as *const f32), w:*((base + 64) as *const f32), }, w:super::types::Vec4{x:*((base + 68) as *const f32), y:*((base + 72) as *const f32), z:*((base + 76) as *const f32), w:*((base + 80) as *const f32), }, }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        6 => OptionValue::TypeI32(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(*((base + 20) as *const i32)),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        7 => OptionValue::TypeQuat(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::types::Quat{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        8 => OptionValue::TypeString(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some({
                                            let len25 = *((base + 24) as *const i32) as usize;
                                            
                                            {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len25, len25))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len25, len25)).unwrap()}}
                                          }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        9 => OptionValue::TypeU8(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(i32::from(*((base + 17) as *const u8)) as u8),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        10 => OptionValue::TypeU32(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(*((base + 20) as *const i32) as u32),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        11 => OptionValue::TypeU64(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(*((base + 24) as *const i64) as u64),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        12 => OptionValue::TypeVec2(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::types::Vec2{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        13 => OptionValue::TypeVec3(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::types::Vec3{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        14 => OptionValue::TypeVec4(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::types::Vec4{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        15 => OptionValue::TypeUvec2(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::types::Uvec2{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        16 => OptionValue::TypeUvec3(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::types::Uvec3{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, z:*((base + 28) as *const i32) as u32, }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        17 => OptionValue::TypeUvec4(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::types::Uvec4{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, z:*((base + 28) as *const i32) as u32, w:*((base + 32) as *const i32) as u32, }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        18 => OptionValue::TypeProceduralMeshHandle(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::client_mesh::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        19 => OptionValue::TypeProceduralTextureHandle(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::client_texture::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        20 => OptionValue::TypeProceduralSamplerHandle(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::client_sampler::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        #[cfg(debug_assertions)]21 => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::client_material::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        #[cfg(not(debug_assertions))]_ => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::client_material::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                      }}}),
                                      #[cfg(not(debug_assertions))]_ => Value::TypeOption({{match i32::from(*((base + 8) as *const u8)) {
                                        0 => OptionValue::TypeEmpty(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(()),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        1 => OptionValue::TypeBool(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some({
                                            #[cfg(not(debug_assertions))]
                                            { core::mem::transmute::<u8, bool>(i32::from(*((base + 17) as *const u8)) as u8) }
                                            #[cfg(debug_assertions)]
                                            {
                                              match i32::from(*((base + 17) as *const u8)) {
                                                0 => false,
                                                1 => true,
                                                _ => panic!("invalid bool discriminant"),
                                              }
                                            }
                                          }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        2 => OptionValue::TypeEntityId(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::types::EntityId{id0:*((base + 24) as *const i64) as u64, id1:*((base + 32) as *const i64) as u64, }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        3 => OptionValue::TypeF32(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(*((base + 20) as *const f32)),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        4 => OptionValue::TypeF64(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(*((base + 24) as *const f64)),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        5 => OptionValue::TypeMat4(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::types::Mat4{x:super::types::Vec4{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }, y:super::types::Vec4{x:*((base + 36) as *const f32), y:*((base + 40) as *const f32), z:*((base + 44) as *const f32), w:*((base + 48) as *const f32), }, z:super::types::Vec4{x:*((base + 52) as *const f32), y:*((base + 56) as *const f32), z:*((base + 60) as *const f32), w:*((base + 64) as *const f32), }, w:super::types::Vec4{x:*((base + 68) as *const f32), y:*((base + 72) as *const f32), z:*((base + 76) as *const f32), w:*((base + 80) as *const f32), }, }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        6 => OptionValue::TypeI32(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(*((base + 20) as *const i32)),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        7 => OptionValue::TypeQuat(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::types::Quat{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        8 => OptionValue::TypeString(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some({
                                            let len25 = *((base + 24) as *const i32) as usize;
                                            
                                            {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len25, len25))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len25, len25)).unwrap()}}
                                          }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        9 => OptionValue::TypeU8(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(i32::from(*((base + 17) as *const u8)) as u8),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        10 => OptionValue::TypeU32(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(*((base + 20) as *const i32) as u32),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        11 => OptionValue::TypeU64(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(*((base + 24) as *const i64) as u64),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        12 => OptionValue::TypeVec2(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::types::Vec2{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        13 => OptionValue::TypeVec3(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::types::Vec3{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        14 => OptionValue::TypeVec4(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::types::Vec4{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        15 => OptionValue::TypeUvec2(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::types::Uvec2{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        16 => OptionValue::TypeUvec3(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::types::Uvec3{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, z:*((base + 28) as *const i32) as u32, }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        17 => OptionValue::TypeUvec4(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::types::Uvec4{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, z:*((base + 28) as *const i32) as u32, w:*((base + 32) as *const i32) as u32, }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        18 => OptionValue::TypeProceduralMeshHandle(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::client_mesh::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        19 => OptionValue::TypeProceduralTextureHandle(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::client_texture::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        20 => OptionValue::TypeProceduralSamplerHandle(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::client_sampler::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        #[cfg(debug_assertions)]21 => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::client_material::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        #[cfg(not(debug_assertions))]_ => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 16) as *const u8)) {
                                          0 => None,
                                          1 => Some(super::client_material::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }),
                                        #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                      }}}),
                                      #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                    }}});
                                  }
                                  wit_bindgen::rt::dealloc(base26, (len26 as usize) * 88, 8);
                                  
                                  (super::types::EntityId{id0:*((base + 0) as *const i64) as u64, id1:*((base + 8) as *const i64) as u64, }, result26)
                                });
                              }
                              wit_bindgen::rt::dealloc(base27, (len27 as usize) * 24, 8);
                              result27
                            }
                          }
                          
                        }
                        
                        
                        #[allow(clippy::all)]
                        pub mod entity{
                          #[used]
                          #[doc(hidden)]
                          #[cfg(target_arch = "wasm32")]
                          static __FORCE_SECTION_REF: fn() = super::__link_section;
                          
                          pub type EntityId = super::types::EntityId;
                          pub type Vec3 = super::types::Vec3;
                          pub type Mat4 = super::types::Mat4;
                          pub type EntityData = super::component::Entity;
                          /// Variant of animation action stack to blend two samples using a mask
                          #[repr(C)]
                          #[derive(Copy, Clone)]
                          pub struct AnimationStackBlend {
                            /// Blend weight [0, 1]
                            pub weight: f32,
                            /// Index into animation binder mask weights
                            pub mask: u32,
                          }
                          impl core::fmt::Debug for AnimationStackBlend {
                            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                              f.debug_struct("AnimationStackBlend").field("weight", &self.weight).field("mask", &self.mask).finish()
                            }
                          }
                          /// Variant of animation action stack that samples to specific action index
                          #[repr(C)]
                          #[derive(Copy, Clone)]
                          pub struct AnimationSamplePercentage {
                            /// Index into animation controller actions
                            pub action_index: u32,
                            /// Time [0, 1]
                            pub time_percentage: f32,
                          }
                          impl core::fmt::Debug for AnimationSamplePercentage {
                            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                              f.debug_struct("AnimationSamplePercentage").field("action-index", &self.action_index).field("time-percentage", &self.time_percentage).finish()
                            }
                          }
                          /// Variant of animation action stack that samples to specific action index
                          #[repr(C)]
                          #[derive(Copy, Clone)]
                          pub struct AnimationSampleAbsolute {
                            /// Index into animation controller actions
                            pub action_index: u32,
                            /// Time in seconds
                            pub time_absolute: f32,
                          }
                          impl core::fmt::Debug for AnimationSampleAbsolute {
                            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                              f.debug_struct("AnimationSampleAbsolute").field("action-index", &self.action_index).field("time-absolute", &self.time_absolute).finish()
                            }
                          }
                          /// Animation blend stack
                          #[derive(Clone, Copy)]
                          pub enum AnimationActionStack{
                            /// Sample action at current time
                            Sample(u32),
                            /// Sample action at time percentage
                            SamplePercentage(AnimationSamplePercentage),
                            /// Sample action at an absolute time point
                            SampleAbsolute(AnimationSampleAbsolute),
                            /// Interpolate the two samples on top of the stack
                            Interpolate(f32),
                            /// Blend the two samples on top of the stack with the binder mask weights index
                            Blend(AnimationStackBlend),
                          }
                          impl core::fmt::Debug for AnimationActionStack {
                            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                              match self {
                                AnimationActionStack::Sample(e) => {
                                  f.debug_tuple("AnimationActionStack::Sample").field(e).finish()
                                }
                                AnimationActionStack::SamplePercentage(e) => {
                                  f.debug_tuple("AnimationActionStack::SamplePercentage").field(e).finish()
                                }
                                AnimationActionStack::SampleAbsolute(e) => {
                                  f.debug_tuple("AnimationActionStack::SampleAbsolute").field(e).finish()
                                }
                                AnimationActionStack::Interpolate(e) => {
                                  f.debug_tuple("AnimationActionStack::Interpolate").field(e).finish()
                                }
                                AnimationActionStack::Blend(e) => {
                                  f.debug_tuple("AnimationActionStack::Blend").field(e).finish()
                                }
                              }
                            }
                          }
                          /// An action in an animation.
                          #[derive(Clone)]
                          pub struct AnimationAction<'a,> {
                            /// The animation clip URL to play.
                            pub clip_url: &'a str,
                            /// Whether or not this action should loop
                            pub looping: bool,
                            /// How strongly this action applies to the final blend [0-1]
                            pub weight: f32,
                          }
                          impl<'a,> core::fmt::Debug for AnimationAction<'a,> {
                            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                              f.debug_struct("AnimationAction").field("clip-url", &self.clip_url).field("looping", &self.looping).field("weight", &self.weight).finish()
                            }
                          }
                          /// Controls the animations for an entity.
                          #[derive(Clone)]
                          pub struct AnimationController<'a,> {
                            /// All of the actions that contribute to this animation.
                            /// Will be blended together.
                            pub actions: &'a [AnimationAction<'a,>],
                            /// Whether or not the first action's pose should be used as a base pose.
                            pub apply_base_pose: bool,
                          }
                          impl<'a,> core::fmt::Debug for AnimationController<'a,> {
                            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                              f.debug_struct("AnimationController").field("actions", &self.actions).field("apply-base-pose", &self.apply_base_pose).finish()
                            }
                          }
                          #[allow(clippy::all)]
                          pub fn set_animation_action_stack(entity: EntityId,stack: &[AnimationActionStack],){
                            
                            #[allow(unused_imports)]
                            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                            unsafe {
                              let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                              let vec4 = stack;
                              let len4 = vec4.len() as i32;
                              let layout4 = alloc::Layout::from_size_align_unchecked(vec4.len() * 12, 4);
                              let result4 = if layout4.size() != 0
                              {
                                let ptr = alloc::alloc(layout4);
                                if ptr.is_null()
                                {
                                  alloc::handle_alloc_error(layout4);
                                }
                                ptr
                              }else {
                                core::ptr::null_mut()
                              };
                              for (i, e) in vec4.into_iter().enumerate() {
                                let base = result4 as i32 + (i as i32) * 12;
                                {
                                  match e {
                                    AnimationActionStack::Sample(e) => {
                                      *((base + 0) as *mut u8) = (0i32) as u8;
                                      *((base + 4) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                      
                                    },
                                    AnimationActionStack::SamplePercentage(e) => {
                                      *((base + 0) as *mut u8) = (1i32) as u8;
                                      let AnimationSamplePercentage{ action_index:action_index1, time_percentage:time_percentage1, } = e;
                                      *((base + 4) as *mut i32) = wit_bindgen::rt::as_i32(action_index1);
                                      *((base + 8) as *mut f32) = wit_bindgen::rt::as_f32(time_percentage1);
                                      
                                    },
                                    AnimationActionStack::SampleAbsolute(e) => {
                                      *((base + 0) as *mut u8) = (2i32) as u8;
                                      let AnimationSampleAbsolute{ action_index:action_index2, time_absolute:time_absolute2, } = e;
                                      *((base + 4) as *mut i32) = wit_bindgen::rt::as_i32(action_index2);
                                      *((base + 8) as *mut f32) = wit_bindgen::rt::as_f32(time_absolute2);
                                      
                                    },
                                    AnimationActionStack::Interpolate(e) => {
                                      *((base + 0) as *mut u8) = (3i32) as u8;
                                      *((base + 4) as *mut f32) = wit_bindgen::rt::as_f32(e);
                                      
                                    },
                                    AnimationActionStack::Blend(e) => {
                                      *((base + 0) as *mut u8) = (4i32) as u8;
                                      let AnimationStackBlend{ weight:weight3, mask:mask3, } = e;
                                      *((base + 4) as *mut f32) = wit_bindgen::rt::as_f32(weight3);
                                      *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(mask3);
                                      
                                    },
                                  };
                                  
                                }}
                                
                                #[link(wasm_import_module = "entity")]
                                extern "C" {
                                  #[cfg_attr(target_arch = "wasm32", link_name = "set-animation-action-stack")]
                                  #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_set-animation-action-stack")]
                                  fn wit_import(
                                  _: i64, _: i64, _: i32, _: i32, );
                                }
                                wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), result4 as i32, len4);
                                if layout4.size() != 0 {
                                  alloc::dealloc(result4, layout4);
                                }
                              }
                            }
                            #[allow(clippy::all)]
                            pub fn set_animation_binder_mask(entity: EntityId,mask: &[&str],){
                              
                              #[allow(unused_imports)]
                              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                              unsafe {
                                let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                let vec2 = mask;
                                let len2 = vec2.len() as i32;
                                let layout2 = alloc::Layout::from_size_align_unchecked(vec2.len() * 8, 4);
                                let result2 = if layout2.size() != 0
                                {
                                  let ptr = alloc::alloc(layout2);
                                  if ptr.is_null()
                                  {
                                    alloc::handle_alloc_error(layout2);
                                  }
                                  ptr
                                }else {
                                  core::ptr::null_mut()
                                };
                                for (i, e) in vec2.into_iter().enumerate() {
                                  let base = result2 as i32 + (i as i32) * 8;
                                  {
                                    let vec1 = e;
                                    let ptr1 = vec1.as_ptr() as i32;
                                    let len1 = vec1.len() as i32;
                                    *((base + 4) as *mut i32) = len1;
                                    *((base + 0) as *mut i32) = ptr1;
                                    
                                  }}
                                  
                                  #[link(wasm_import_module = "entity")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "set-animation-binder-mask")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_set-animation-binder-mask")]
                                    fn wit_import(
                                    _: i64, _: i64, _: i32, _: i32, );
                                  }
                                  wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), result2 as i32, len2);
                                  if layout2.size() != 0 {
                                    alloc::dealloc(result2, layout2);
                                  }
                                }
                              }
                              #[allow(clippy::all)]
                              pub fn get_animation_binder_mask(entity: EntityId,) -> wit_bindgen::rt::vec::Vec::<wit_bindgen::rt::string::String>{
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                unsafe {
                                  
                                  #[repr(align(4))]
                                  struct RetArea([u8; 8]);
                                  let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                  let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                  let ptr1 = ret_area.as_mut_ptr() as i32;
                                  #[link(wasm_import_module = "entity")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "get-animation-binder-mask")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_get-animation-binder-mask")]
                                    fn wit_import(
                                    _: i64, _: i64, _: i32, );
                                  }
                                  wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), ptr1);
                                  let base3 = *((ptr1 + 0) as *const i32);
                                  let len3 = *((ptr1 + 4) as *const i32);
                                  let mut result3 = Vec::with_capacity(len3 as usize);
                                  for i in 0..len3 {
                                    let base = base3 + i *8;
                                    result3.push({
                                      let len2 = *((base + 4) as *const i32) as usize;
                                      
                                      {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len2, len2))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len2, len2)).unwrap()}}
                                    });
                                  }
                                  wit_bindgen::rt::dealloc(base3, (len3 as usize) * 8, 4);
                                  result3
                                }
                              }
                              #[allow(clippy::all)]
                              pub fn set_animation_binder_weights(entity: EntityId,index: u32,mask: &[f32],){
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                unsafe {
                                  let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                  let vec1 = mask;
                                  let ptr1 = vec1.as_ptr() as i32;
                                  let len1 = vec1.len() as i32;
                                  
                                  #[link(wasm_import_module = "entity")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "set-animation-binder-weights")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_set-animation-binder-weights")]
                                    fn wit_import(
                                    _: i64, _: i64, _: i32, _: i32, _: i32, );
                                  }
                                  wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_i32(index), ptr1, len1);
                                }
                              }
                              #[allow(clippy::all)]
                              pub fn get_animation_binder_mask_entities(entity: EntityId,) -> wit_bindgen::rt::vec::Vec::<EntityId>{
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                unsafe {
                                  
                                  #[repr(align(4))]
                                  struct RetArea([u8; 8]);
                                  let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                  let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                  let ptr1 = ret_area.as_mut_ptr() as i32;
                                  #[link(wasm_import_module = "entity")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "get-animation-binder-mask-entities")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_get-animation-binder-mask-entities")]
                                    fn wit_import(
                                    _: i64, _: i64, _: i32, );
                                  }
                                  wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), ptr1);
                                  let len2 = *((ptr1 + 4) as *const i32) as usize;
                                  Vec::from_raw_parts(*((ptr1 + 0) as *const i32) as *mut _, len2, len2)
                                }
                              }
                              #[allow(clippy::all)]
                              pub fn set_animation_blend(entity: EntityId,weights: &[f32],time: &[f32],absolute_time: bool,){
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                unsafe {
                                  let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                  let vec1 = weights;
                                  let ptr1 = vec1.as_ptr() as i32;
                                  let len1 = vec1.len() as i32;
                                  let vec2 = time;
                                  let ptr2 = vec2.as_ptr() as i32;
                                  let len2 = vec2.len() as i32;
                                  
                                  #[link(wasm_import_module = "entity")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "set-animation-blend")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_set-animation-blend")]
                                    fn wit_import(
                                    _: i64, _: i64, _: i32, _: i32, _: i32, _: i32, _: i32, );
                                  }
                                  wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), ptr1, len1, ptr2, len2, match absolute_time { true => 1, false => 0 });
                                }
                              }
                              #[allow(clippy::all)]
                              pub fn get_transforms_relative_to(entities: &[EntityId],origin: EntityId,) -> wit_bindgen::rt::vec::Vec::<Mat4>{
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                unsafe {
                                  
                                  #[repr(align(4))]
                                  struct RetArea([u8; 8]);
                                  let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                  let vec0 = entities;
                                  let ptr0 = vec0.as_ptr() as i32;
                                  let len0 = vec0.len() as i32;
                                  let super::types::EntityId{ id0:id01, id1:id11, } = origin;
                                  let ptr2 = ret_area.as_mut_ptr() as i32;
                                  #[link(wasm_import_module = "entity")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "get-transforms-relative-to")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_get-transforms-relative-to")]
                                    fn wit_import(
                                    _: i32, _: i32, _: i64, _: i64, _: i32, );
                                  }
                                  wit_import(ptr0, len0, wit_bindgen::rt::as_i64(id01), wit_bindgen::rt::as_i64(id11), ptr2);
                                  let len3 = *((ptr2 + 4) as *const i32) as usize;
                                  Vec::from_raw_parts(*((ptr2 + 0) as *const i32) as *mut _, len3, len3)
                                }
                              }
                              #[allow(clippy::all)]
                              pub fn spawn(data: &EntityData,) -> EntityId{
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                unsafe {
                                  let mut cleanup_list = Vec::new();
                                  
                                  #[repr(align(8))]
                                  struct RetArea([u8; 16]);
                                  let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                  let vec70 = data;
                                  let len70 = vec70.len() as i32;
                                  let layout70 = alloc::Layout::from_size_align_unchecked(vec70.len() * 96, 8);
                                  let result70 = if layout70.size() != 0
                                  {
                                    let ptr = alloc::alloc(layout70);
                                    if ptr.is_null()
                                    {
                                      alloc::handle_alloc_error(layout70);
                                    }
                                    ptr
                                  }else {
                                    core::ptr::null_mut()
                                  };
                                  for (i, e) in vec70.into_iter().enumerate() {
                                    let base = result70 as i32 + (i as i32) * 96;
                                    {
                                      let (t0_0, t0_1, ) = e;
                                      *((base + 0) as *mut i32) = wit_bindgen::rt::as_i32(t0_0);
                                      match t0_1 {
                                        super::component::Value::TypeEmpty(e) => {
                                          *((base + 8) as *mut u8) = (0i32) as u8;
                                          let () = e;
                                          
                                        },
                                        super::component::Value::TypeBool(e) => {
                                          *((base + 8) as *mut u8) = (1i32) as u8;
                                          *((base + 16) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                          
                                        },
                                        super::component::Value::TypeEntityId(e) => {
                                          *((base + 8) as *mut u8) = (2i32) as u8;
                                          let super::types::EntityId{ id0:id02, id1:id12, } = e;
                                          *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(id02);
                                          *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(id12);
                                          
                                        },
                                        super::component::Value::TypeF32(e) => {
                                          *((base + 8) as *mut u8) = (3i32) as u8;
                                          *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(e);
                                          
                                        },
                                        super::component::Value::TypeF64(e) => {
                                          *((base + 8) as *mut u8) = (4i32) as u8;
                                          *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                          
                                        },
                                        super::component::Value::TypeMat4(e) => {
                                          *((base + 8) as *mut u8) = (5i32) as u8;
                                          let super::types::Mat4{ x:x3, y:y3, z:z3, w:w3, } = e;
                                          let super::types::Vec4{ x:x4, y:y4, z:z4, w:w4, } = x3;
                                          *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x4);
                                          *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y4);
                                          *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z4);
                                          *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w4);
                                          let super::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = y3;
                                          *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(x5);
                                          *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(y5);
                                          *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(z5);
                                          *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(w5);
                                          let super::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = z3;
                                          *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(x6);
                                          *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(y6);
                                          *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(z6);
                                          *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(w6);
                                          let super::types::Vec4{ x:x7, y:y7, z:z7, w:w7, } = w3;
                                          *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(x7);
                                          *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(y7);
                                          *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(z7);
                                          *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(w7);
                                          
                                        },
                                        super::component::Value::TypeI32(e) => {
                                          *((base + 8) as *mut u8) = (6i32) as u8;
                                          *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                          
                                        },
                                        super::component::Value::TypeQuat(e) => {
                                          *((base + 8) as *mut u8) = (7i32) as u8;
                                          let super::types::Quat{ x:x8, y:y8, z:z8, w:w8, } = e;
                                          *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x8);
                                          *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y8);
                                          *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z8);
                                          *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w8);
                                          
                                        },
                                        super::component::Value::TypeString(e) => {
                                          *((base + 8) as *mut u8) = (8i32) as u8;
                                          let vec9 = e;
                                          let ptr9 = vec9.as_ptr() as i32;
                                          let len9 = vec9.len() as i32;
                                          *((base + 20) as *mut i32) = len9;
                                          *((base + 16) as *mut i32) = ptr9;
                                          
                                        },
                                        super::component::Value::TypeU8(e) => {
                                          *((base + 8) as *mut u8) = (9i32) as u8;
                                          *((base + 16) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                          
                                        },
                                        super::component::Value::TypeU32(e) => {
                                          *((base + 8) as *mut u8) = (10i32) as u8;
                                          *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                          
                                        },
                                        super::component::Value::TypeU64(e) => {
                                          *((base + 8) as *mut u8) = (11i32) as u8;
                                          *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                          
                                        },
                                        super::component::Value::TypeVec2(e) => {
                                          *((base + 8) as *mut u8) = (12i32) as u8;
                                          let super::types::Vec2{ x:x10, y:y10, } = e;
                                          *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x10);
                                          *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y10);
                                          
                                        },
                                        super::component::Value::TypeVec3(e) => {
                                          *((base + 8) as *mut u8) = (13i32) as u8;
                                          let super::types::Vec3{ x:x11, y:y11, z:z11, } = e;
                                          *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x11);
                                          *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y11);
                                          *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z11);
                                          
                                        },
                                        super::component::Value::TypeVec4(e) => {
                                          *((base + 8) as *mut u8) = (14i32) as u8;
                                          let super::types::Vec4{ x:x12, y:y12, z:z12, w:w12, } = e;
                                          *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x12);
                                          *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y12);
                                          *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z12);
                                          *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w12);
                                          
                                        },
                                        super::component::Value::TypeUvec2(e) => {
                                          *((base + 8) as *mut u8) = (15i32) as u8;
                                          let super::types::Uvec2{ x:x13, y:y13, } = e;
                                          *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x13);
                                          *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y13);
                                          
                                        },
                                        super::component::Value::TypeUvec3(e) => {
                                          *((base + 8) as *mut u8) = (16i32) as u8;
                                          let super::types::Uvec3{ x:x14, y:y14, z:z14, } = e;
                                          *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x14);
                                          *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y14);
                                          *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z14);
                                          
                                        },
                                        super::component::Value::TypeUvec4(e) => {
                                          *((base + 8) as *mut u8) = (17i32) as u8;
                                          let super::types::Uvec4{ x:x15, y:y15, z:z15, w:w15, } = e;
                                          *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x15);
                                          *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y15);
                                          *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z15);
                                          *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(w15);
                                          
                                        },
                                        super::component::Value::TypeProceduralMeshHandle(e) => {
                                          *((base + 8) as *mut u8) = (18i32) as u8;
                                          let super::client_mesh::Handle{ ulid:ulid16, } = e;
                                          let (t17_0, t17_1, ) = ulid16;
                                          *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t17_0);
                                          *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t17_1);
                                          
                                        },
                                        super::component::Value::TypeProceduralTextureHandle(e) => {
                                          *((base + 8) as *mut u8) = (19i32) as u8;
                                          let super::client_texture::Handle{ ulid:ulid18, } = e;
                                          let (t19_0, t19_1, ) = ulid18;
                                          *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t19_0);
                                          *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t19_1);
                                          
                                        },
                                        super::component::Value::TypeProceduralSamplerHandle(e) => {
                                          *((base + 8) as *mut u8) = (20i32) as u8;
                                          let super::client_sampler::Handle{ ulid:ulid20, } = e;
                                          let (t21_0, t21_1, ) = ulid20;
                                          *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t21_0);
                                          *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t21_1);
                                          
                                        },
                                        super::component::Value::TypeProceduralMaterialHandle(e) => {
                                          *((base + 8) as *mut u8) = (21i32) as u8;
                                          let super::client_material::Handle{ ulid:ulid22, } = e;
                                          let (t23_0, t23_1, ) = ulid22;
                                          *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t23_0);
                                          *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t23_1);
                                          
                                        },
                                        super::component::Value::TypeVec(e) => {
                                          *((base + 8) as *mut u8) = (22i32) as u8;
                                          match e {
                                            super::component::VecValue::TypeEmpty(e) => {
                                              *((base + 16) as *mut u8) = (0i32) as u8;
                                              let vec24 = e;
                                              let ptr24 = vec24.as_ptr() as i32;
                                              let len24 = vec24.len() as i32;
                                              *((base + 24) as *mut i32) = len24;
                                              *((base + 20) as *mut i32) = ptr24;
                                              
                                            },
                                            super::component::VecValue::TypeBool(e) => {
                                              *((base + 16) as *mut u8) = (1i32) as u8;
                                              let vec25 = e;
                                              let len25 = vec25.len() as i32;
                                              let layout25 = alloc::Layout::from_size_align_unchecked(vec25.len() * 1, 1);
                                              let result25 = if layout25.size() != 0
                                              {
                                                let ptr = alloc::alloc(layout25);
                                                if ptr.is_null()
                                                {
                                                  alloc::handle_alloc_error(layout25);
                                                }
                                                ptr
                                              }else {
                                                core::ptr::null_mut()
                                              };
                                              for (i, e) in vec25.into_iter().enumerate() {
                                                let base = result25 as i32 + (i as i32) * 1;
                                                {
                                                  *((base + 0) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                                  
                                                }}
                                                *((base + 24) as *mut i32) = len25;
                                                *((base + 20) as *mut i32) = result25 as i32;
                                                cleanup_list.extend_from_slice(&[(result25, layout25),]);
                                                
                                              },
                                              super::component::VecValue::TypeEntityId(e) => {
                                                *((base + 16) as *mut u8) = (2i32) as u8;
                                                let vec26 = e;
                                                let ptr26 = vec26.as_ptr() as i32;
                                                let len26 = vec26.len() as i32;
                                                *((base + 24) as *mut i32) = len26;
                                                *((base + 20) as *mut i32) = ptr26;
                                                
                                              },
                                              super::component::VecValue::TypeF32(e) => {
                                                *((base + 16) as *mut u8) = (3i32) as u8;
                                                let vec27 = e;
                                                let ptr27 = vec27.as_ptr() as i32;
                                                let len27 = vec27.len() as i32;
                                                *((base + 24) as *mut i32) = len27;
                                                *((base + 20) as *mut i32) = ptr27;
                                                
                                              },
                                              super::component::VecValue::TypeF64(e) => {
                                                *((base + 16) as *mut u8) = (4i32) as u8;
                                                let vec28 = e;
                                                let ptr28 = vec28.as_ptr() as i32;
                                                let len28 = vec28.len() as i32;
                                                *((base + 24) as *mut i32) = len28;
                                                *((base + 20) as *mut i32) = ptr28;
                                                
                                              },
                                              super::component::VecValue::TypeMat4(e) => {
                                                *((base + 16) as *mut u8) = (5i32) as u8;
                                                let vec29 = e;
                                                let ptr29 = vec29.as_ptr() as i32;
                                                let len29 = vec29.len() as i32;
                                                *((base + 24) as *mut i32) = len29;
                                                *((base + 20) as *mut i32) = ptr29;
                                                
                                              },
                                              super::component::VecValue::TypeI32(e) => {
                                                *((base + 16) as *mut u8) = (6i32) as u8;
                                                let vec30 = e;
                                                let ptr30 = vec30.as_ptr() as i32;
                                                let len30 = vec30.len() as i32;
                                                *((base + 24) as *mut i32) = len30;
                                                *((base + 20) as *mut i32) = ptr30;
                                                
                                              },
                                              super::component::VecValue::TypeQuat(e) => {
                                                *((base + 16) as *mut u8) = (7i32) as u8;
                                                let vec31 = e;
                                                let ptr31 = vec31.as_ptr() as i32;
                                                let len31 = vec31.len() as i32;
                                                *((base + 24) as *mut i32) = len31;
                                                *((base + 20) as *mut i32) = ptr31;
                                                
                                              },
                                              super::component::VecValue::TypeString(e) => {
                                                *((base + 16) as *mut u8) = (8i32) as u8;
                                                let vec33 = e;
                                                let len33 = vec33.len() as i32;
                                                let layout33 = alloc::Layout::from_size_align_unchecked(vec33.len() * 8, 4);
                                                let result33 = if layout33.size() != 0
                                                {
                                                  let ptr = alloc::alloc(layout33);
                                                  if ptr.is_null()
                                                  {
                                                    alloc::handle_alloc_error(layout33);
                                                  }
                                                  ptr
                                                }else {
                                                  core::ptr::null_mut()
                                                };
                                                for (i, e) in vec33.into_iter().enumerate() {
                                                  let base = result33 as i32 + (i as i32) * 8;
                                                  {
                                                    let vec32 = e;
                                                    let ptr32 = vec32.as_ptr() as i32;
                                                    let len32 = vec32.len() as i32;
                                                    *((base + 4) as *mut i32) = len32;
                                                    *((base + 0) as *mut i32) = ptr32;
                                                    
                                                  }}
                                                  *((base + 24) as *mut i32) = len33;
                                                  *((base + 20) as *mut i32) = result33 as i32;
                                                  cleanup_list.extend_from_slice(&[(result33, layout33),]);
                                                  
                                                },
                                                super::component::VecValue::TypeU8(e) => {
                                                  *((base + 16) as *mut u8) = (9i32) as u8;
                                                  let vec34 = e;
                                                  let ptr34 = vec34.as_ptr() as i32;
                                                  let len34 = vec34.len() as i32;
                                                  *((base + 24) as *mut i32) = len34;
                                                  *((base + 20) as *mut i32) = ptr34;
                                                  
                                                },
                                                super::component::VecValue::TypeU32(e) => {
                                                  *((base + 16) as *mut u8) = (10i32) as u8;
                                                  let vec35 = e;
                                                  let ptr35 = vec35.as_ptr() as i32;
                                                  let len35 = vec35.len() as i32;
                                                  *((base + 24) as *mut i32) = len35;
                                                  *((base + 20) as *mut i32) = ptr35;
                                                  
                                                },
                                                super::component::VecValue::TypeU64(e) => {
                                                  *((base + 16) as *mut u8) = (11i32) as u8;
                                                  let vec36 = e;
                                                  let ptr36 = vec36.as_ptr() as i32;
                                                  let len36 = vec36.len() as i32;
                                                  *((base + 24) as *mut i32) = len36;
                                                  *((base + 20) as *mut i32) = ptr36;
                                                  
                                                },
                                                super::component::VecValue::TypeVec2(e) => {
                                                  *((base + 16) as *mut u8) = (12i32) as u8;
                                                  let vec37 = e;
                                                  let ptr37 = vec37.as_ptr() as i32;
                                                  let len37 = vec37.len() as i32;
                                                  *((base + 24) as *mut i32) = len37;
                                                  *((base + 20) as *mut i32) = ptr37;
                                                  
                                                },
                                                super::component::VecValue::TypeVec3(e) => {
                                                  *((base + 16) as *mut u8) = (13i32) as u8;
                                                  let vec38 = e;
                                                  let ptr38 = vec38.as_ptr() as i32;
                                                  let len38 = vec38.len() as i32;
                                                  *((base + 24) as *mut i32) = len38;
                                                  *((base + 20) as *mut i32) = ptr38;
                                                  
                                                },
                                                super::component::VecValue::TypeVec4(e) => {
                                                  *((base + 16) as *mut u8) = (14i32) as u8;
                                                  let vec39 = e;
                                                  let ptr39 = vec39.as_ptr() as i32;
                                                  let len39 = vec39.len() as i32;
                                                  *((base + 24) as *mut i32) = len39;
                                                  *((base + 20) as *mut i32) = ptr39;
                                                  
                                                },
                                                super::component::VecValue::TypeUvec2(e) => {
                                                  *((base + 16) as *mut u8) = (15i32) as u8;
                                                  let vec40 = e;
                                                  let ptr40 = vec40.as_ptr() as i32;
                                                  let len40 = vec40.len() as i32;
                                                  *((base + 24) as *mut i32) = len40;
                                                  *((base + 20) as *mut i32) = ptr40;
                                                  
                                                },
                                                super::component::VecValue::TypeUvec3(e) => {
                                                  *((base + 16) as *mut u8) = (16i32) as u8;
                                                  let vec41 = e;
                                                  let ptr41 = vec41.as_ptr() as i32;
                                                  let len41 = vec41.len() as i32;
                                                  *((base + 24) as *mut i32) = len41;
                                                  *((base + 20) as *mut i32) = ptr41;
                                                  
                                                },
                                                super::component::VecValue::TypeUvec4(e) => {
                                                  *((base + 16) as *mut u8) = (17i32) as u8;
                                                  let vec42 = e;
                                                  let ptr42 = vec42.as_ptr() as i32;
                                                  let len42 = vec42.len() as i32;
                                                  *((base + 24) as *mut i32) = len42;
                                                  *((base + 20) as *mut i32) = ptr42;
                                                  
                                                },
                                                super::component::VecValue::TypeProceduralMeshHandle(e) => {
                                                  *((base + 16) as *mut u8) = (18i32) as u8;
                                                  let vec43 = e;
                                                  let ptr43 = vec43.as_ptr() as i32;
                                                  let len43 = vec43.len() as i32;
                                                  *((base + 24) as *mut i32) = len43;
                                                  *((base + 20) as *mut i32) = ptr43;
                                                  
                                                },
                                                super::component::VecValue::TypeProceduralTextureHandle(e) => {
                                                  *((base + 16) as *mut u8) = (19i32) as u8;
                                                  let vec44 = e;
                                                  let ptr44 = vec44.as_ptr() as i32;
                                                  let len44 = vec44.len() as i32;
                                                  *((base + 24) as *mut i32) = len44;
                                                  *((base + 20) as *mut i32) = ptr44;
                                                  
                                                },
                                                super::component::VecValue::TypeProceduralSamplerHandle(e) => {
                                                  *((base + 16) as *mut u8) = (20i32) as u8;
                                                  let vec45 = e;
                                                  let ptr45 = vec45.as_ptr() as i32;
                                                  let len45 = vec45.len() as i32;
                                                  *((base + 24) as *mut i32) = len45;
                                                  *((base + 20) as *mut i32) = ptr45;
                                                  
                                                },
                                                super::component::VecValue::TypeProceduralMaterialHandle(e) => {
                                                  *((base + 16) as *mut u8) = (21i32) as u8;
                                                  let vec46 = e;
                                                  let ptr46 = vec46.as_ptr() as i32;
                                                  let len46 = vec46.len() as i32;
                                                  *((base + 24) as *mut i32) = len46;
                                                  *((base + 20) as *mut i32) = ptr46;
                                                  
                                                },
                                              };
                                              
                                            },
                                            super::component::Value::TypeOption(e) => {
                                              *((base + 8) as *mut u8) = (23i32) as u8;
                                              match e {
                                                super::component::OptionValue::TypeEmpty(e) => {
                                                  *((base + 16) as *mut u8) = (0i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let () = e;
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::OptionValue::TypeBool(e) => {
                                                  *((base + 16) as *mut u8) = (1i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      *((base + 25) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::OptionValue::TypeEntityId(e) => {
                                                  *((base + 16) as *mut u8) = (2i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let super::types::EntityId{ id0:id048, id1:id148, } = e;
                                                      *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(id048);
                                                      *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(id148);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::OptionValue::TypeF32(e) => {
                                                  *((base + 16) as *mut u8) = (3i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(e);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::OptionValue::TypeF64(e) => {
                                                  *((base + 16) as *mut u8) = (4i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::OptionValue::TypeMat4(e) => {
                                                  *((base + 16) as *mut u8) = (5i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let super::types::Mat4{ x:x49, y:y49, z:z49, w:w49, } = e;
                                                      let super::types::Vec4{ x:x50, y:y50, z:z50, w:w50, } = x49;
                                                      *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x50);
                                                      *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y50);
                                                      *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z50);
                                                      *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w50);
                                                      let super::types::Vec4{ x:x51, y:y51, z:z51, w:w51, } = y49;
                                                      *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(x51);
                                                      *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(y51);
                                                      *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(z51);
                                                      *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(w51);
                                                      let super::types::Vec4{ x:x52, y:y52, z:z52, w:w52, } = z49;
                                                      *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(x52);
                                                      *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(y52);
                                                      *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(z52);
                                                      *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(w52);
                                                      let super::types::Vec4{ x:x53, y:y53, z:z53, w:w53, } = w49;
                                                      *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(x53);
                                                      *((base + 80) as *mut f32) = wit_bindgen::rt::as_f32(y53);
                                                      *((base + 84) as *mut f32) = wit_bindgen::rt::as_f32(z53);
                                                      *((base + 88) as *mut f32) = wit_bindgen::rt::as_f32(w53);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::OptionValue::TypeI32(e) => {
                                                  *((base + 16) as *mut u8) = (6i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::OptionValue::TypeQuat(e) => {
                                                  *((base + 16) as *mut u8) = (7i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let super::types::Quat{ x:x54, y:y54, z:z54, w:w54, } = e;
                                                      *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x54);
                                                      *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y54);
                                                      *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z54);
                                                      *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w54);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::OptionValue::TypeString(e) => {
                                                  *((base + 16) as *mut u8) = (8i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let vec55 = e;
                                                      let ptr55 = vec55.as_ptr() as i32;
                                                      let len55 = vec55.len() as i32;
                                                      *((base + 32) as *mut i32) = len55;
                                                      *((base + 28) as *mut i32) = ptr55;
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::OptionValue::TypeU8(e) => {
                                                  *((base + 16) as *mut u8) = (9i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      *((base + 25) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::OptionValue::TypeU32(e) => {
                                                  *((base + 16) as *mut u8) = (10i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::OptionValue::TypeU64(e) => {
                                                  *((base + 16) as *mut u8) = (11i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::OptionValue::TypeVec2(e) => {
                                                  *((base + 16) as *mut u8) = (12i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let super::types::Vec2{ x:x56, y:y56, } = e;
                                                      *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x56);
                                                      *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y56);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::OptionValue::TypeVec3(e) => {
                                                  *((base + 16) as *mut u8) = (13i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let super::types::Vec3{ x:x57, y:y57, z:z57, } = e;
                                                      *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x57);
                                                      *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y57);
                                                      *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z57);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::OptionValue::TypeVec4(e) => {
                                                  *((base + 16) as *mut u8) = (14i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let super::types::Vec4{ x:x58, y:y58, z:z58, w:w58, } = e;
                                                      *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x58);
                                                      *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y58);
                                                      *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z58);
                                                      *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w58);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::OptionValue::TypeUvec2(e) => {
                                                  *((base + 16) as *mut u8) = (15i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let super::types::Uvec2{ x:x59, y:y59, } = e;
                                                      *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x59);
                                                      *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y59);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::OptionValue::TypeUvec3(e) => {
                                                  *((base + 16) as *mut u8) = (16i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let super::types::Uvec3{ x:x60, y:y60, z:z60, } = e;
                                                      *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x60);
                                                      *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y60);
                                                      *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z60);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::OptionValue::TypeUvec4(e) => {
                                                  *((base + 16) as *mut u8) = (17i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let super::types::Uvec4{ x:x61, y:y61, z:z61, w:w61, } = e;
                                                      *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x61);
                                                      *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y61);
                                                      *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z61);
                                                      *((base + 40) as *mut i32) = wit_bindgen::rt::as_i32(w61);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::OptionValue::TypeProceduralMeshHandle(e) => {
                                                  *((base + 16) as *mut u8) = (18i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let super::client_mesh::Handle{ ulid:ulid62, } = e;
                                                      let (t63_0, t63_1, ) = ulid62;
                                                      *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t63_0);
                                                      *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t63_1);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::OptionValue::TypeProceduralTextureHandle(e) => {
                                                  *((base + 16) as *mut u8) = (19i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let super::client_texture::Handle{ ulid:ulid64, } = e;
                                                      let (t65_0, t65_1, ) = ulid64;
                                                      *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t65_0);
                                                      *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t65_1);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::OptionValue::TypeProceduralSamplerHandle(e) => {
                                                  *((base + 16) as *mut u8) = (20i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let super::client_sampler::Handle{ ulid:ulid66, } = e;
                                                      let (t67_0, t67_1, ) = ulid66;
                                                      *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t67_0);
                                                      *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t67_1);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::OptionValue::TypeProceduralMaterialHandle(e) => {
                                                  *((base + 16) as *mut u8) = (21i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let super::client_material::Handle{ ulid:ulid68, } = e;
                                                      let (t69_0, t69_1, ) = ulid68;
                                                      *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t69_0);
                                                      *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t69_1);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                              };
                                              
                                            },
                                          };
                                          
                                        }}
                                        let ptr71 = ret_area.as_mut_ptr() as i32;
                                        #[link(wasm_import_module = "entity")]
                                        extern "C" {
                                          #[cfg_attr(target_arch = "wasm32", link_name = "spawn")]
                                          #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_spawn")]
                                          fn wit_import(
                                          _: i32, _: i32, _: i32, );
                                        }
                                        wit_import(result70 as i32, len70, ptr71);
                                        if layout70.size() != 0 {
                                          alloc::dealloc(result70, layout70);
                                        }
                                        for (ptr, layout) in cleanup_list {
                                          
                                          if layout.size() != 0 {
                                            
                                            alloc::dealloc(ptr, layout);
                                            
                                          }
                                          
                                        }
                                        super::types::EntityId{id0:*((ptr71 + 0) as *const i64) as u64, id1:*((ptr71 + 8) as *const i64) as u64, }
                                      }
                                    }
                                    #[allow(clippy::all)]
                                    pub fn despawn(entity: EntityId,) -> Option<EntityData>{
                                      
                                      #[allow(unused_imports)]
                                      use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                      unsafe {
                                        
                                        #[repr(align(4))]
                                        struct RetArea([u8; 12]);
                                        let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                        let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                        let ptr1 = ret_area.as_mut_ptr() as i32;
                                        #[link(wasm_import_module = "entity")]
                                        extern "C" {
                                          #[cfg_attr(target_arch = "wasm32", link_name = "despawn")]
                                          #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_despawn")]
                                          fn wit_import(
                                          _: i64, _: i64, _: i32, );
                                        }
                                        wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), ptr1);
                                        match i32::from(*((ptr1 + 0) as *const u8)) {
                                          0 => None,
                                          1 => Some({
                                            let base27 = *((ptr1 + 4) as *const i32);
                                            let len27 = *((ptr1 + 8) as *const i32);
                                            let mut result27 = Vec::with_capacity(len27 as usize);
                                            for i in 0..len27 {
                                              let base = base27 + i *96;
                                              result27.push((*((base + 0) as *const i32) as u32, {{match i32::from(*((base + 8) as *const u8)) {
                                                0 => super::component::Value::TypeEmpty(()),
                                                1 => super::component::Value::TypeBool({
                                                  #[cfg(not(debug_assertions))]
                                                  { core::mem::transmute::<u8, bool>(i32::from(*((base + 16) as *const u8)) as u8) }
                                                  #[cfg(debug_assertions)]
                                                  {
                                                    match i32::from(*((base + 16) as *const u8)) {
                                                      0 => false,
                                                      1 => true,
                                                      _ => panic!("invalid bool discriminant"),
                                                    }
                                                  }
                                                }),
                                                2 => super::component::Value::TypeEntityId(super::types::EntityId{id0:*((base + 16) as *const i64) as u64, id1:*((base + 24) as *const i64) as u64, }),
                                                3 => super::component::Value::TypeF32(*((base + 16) as *const f32)),
                                                4 => super::component::Value::TypeF64(*((base + 16) as *const f64)),
                                                5 => super::component::Value::TypeMat4(super::types::Mat4{x:super::types::Vec4{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }, y:super::types::Vec4{x:*((base + 32) as *const f32), y:*((base + 36) as *const f32), z:*((base + 40) as *const f32), w:*((base + 44) as *const f32), }, z:super::types::Vec4{x:*((base + 48) as *const f32), y:*((base + 52) as *const f32), z:*((base + 56) as *const f32), w:*((base + 60) as *const f32), }, w:super::types::Vec4{x:*((base + 64) as *const f32), y:*((base + 68) as *const f32), z:*((base + 72) as *const f32), w:*((base + 76) as *const f32), }, }),
                                                6 => super::component::Value::TypeI32(*((base + 16) as *const i32)),
                                                7 => super::component::Value::TypeQuat(super::types::Quat{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }),
                                                8 => super::component::Value::TypeString({
                                                  let len2 = *((base + 20) as *const i32) as usize;
                                                  
                                                  {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 16) as *const i32) as *mut _, len2, len2))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 16) as *const i32) as *mut _, len2, len2)).unwrap()}}
                                                }),
                                                9 => super::component::Value::TypeU8(i32::from(*((base + 16) as *const u8)) as u8),
                                                10 => super::component::Value::TypeU32(*((base + 16) as *const i32) as u32),
                                                11 => super::component::Value::TypeU64(*((base + 16) as *const i64) as u64),
                                                12 => super::component::Value::TypeVec2(super::types::Vec2{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), }),
                                                13 => super::component::Value::TypeVec3(super::types::Vec3{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), }),
                                                14 => super::component::Value::TypeVec4(super::types::Vec4{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }),
                                                15 => super::component::Value::TypeUvec2(super::types::Uvec2{x:*((base + 16) as *const i32) as u32, y:*((base + 20) as *const i32) as u32, }),
                                                16 => super::component::Value::TypeUvec3(super::types::Uvec3{x:*((base + 16) as *const i32) as u32, y:*((base + 20) as *const i32) as u32, z:*((base + 24) as *const i32) as u32, }),
                                                17 => super::component::Value::TypeUvec4(super::types::Uvec4{x:*((base + 16) as *const i32) as u32, y:*((base + 20) as *const i32) as u32, z:*((base + 24) as *const i32) as u32, w:*((base + 28) as *const i32) as u32, }),
                                                18 => super::component::Value::TypeProceduralMeshHandle(super::client_mesh::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                                                19 => super::component::Value::TypeProceduralTextureHandle(super::client_texture::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                                                20 => super::component::Value::TypeProceduralSamplerHandle(super::client_sampler::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                                                21 => super::component::Value::TypeProceduralMaterialHandle(super::client_material::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                                                22 => super::component::Value::TypeVec({{match i32::from(*((base + 16) as *const u8)) {
                                                  0 => super::component::VecValue::TypeEmpty({
                                                    let len3 = *((base + 24) as *const i32) as usize;
                                                    
                                                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len3, len3)
                                                  }),
                                                  1 => super::component::VecValue::TypeBool({
                                                    let base4 = *((base + 20) as *const i32);
                                                    let len4 = *((base + 24) as *const i32);
                                                    let mut result4 = Vec::with_capacity(len4 as usize);
                                                    for i in 0..len4 {
                                                      let base = base4 + i *1;
                                                      result4.push({
                                                        #[cfg(not(debug_assertions))]
                                                        { core::mem::transmute::<u8, bool>(i32::from(*((base + 0) as *const u8)) as u8) }
                                                        #[cfg(debug_assertions)]
                                                        {
                                                          match i32::from(*((base + 0) as *const u8)) {
                                                            0 => false,
                                                            1 => true,
                                                            _ => panic!("invalid bool discriminant"),
                                                          }
                                                        }
                                                      });
                                                    }
                                                    wit_bindgen::rt::dealloc(base4, (len4 as usize) * 1, 1);
                                                    
                                                    result4
                                                  }),
                                                  2 => super::component::VecValue::TypeEntityId({
                                                    let len5 = *((base + 24) as *const i32) as usize;
                                                    
                                                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len5, len5)
                                                  }),
                                                  3 => super::component::VecValue::TypeF32({
                                                    let len6 = *((base + 24) as *const i32) as usize;
                                                    
                                                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len6, len6)
                                                  }),
                                                  4 => super::component::VecValue::TypeF64({
                                                    let len7 = *((base + 24) as *const i32) as usize;
                                                    
                                                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len7, len7)
                                                  }),
                                                  5 => super::component::VecValue::TypeMat4({
                                                    let len8 = *((base + 24) as *const i32) as usize;
                                                    
                                                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len8, len8)
                                                  }),
                                                  6 => super::component::VecValue::TypeI32({
                                                    let len9 = *((base + 24) as *const i32) as usize;
                                                    
                                                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len9, len9)
                                                  }),
                                                  7 => super::component::VecValue::TypeQuat({
                                                    let len10 = *((base + 24) as *const i32) as usize;
                                                    
                                                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len10, len10)
                                                  }),
                                                  8 => super::component::VecValue::TypeString({
                                                    let base12 = *((base + 20) as *const i32);
                                                    let len12 = *((base + 24) as *const i32);
                                                    let mut result12 = Vec::with_capacity(len12 as usize);
                                                    for i in 0..len12 {
                                                      let base = base12 + i *8;
                                                      result12.push({
                                                        let len11 = *((base + 4) as *const i32) as usize;
                                                        
                                                        {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len11, len11))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len11, len11)).unwrap()}}
                                                      });
                                                    }
                                                    wit_bindgen::rt::dealloc(base12, (len12 as usize) * 8, 4);
                                                    
                                                    result12
                                                  }),
                                                  9 => super::component::VecValue::TypeU8({
                                                    let len13 = *((base + 24) as *const i32) as usize;
                                                    
                                                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len13, len13)
                                                  }),
                                                  10 => super::component::VecValue::TypeU32({
                                                    let len14 = *((base + 24) as *const i32) as usize;
                                                    
                                                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len14, len14)
                                                  }),
                                                  11 => super::component::VecValue::TypeU64({
                                                    let len15 = *((base + 24) as *const i32) as usize;
                                                    
                                                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len15, len15)
                                                  }),
                                                  12 => super::component::VecValue::TypeVec2({
                                                    let len16 = *((base + 24) as *const i32) as usize;
                                                    
                                                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len16, len16)
                                                  }),
                                                  13 => super::component::VecValue::TypeVec3({
                                                    let len17 = *((base + 24) as *const i32) as usize;
                                                    
                                                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len17, len17)
                                                  }),
                                                  14 => super::component::VecValue::TypeVec4({
                                                    let len18 = *((base + 24) as *const i32) as usize;
                                                    
                                                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len18, len18)
                                                  }),
                                                  15 => super::component::VecValue::TypeUvec2({
                                                    let len19 = *((base + 24) as *const i32) as usize;
                                                    
                                                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len19, len19)
                                                  }),
                                                  16 => super::component::VecValue::TypeUvec3({
                                                    let len20 = *((base + 24) as *const i32) as usize;
                                                    
                                                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len20, len20)
                                                  }),
                                                  17 => super::component::VecValue::TypeUvec4({
                                                    let len21 = *((base + 24) as *const i32) as usize;
                                                    
                                                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len21, len21)
                                                  }),
                                                  18 => super::component::VecValue::TypeProceduralMeshHandle({
                                                    let len22 = *((base + 24) as *const i32) as usize;
                                                    
                                                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len22, len22)
                                                  }),
                                                  19 => super::component::VecValue::TypeProceduralTextureHandle({
                                                    let len23 = *((base + 24) as *const i32) as usize;
                                                    
                                                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len23, len23)
                                                  }),
                                                  20 => super::component::VecValue::TypeProceduralSamplerHandle({
                                                    let len24 = *((base + 24) as *const i32) as usize;
                                                    
                                                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len24, len24)
                                                  }),
                                                  #[cfg(debug_assertions)]21 => super::component::VecValue::TypeProceduralMaterialHandle({
                                                    let len25 = *((base + 24) as *const i32) as usize;
                                                    
                                                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len25, len25)
                                                  }),
                                                  #[cfg(not(debug_assertions))]_ => super::component::VecValue::TypeProceduralMaterialHandle({
                                                    let len25 = *((base + 24) as *const i32) as usize;
                                                    
                                                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len25, len25)
                                                  }),
                                                  #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                                }}}),
                                                #[cfg(debug_assertions)]23 => super::component::Value::TypeOption({{match i32::from(*((base + 16) as *const u8)) {
                                                  0 => super::component::OptionValue::TypeEmpty(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(()),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  1 => super::component::OptionValue::TypeBool(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some({
                                                      #[cfg(not(debug_assertions))]
                                                      { core::mem::transmute::<u8, bool>(i32::from(*((base + 25) as *const u8)) as u8) }
                                                      #[cfg(debug_assertions)]
                                                      {
                                                        match i32::from(*((base + 25) as *const u8)) {
                                                          0 => false,
                                                          1 => true,
                                                          _ => panic!("invalid bool discriminant"),
                                                        }
                                                      }
                                                    }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  2 => super::component::OptionValue::TypeEntityId(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::types::EntityId{id0:*((base + 32) as *const i64) as u64, id1:*((base + 40) as *const i64) as u64, }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  3 => super::component::OptionValue::TypeF32(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(*((base + 28) as *const f32)),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  4 => super::component::OptionValue::TypeF64(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(*((base + 32) as *const f64)),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  5 => super::component::OptionValue::TypeMat4(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::types::Mat4{x:super::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }, y:super::types::Vec4{x:*((base + 44) as *const f32), y:*((base + 48) as *const f32), z:*((base + 52) as *const f32), w:*((base + 56) as *const f32), }, z:super::types::Vec4{x:*((base + 60) as *const f32), y:*((base + 64) as *const f32), z:*((base + 68) as *const f32), w:*((base + 72) as *const f32), }, w:super::types::Vec4{x:*((base + 76) as *const f32), y:*((base + 80) as *const f32), z:*((base + 84) as *const f32), w:*((base + 88) as *const f32), }, }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  6 => super::component::OptionValue::TypeI32(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(*((base + 28) as *const i32)),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  7 => super::component::OptionValue::TypeQuat(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::types::Quat{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  8 => super::component::OptionValue::TypeString(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some({
                                                      let len26 = *((base + 32) as *const i32) as usize;
                                                      
                                                      {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len26, len26))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len26, len26)).unwrap()}}
                                                    }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  9 => super::component::OptionValue::TypeU8(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(i32::from(*((base + 25) as *const u8)) as u8),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  10 => super::component::OptionValue::TypeU32(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(*((base + 28) as *const i32) as u32),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  11 => super::component::OptionValue::TypeU64(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(*((base + 32) as *const i64) as u64),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  12 => super::component::OptionValue::TypeVec2(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::types::Vec2{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  13 => super::component::OptionValue::TypeVec3(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::types::Vec3{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  14 => super::component::OptionValue::TypeVec4(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  15 => super::component::OptionValue::TypeUvec2(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::types::Uvec2{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  16 => super::component::OptionValue::TypeUvec3(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::types::Uvec3{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  17 => super::component::OptionValue::TypeUvec4(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::types::Uvec4{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, w:*((base + 40) as *const i32) as u32, }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  18 => super::component::OptionValue::TypeProceduralMeshHandle(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::client_mesh::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  19 => super::component::OptionValue::TypeProceduralTextureHandle(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::client_texture::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  20 => super::component::OptionValue::TypeProceduralSamplerHandle(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::client_sampler::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  #[cfg(debug_assertions)]21 => super::component::OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  #[cfg(not(debug_assertions))]_ => super::component::OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                                }}}),
                                                #[cfg(not(debug_assertions))]_ => super::component::Value::TypeOption({{match i32::from(*((base + 16) as *const u8)) {
                                                  0 => super::component::OptionValue::TypeEmpty(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(()),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  1 => super::component::OptionValue::TypeBool(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some({
                                                      #[cfg(not(debug_assertions))]
                                                      { core::mem::transmute::<u8, bool>(i32::from(*((base + 25) as *const u8)) as u8) }
                                                      #[cfg(debug_assertions)]
                                                      {
                                                        match i32::from(*((base + 25) as *const u8)) {
                                                          0 => false,
                                                          1 => true,
                                                          _ => panic!("invalid bool discriminant"),
                                                        }
                                                      }
                                                    }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  2 => super::component::OptionValue::TypeEntityId(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::types::EntityId{id0:*((base + 32) as *const i64) as u64, id1:*((base + 40) as *const i64) as u64, }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  3 => super::component::OptionValue::TypeF32(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(*((base + 28) as *const f32)),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  4 => super::component::OptionValue::TypeF64(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(*((base + 32) as *const f64)),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  5 => super::component::OptionValue::TypeMat4(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::types::Mat4{x:super::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }, y:super::types::Vec4{x:*((base + 44) as *const f32), y:*((base + 48) as *const f32), z:*((base + 52) as *const f32), w:*((base + 56) as *const f32), }, z:super::types::Vec4{x:*((base + 60) as *const f32), y:*((base + 64) as *const f32), z:*((base + 68) as *const f32), w:*((base + 72) as *const f32), }, w:super::types::Vec4{x:*((base + 76) as *const f32), y:*((base + 80) as *const f32), z:*((base + 84) as *const f32), w:*((base + 88) as *const f32), }, }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  6 => super::component::OptionValue::TypeI32(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(*((base + 28) as *const i32)),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  7 => super::component::OptionValue::TypeQuat(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::types::Quat{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  8 => super::component::OptionValue::TypeString(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some({
                                                      let len26 = *((base + 32) as *const i32) as usize;
                                                      
                                                      {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len26, len26))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len26, len26)).unwrap()}}
                                                    }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  9 => super::component::OptionValue::TypeU8(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(i32::from(*((base + 25) as *const u8)) as u8),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  10 => super::component::OptionValue::TypeU32(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(*((base + 28) as *const i32) as u32),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  11 => super::component::OptionValue::TypeU64(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(*((base + 32) as *const i64) as u64),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  12 => super::component::OptionValue::TypeVec2(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::types::Vec2{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  13 => super::component::OptionValue::TypeVec3(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::types::Vec3{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  14 => super::component::OptionValue::TypeVec4(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  15 => super::component::OptionValue::TypeUvec2(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::types::Uvec2{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  16 => super::component::OptionValue::TypeUvec3(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::types::Uvec3{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  17 => super::component::OptionValue::TypeUvec4(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::types::Uvec4{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, w:*((base + 40) as *const i32) as u32, }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  18 => super::component::OptionValue::TypeProceduralMeshHandle(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::client_mesh::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  19 => super::component::OptionValue::TypeProceduralTextureHandle(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::client_texture::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  20 => super::component::OptionValue::TypeProceduralSamplerHandle(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::client_sampler::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  #[cfg(debug_assertions)]21 => super::component::OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  #[cfg(not(debug_assertions))]_ => super::component::OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                                                    0 => None,
                                                    1 => Some(super::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                                                    #[cfg(not(debug_assertions))]
                                                    _ => core::hint::unreachable_unchecked(),
                                                    #[cfg(debug_assertions)]
                                                    _ => panic!("invalid enum discriminant"),
                                                  }),
                                                  #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                                }}}),
                                                #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                              }}}));
                                            }
                                            wit_bindgen::rt::dealloc(base27, (len27 as usize) * 96, 8);
                                            
                                            result27
                                          }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }
                                      }
                                    }
                                    #[allow(clippy::all)]
                                    pub fn set_animation_controller(entity: EntityId,animation_controller: AnimationController<'_,>,){
                                      
                                      #[allow(unused_imports)]
                                      use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                      unsafe {
                                        let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                        let AnimationController{ actions:actions1, apply_base_pose:apply_base_pose1, } = animation_controller;
                                        let vec4 = actions1;
                                        let len4 = vec4.len() as i32;
                                        let layout4 = alloc::Layout::from_size_align_unchecked(vec4.len() * 16, 4);
                                        let result4 = if layout4.size() != 0
                                        {
                                          let ptr = alloc::alloc(layout4);
                                          if ptr.is_null()
                                          {
                                            alloc::handle_alloc_error(layout4);
                                          }
                                          ptr
                                        }else {
                                          core::ptr::null_mut()
                                        };
                                        for (i, e) in vec4.into_iter().enumerate() {
                                          let base = result4 as i32 + (i as i32) * 16;
                                          {
                                            let AnimationAction{ clip_url:clip_url2, looping:looping2, weight:weight2, } = e;
                                            let vec3 = clip_url2;
                                            let ptr3 = vec3.as_ptr() as i32;
                                            let len3 = vec3.len() as i32;
                                            *((base + 4) as *mut i32) = len3;
                                            *((base + 0) as *mut i32) = ptr3;
                                            *((base + 8) as *mut u8) = (match looping2 { true => 1, false => 0 }) as u8;
                                            *((base + 12) as *mut f32) = wit_bindgen::rt::as_f32(weight2);
                                            
                                          }}
                                          
                                          #[link(wasm_import_module = "entity")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "set-animation-controller")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_set-animation-controller")]
                                            fn wit_import(
                                            _: i64, _: i64, _: i32, _: i32, _: i32, );
                                          }
                                          wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), result4 as i32, len4, match apply_base_pose1 { true => 1, false => 0 });
                                          if layout4.size() != 0 {
                                            alloc::dealloc(result4, layout4);
                                          }
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn in_area(position: Vec3,radius: f32,) -> wit_bindgen::rt::vec::Vec::<EntityId>{
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          
                                          #[repr(align(4))]
                                          struct RetArea([u8; 8]);
                                          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                          let super::types::Vec3{ x:x0, y:y0, z:z0, } = position;
                                          let ptr1 = ret_area.as_mut_ptr() as i32;
                                          #[link(wasm_import_module = "entity")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "in-area")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_in-area")]
                                            fn wit_import(
                                            _: f32, _: f32, _: f32, _: f32, _: i32, );
                                          }
                                          wit_import(wit_bindgen::rt::as_f32(x0), wit_bindgen::rt::as_f32(y0), wit_bindgen::rt::as_f32(z0), wit_bindgen::rt::as_f32(radius), ptr1);
                                          let len2 = *((ptr1 + 4) as *const i32) as usize;
                                          Vec::from_raw_parts(*((ptr1 + 0) as *const i32) as *mut _, len2, len2)
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn exists(entity: EntityId,) -> bool{
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                          
                                          #[link(wasm_import_module = "entity")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "exists")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_exists")]
                                            fn wit_import(
                                            _: i64, _: i64, ) -> i32;
                                          }
                                          let ret = wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10));
                                          {
                                            #[cfg(not(debug_assertions))]
                                            { core::mem::transmute::<u8, bool>(ret as u8) }
                                            #[cfg(debug_assertions)]
                                            {
                                              match ret {
                                                0 => false,
                                                1 => true,
                                                _ => panic!("invalid bool discriminant"),
                                              }
                                            }
                                          }
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn get_all(index: u32,) -> wit_bindgen::rt::vec::Vec::<EntityId>{
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          
                                          #[repr(align(4))]
                                          struct RetArea([u8; 8]);
                                          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                          let ptr0 = ret_area.as_mut_ptr() as i32;
                                          #[link(wasm_import_module = "entity")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "get-all")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_get-all")]
                                            fn wit_import(
                                            _: i32, _: i32, );
                                          }
                                          wit_import(wit_bindgen::rt::as_i32(index), ptr0);
                                          let len1 = *((ptr0 + 4) as *const i32) as usize;
                                          Vec::from_raw_parts(*((ptr0 + 0) as *const i32) as *mut _, len1, len1)
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn resources() -> EntityId{
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          
                                          #[repr(align(8))]
                                          struct RetArea([u8; 16]);
                                          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                          let ptr0 = ret_area.as_mut_ptr() as i32;
                                          #[link(wasm_import_module = "entity")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "resources")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_resources")]
                                            fn wit_import(
                                            _: i32, );
                                          }
                                          wit_import(ptr0);
                                          super::types::EntityId{id0:*((ptr0 + 0) as *const i64) as u64, id1:*((ptr0 + 8) as *const i64) as u64, }
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn synchronized_resources() -> EntityId{
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          
                                          #[repr(align(8))]
                                          struct RetArea([u8; 16]);
                                          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                          let ptr0 = ret_area.as_mut_ptr() as i32;
                                          #[link(wasm_import_module = "entity")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "synchronized-resources")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_synchronized-resources")]
                                            fn wit_import(
                                            _: i32, );
                                          }
                                          wit_import(ptr0);
                                          super::types::EntityId{id0:*((ptr0 + 0) as *const i64) as u64, id1:*((ptr0 + 8) as *const i64) as u64, }
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn persisted_resources() -> EntityId{
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          
                                          #[repr(align(8))]
                                          struct RetArea([u8; 16]);
                                          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                          let ptr0 = ret_area.as_mut_ptr() as i32;
                                          #[link(wasm_import_module = "entity")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "persisted-resources")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_persisted-resources")]
                                            fn wit_import(
                                            _: i32, );
                                          }
                                          wit_import(ptr0);
                                          super::types::EntityId{id0:*((ptr0 + 0) as *const i64) as u64, id1:*((ptr0 + 8) as *const i64) as u64, }
                                        }
                                      }
                                      
                                    }
                                    
                                    
                                    #[allow(clippy::all)]
                                    pub mod message{
                                      #[used]
                                      #[doc(hidden)]
                                      #[cfg(target_arch = "wasm32")]
                                      static __FORCE_SECTION_REF: fn() = super::__link_section;
                                      
                                      #[allow(clippy::all)]
                                      pub fn subscribe(name: &str,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let vec0 = name;
                                          let ptr0 = vec0.as_ptr() as i32;
                                          let len0 = vec0.len() as i32;
                                          
                                          #[link(wasm_import_module = "message")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "subscribe")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "message_subscribe")]
                                            fn wit_import(
                                            _: i32, _: i32, );
                                          }
                                          wit_import(ptr0, len0);
                                        }
                                      }
                                      
                                    }
                                    
                                    
                                    #[allow(clippy::all)]
                                    pub mod player{
                                      #[used]
                                      #[doc(hidden)]
                                      #[cfg(target_arch = "wasm32")]
                                      static __FORCE_SECTION_REF: fn() = super::__link_section;
                                      
                                      pub type EntityId = super::types::EntityId;
                                      #[allow(clippy::all)]
                                      pub fn get_by_user_id(user_id: &str,) -> Option<EntityId>{
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          
                                          #[repr(align(8))]
                                          struct RetArea([u8; 24]);
                                          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                          let vec0 = user_id;
                                          let ptr0 = vec0.as_ptr() as i32;
                                          let len0 = vec0.len() as i32;
                                          let ptr1 = ret_area.as_mut_ptr() as i32;
                                          #[link(wasm_import_module = "player")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "get-by-user-id")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "player_get-by-user-id")]
                                            fn wit_import(
                                            _: i32, _: i32, _: i32, );
                                          }
                                          wit_import(ptr0, len0, ptr1);
                                          match i32::from(*((ptr1 + 0) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::types::EntityId{id0:*((ptr1 + 8) as *const i64) as u64, id1:*((ptr1 + 16) as *const i64) as u64, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }
                                        }
                                      }
                                      
                                    }
                                    
                                    
                                    #[allow(clippy::all)]
                                    pub mod world_audio{
                                      #[used]
                                      #[doc(hidden)]
                                      #[cfg(target_arch = "wasm32")]
                                      static __FORCE_SECTION_REF: fn() = super::__link_section;
                                      
                                      pub type EntityId = super::types::EntityId;
                                      #[allow(clippy::all)]
                                      pub fn set_listener(entity: EntityId,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                          
                                          #[link(wasm_import_module = "world-audio")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "set-listener")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "world-audio_set-listener")]
                                            fn wit_import(
                                            _: i64, _: i64, );
                                          }
                                          wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10));
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn set_emitter(entity: EntityId,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                          
                                          #[link(wasm_import_module = "world-audio")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "set-emitter")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "world-audio_set-emitter")]
                                            fn wit_import(
                                            _: i64, _: i64, );
                                          }
                                          wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10));
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn play_sound_on_entity(sound: &str,emitter: EntityId,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let vec0 = sound;
                                          let ptr0 = vec0.as_ptr() as i32;
                                          let len0 = vec0.len() as i32;
                                          let super::types::EntityId{ id0:id01, id1:id11, } = emitter;
                                          
                                          #[link(wasm_import_module = "world-audio")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "play-sound-on-entity")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "world-audio_play-sound-on-entity")]
                                            fn wit_import(
                                            _: i32, _: i32, _: i64, _: i64, );
                                          }
                                          wit_import(ptr0, len0, wit_bindgen::rt::as_i64(id01), wit_bindgen::rt::as_i64(id11));
                                        }
                                      }
                                      
                                    }
                                    
                                    
                                    #[allow(clippy::all)]
                                    pub mod client_audio{
                                      #[used]
                                      #[doc(hidden)]
                                      #[cfg(target_arch = "wasm32")]
                                      static __FORCE_SECTION_REF: fn() = super::__link_section;
                                      
                                      #[allow(clippy::all)]
                                      pub fn load(url: &str,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let vec0 = url;
                                          let ptr0 = vec0.as_ptr() as i32;
                                          let len0 = vec0.len() as i32;
                                          
                                          #[link(wasm_import_module = "client-audio")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "load")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-audio_load")]
                                            fn wit_import(
                                            _: i32, _: i32, );
                                          }
                                          wit_import(ptr0, len0);
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn play(name: &str,looping: bool,volume: f32,uid: u32,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let vec0 = name;
                                          let ptr0 = vec0.as_ptr() as i32;
                                          let len0 = vec0.len() as i32;
                                          
                                          #[link(wasm_import_module = "client-audio")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "play")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-audio_play")]
                                            fn wit_import(
                                            _: i32, _: i32, _: i32, _: f32, _: i32, );
                                          }
                                          wit_import(ptr0, len0, match looping { true => 1, false => 0 }, wit_bindgen::rt::as_f32(volume), wit_bindgen::rt::as_i32(uid));
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn stop(name: &str,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let vec0 = name;
                                          let ptr0 = vec0.as_ptr() as i32;
                                          let len0 = vec0.len() as i32;
                                          
                                          #[link(wasm_import_module = "client-audio")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "stop")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-audio_stop")]
                                            fn wit_import(
                                            _: i32, _: i32, );
                                          }
                                          wit_import(ptr0, len0);
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn stop_by_id(uid: u32,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          
                                          #[link(wasm_import_module = "client-audio")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "stop-by-id")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-audio_stop-by-id")]
                                            fn wit_import(
                                            _: i32, );
                                          }
                                          wit_import(wit_bindgen::rt::as_i32(uid));
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn set_volume(name: &str,volume: f32,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let vec0 = name;
                                          let ptr0 = vec0.as_ptr() as i32;
                                          let len0 = vec0.len() as i32;
                                          
                                          #[link(wasm_import_module = "client-audio")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "set-volume")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-audio_set-volume")]
                                            fn wit_import(
                                            _: i32, _: i32, _: f32, );
                                          }
                                          wit_import(ptr0, len0, wit_bindgen::rt::as_f32(volume));
                                        }
                                      }
                                      
                                    }
                                    
                                    
                                    #[allow(clippy::all)]
                                    pub mod client_message{
                                      #[used]
                                      #[doc(hidden)]
                                      #[cfg(target_arch = "wasm32")]
                                      static __FORCE_SECTION_REF: fn() = super::__link_section;
                                      
                                      pub type EntityId = super::types::EntityId;
                                      #[derive(Clone, Copy)]
                                      pub enum Target{
                                        ServerUnreliable,
                                        ServerReliable,
                                        LocalBroadcast,
                                        Local(EntityId),
                                      }
                                      impl core::fmt::Debug for Target {
                                        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                                          match self {
                                            Target::ServerUnreliable => {
                                              f.debug_tuple("Target::ServerUnreliable").finish()
                                            }
                                            Target::ServerReliable => {
                                              f.debug_tuple("Target::ServerReliable").finish()
                                            }
                                            Target::LocalBroadcast => {
                                              f.debug_tuple("Target::LocalBroadcast").finish()
                                            }
                                            Target::Local(e) => {
                                              f.debug_tuple("Target::Local").field(e).finish()
                                            }
                                          }
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn send(target_id: Target,name: &str,data: &[u8],){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let (result1_0,result1_1,result1_2,) = match target_id {
                                            Target::ServerUnreliable=> {
                                              (0i32, 0i64, 0i64)
                                            }
                                            Target::ServerReliable=> {
                                              (1i32, 0i64, 0i64)
                                            }
                                            Target::LocalBroadcast=> {
                                              (2i32, 0i64, 0i64)
                                            }
                                            Target::Local(e) => {
                                              let super::types::EntityId{ id0:id00, id1:id10, } = e;
                                              
                                              (3i32, wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10))
                                            },
                                          };
                                          let vec2 = name;
                                          let ptr2 = vec2.as_ptr() as i32;
                                          let len2 = vec2.len() as i32;
                                          let vec3 = data;
                                          let ptr3 = vec3.as_ptr() as i32;
                                          let len3 = vec3.len() as i32;
                                          
                                          #[link(wasm_import_module = "client-message")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "send")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-message_send")]
                                            fn wit_import(
                                            _: i32, _: i64, _: i64, _: i32, _: i32, _: i32, _: i32, );
                                          }
                                          wit_import(result1_0, result1_1, result1_2, ptr2, len2, ptr3, len3);
                                        }
                                      }
                                      
                                    }
                                    
                                    
                                    #[allow(clippy::all)]
                                    pub mod client_player{
                                      #[used]
                                      #[doc(hidden)]
                                      #[cfg(target_arch = "wasm32")]
                                      static __FORCE_SECTION_REF: fn() = super::__link_section;
                                      
                                      pub type EntityId = super::types::EntityId;
                                      #[allow(clippy::all)]
                                      pub fn get_local() -> EntityId{
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          
                                          #[repr(align(8))]
                                          struct RetArea([u8; 16]);
                                          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                          let ptr0 = ret_area.as_mut_ptr() as i32;
                                          #[link(wasm_import_module = "client-player")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "get-local")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-player_get-local")]
                                            fn wit_import(
                                            _: i32, );
                                          }
                                          wit_import(ptr0);
                                          super::types::EntityId{id0:*((ptr0 + 0) as *const i64) as u64, id1:*((ptr0 + 8) as *const i64) as u64, }
                                        }
                                      }
                                      
                                    }
                                    
                                    
                                    #[allow(clippy::all)]
                                    pub mod client_input{
                                      #[used]
                                      #[doc(hidden)]
                                      #[cfg(target_arch = "wasm32")]
                                      static __FORCE_SECTION_REF: fn() = super::__link_section;
                                      
                                      pub type Vec2 = super::types::Vec2;
                                      #[repr(u8)]
                                      #[derive(Clone, Copy, PartialEq, Eq)]
                                      pub enum VirtualKeyCode {
                                        /// The '1' key over the letters.
                                        Key1,
                                        /// The '2' key over the letters.
                                        Key2,
                                        /// The '3' key over the letters.
                                        Key3,
                                        /// The '4' key over the letters.
                                        Key4,
                                        /// The '5' key over the letters.
                                        Key5,
                                        /// The '6' key over the letters.
                                        Key6,
                                        /// The '7' key over the letters.
                                        Key7,
                                        /// The '8' key over the letters.
                                        Key8,
                                        /// The '9' key over the letters.
                                        Key9,
                                        /// The '0' key over the 'O' and 'P' keys.
                                        Key0,
                                        A,
                                        B,
                                        C,
                                        D,
                                        E,
                                        F,
                                        G,
                                        H,
                                        I,
                                        J,
                                        K,
                                        L,
                                        M,
                                        N,
                                        O,
                                        P,
                                        Q,
                                        R,
                                        S,
                                        T,
                                        U,
                                        V,
                                        W,
                                        X,
                                        Y,
                                        Z,
                                        /// The Escape key, next to F1.
                                        Escape,
                                        F1,
                                        F2,
                                        F3,
                                        F4,
                                        F5,
                                        F6,
                                        F7,
                                        F8,
                                        F9,
                                        F10,
                                        F11,
                                        F12,
                                        F13,
                                        F14,
                                        F15,
                                        F16,
                                        F17,
                                        F18,
                                        F19,
                                        F20,
                                        F21,
                                        F22,
                                        F23,
                                        F24,
                                        /// Print Screen/SysRq.
                                        Snapshot,
                                        /// Scroll Lock.
                                        Scroll,
                                        /// Pause/Break key, next to Scroll lock.
                                        Pause,
                                        /// `Insert`, next to Backspace.
                                        Insert,
                                        Home,
                                        Delete,
                                        End,
                                        PageDown,
                                        PageUp,
                                        Left,
                                        Up,
                                        Right,
                                        Down,
                                        /// The Backspace key, right over Enter.
                                        Back,
                                        /// The Enter key.
                                        Return,
                                        /// The space bar.
                                        Space,
                                        /// The "Compose" key on Linux.
                                        Compose,
                                        Caret,
                                        Numlock,
                                        Numpad0,
                                        Numpad1,
                                        Numpad2,
                                        Numpad3,
                                        Numpad4,
                                        Numpad5,
                                        Numpad6,
                                        Numpad7,
                                        Numpad8,
                                        Numpad9,
                                        NumpadAdd,
                                        NumpadDivide,
                                        NumpadDecimal,
                                        NumpadComma,
                                        NumpadEnter,
                                        NumpadEquals,
                                        NumpadMultiply,
                                        NumpadSubtract,
                                        AbntC1,
                                        AbntC2,
                                        Apostrophe,
                                        Apps,
                                        Asterisk,
                                        At,
                                        Ax,
                                        Backslash,
                                        Calculator,
                                        Capital,
                                        Colon,
                                        Comma,
                                        Convert,
                                        Equals,
                                        Grave,
                                        Kana,
                                        Kanji,
                                        LAlt,
                                        LBracket,
                                        LControl,
                                        LShift,
                                        LWin,
                                        Mail,
                                        MediaSelect,
                                        MediaStop,
                                        Minus,
                                        Mute,
                                        MyComputer,
                                        NavigateForward,
                                        NavigateBackward,
                                        NextTrack,
                                        NoConvert,
                                        Oem102,
                                        Period,
                                        PlayPause,
                                        Plus,
                                        Power,
                                        PrevTrack,
                                        RAlt,
                                        RBracket,
                                        RControl,
                                        RShift,
                                        RWin,
                                        Semicolon,
                                        Slash,
                                        Sleep,
                                        Stop,
                                        Sysrq,
                                        Tab,
                                        Underline,
                                        Unlabeled,
                                        VolumeDown,
                                        VolumeUp,
                                        Wake,
                                        WebBack,
                                        WebFavorites,
                                        WebForward,
                                        WebHome,
                                        WebRefresh,
                                        WebSearch,
                                        WebStop,
                                        Yen,
                                        Copy,
                                        Paste,
                                        Cut,
                                      }
                                      impl core::fmt::Debug for VirtualKeyCode {
                                        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                                          match self {
                                            VirtualKeyCode::Key1 => {
                                              f.debug_tuple("VirtualKeyCode::Key1").finish()
                                            }
                                            VirtualKeyCode::Key2 => {
                                              f.debug_tuple("VirtualKeyCode::Key2").finish()
                                            }
                                            VirtualKeyCode::Key3 => {
                                              f.debug_tuple("VirtualKeyCode::Key3").finish()
                                            }
                                            VirtualKeyCode::Key4 => {
                                              f.debug_tuple("VirtualKeyCode::Key4").finish()
                                            }
                                            VirtualKeyCode::Key5 => {
                                              f.debug_tuple("VirtualKeyCode::Key5").finish()
                                            }
                                            VirtualKeyCode::Key6 => {
                                              f.debug_tuple("VirtualKeyCode::Key6").finish()
                                            }
                                            VirtualKeyCode::Key7 => {
                                              f.debug_tuple("VirtualKeyCode::Key7").finish()
                                            }
                                            VirtualKeyCode::Key8 => {
                                              f.debug_tuple("VirtualKeyCode::Key8").finish()
                                            }
                                            VirtualKeyCode::Key9 => {
                                              f.debug_tuple("VirtualKeyCode::Key9").finish()
                                            }
                                            VirtualKeyCode::Key0 => {
                                              f.debug_tuple("VirtualKeyCode::Key0").finish()
                                            }
                                            VirtualKeyCode::A => {
                                              f.debug_tuple("VirtualKeyCode::A").finish()
                                            }
                                            VirtualKeyCode::B => {
                                              f.debug_tuple("VirtualKeyCode::B").finish()
                                            }
                                            VirtualKeyCode::C => {
                                              f.debug_tuple("VirtualKeyCode::C").finish()
                                            }
                                            VirtualKeyCode::D => {
                                              f.debug_tuple("VirtualKeyCode::D").finish()
                                            }
                                            VirtualKeyCode::E => {
                                              f.debug_tuple("VirtualKeyCode::E").finish()
                                            }
                                            VirtualKeyCode::F => {
                                              f.debug_tuple("VirtualKeyCode::F").finish()
                                            }
                                            VirtualKeyCode::G => {
                                              f.debug_tuple("VirtualKeyCode::G").finish()
                                            }
                                            VirtualKeyCode::H => {
                                              f.debug_tuple("VirtualKeyCode::H").finish()
                                            }
                                            VirtualKeyCode::I => {
                                              f.debug_tuple("VirtualKeyCode::I").finish()
                                            }
                                            VirtualKeyCode::J => {
                                              f.debug_tuple("VirtualKeyCode::J").finish()
                                            }
                                            VirtualKeyCode::K => {
                                              f.debug_tuple("VirtualKeyCode::K").finish()
                                            }
                                            VirtualKeyCode::L => {
                                              f.debug_tuple("VirtualKeyCode::L").finish()
                                            }
                                            VirtualKeyCode::M => {
                                              f.debug_tuple("VirtualKeyCode::M").finish()
                                            }
                                            VirtualKeyCode::N => {
                                              f.debug_tuple("VirtualKeyCode::N").finish()
                                            }
                                            VirtualKeyCode::O => {
                                              f.debug_tuple("VirtualKeyCode::O").finish()
                                            }
                                            VirtualKeyCode::P => {
                                              f.debug_tuple("VirtualKeyCode::P").finish()
                                            }
                                            VirtualKeyCode::Q => {
                                              f.debug_tuple("VirtualKeyCode::Q").finish()
                                            }
                                            VirtualKeyCode::R => {
                                              f.debug_tuple("VirtualKeyCode::R").finish()
                                            }
                                            VirtualKeyCode::S => {
                                              f.debug_tuple("VirtualKeyCode::S").finish()
                                            }
                                            VirtualKeyCode::T => {
                                              f.debug_tuple("VirtualKeyCode::T").finish()
                                            }
                                            VirtualKeyCode::U => {
                                              f.debug_tuple("VirtualKeyCode::U").finish()
                                            }
                                            VirtualKeyCode::V => {
                                              f.debug_tuple("VirtualKeyCode::V").finish()
                                            }
                                            VirtualKeyCode::W => {
                                              f.debug_tuple("VirtualKeyCode::W").finish()
                                            }
                                            VirtualKeyCode::X => {
                                              f.debug_tuple("VirtualKeyCode::X").finish()
                                            }
                                            VirtualKeyCode::Y => {
                                              f.debug_tuple("VirtualKeyCode::Y").finish()
                                            }
                                            VirtualKeyCode::Z => {
                                              f.debug_tuple("VirtualKeyCode::Z").finish()
                                            }
                                            VirtualKeyCode::Escape => {
                                              f.debug_tuple("VirtualKeyCode::Escape").finish()
                                            }
                                            VirtualKeyCode::F1 => {
                                              f.debug_tuple("VirtualKeyCode::F1").finish()
                                            }
                                            VirtualKeyCode::F2 => {
                                              f.debug_tuple("VirtualKeyCode::F2").finish()
                                            }
                                            VirtualKeyCode::F3 => {
                                              f.debug_tuple("VirtualKeyCode::F3").finish()
                                            }
                                            VirtualKeyCode::F4 => {
                                              f.debug_tuple("VirtualKeyCode::F4").finish()
                                            }
                                            VirtualKeyCode::F5 => {
                                              f.debug_tuple("VirtualKeyCode::F5").finish()
                                            }
                                            VirtualKeyCode::F6 => {
                                              f.debug_tuple("VirtualKeyCode::F6").finish()
                                            }
                                            VirtualKeyCode::F7 => {
                                              f.debug_tuple("VirtualKeyCode::F7").finish()
                                            }
                                            VirtualKeyCode::F8 => {
                                              f.debug_tuple("VirtualKeyCode::F8").finish()
                                            }
                                            VirtualKeyCode::F9 => {
                                              f.debug_tuple("VirtualKeyCode::F9").finish()
                                            }
                                            VirtualKeyCode::F10 => {
                                              f.debug_tuple("VirtualKeyCode::F10").finish()
                                            }
                                            VirtualKeyCode::F11 => {
                                              f.debug_tuple("VirtualKeyCode::F11").finish()
                                            }
                                            VirtualKeyCode::F12 => {
                                              f.debug_tuple("VirtualKeyCode::F12").finish()
                                            }
                                            VirtualKeyCode::F13 => {
                                              f.debug_tuple("VirtualKeyCode::F13").finish()
                                            }
                                            VirtualKeyCode::F14 => {
                                              f.debug_tuple("VirtualKeyCode::F14").finish()
                                            }
                                            VirtualKeyCode::F15 => {
                                              f.debug_tuple("VirtualKeyCode::F15").finish()
                                            }
                                            VirtualKeyCode::F16 => {
                                              f.debug_tuple("VirtualKeyCode::F16").finish()
                                            }
                                            VirtualKeyCode::F17 => {
                                              f.debug_tuple("VirtualKeyCode::F17").finish()
                                            }
                                            VirtualKeyCode::F18 => {
                                              f.debug_tuple("VirtualKeyCode::F18").finish()
                                            }
                                            VirtualKeyCode::F19 => {
                                              f.debug_tuple("VirtualKeyCode::F19").finish()
                                            }
                                            VirtualKeyCode::F20 => {
                                              f.debug_tuple("VirtualKeyCode::F20").finish()
                                            }
                                            VirtualKeyCode::F21 => {
                                              f.debug_tuple("VirtualKeyCode::F21").finish()
                                            }
                                            VirtualKeyCode::F22 => {
                                              f.debug_tuple("VirtualKeyCode::F22").finish()
                                            }
                                            VirtualKeyCode::F23 => {
                                              f.debug_tuple("VirtualKeyCode::F23").finish()
                                            }
                                            VirtualKeyCode::F24 => {
                                              f.debug_tuple("VirtualKeyCode::F24").finish()
                                            }
                                            VirtualKeyCode::Snapshot => {
                                              f.debug_tuple("VirtualKeyCode::Snapshot").finish()
                                            }
                                            VirtualKeyCode::Scroll => {
                                              f.debug_tuple("VirtualKeyCode::Scroll").finish()
                                            }
                                            VirtualKeyCode::Pause => {
                                              f.debug_tuple("VirtualKeyCode::Pause").finish()
                                            }
                                            VirtualKeyCode::Insert => {
                                              f.debug_tuple("VirtualKeyCode::Insert").finish()
                                            }
                                            VirtualKeyCode::Home => {
                                              f.debug_tuple("VirtualKeyCode::Home").finish()
                                            }
                                            VirtualKeyCode::Delete => {
                                              f.debug_tuple("VirtualKeyCode::Delete").finish()
                                            }
                                            VirtualKeyCode::End => {
                                              f.debug_tuple("VirtualKeyCode::End").finish()
                                            }
                                            VirtualKeyCode::PageDown => {
                                              f.debug_tuple("VirtualKeyCode::PageDown").finish()
                                            }
                                            VirtualKeyCode::PageUp => {
                                              f.debug_tuple("VirtualKeyCode::PageUp").finish()
                                            }
                                            VirtualKeyCode::Left => {
                                              f.debug_tuple("VirtualKeyCode::Left").finish()
                                            }
                                            VirtualKeyCode::Up => {
                                              f.debug_tuple("VirtualKeyCode::Up").finish()
                                            }
                                            VirtualKeyCode::Right => {
                                              f.debug_tuple("VirtualKeyCode::Right").finish()
                                            }
                                            VirtualKeyCode::Down => {
                                              f.debug_tuple("VirtualKeyCode::Down").finish()
                                            }
                                            VirtualKeyCode::Back => {
                                              f.debug_tuple("VirtualKeyCode::Back").finish()
                                            }
                                            VirtualKeyCode::Return => {
                                              f.debug_tuple("VirtualKeyCode::Return").finish()
                                            }
                                            VirtualKeyCode::Space => {
                                              f.debug_tuple("VirtualKeyCode::Space").finish()
                                            }
                                            VirtualKeyCode::Compose => {
                                              f.debug_tuple("VirtualKeyCode::Compose").finish()
                                            }
                                            VirtualKeyCode::Caret => {
                                              f.debug_tuple("VirtualKeyCode::Caret").finish()
                                            }
                                            VirtualKeyCode::Numlock => {
                                              f.debug_tuple("VirtualKeyCode::Numlock").finish()
                                            }
                                            VirtualKeyCode::Numpad0 => {
                                              f.debug_tuple("VirtualKeyCode::Numpad0").finish()
                                            }
                                            VirtualKeyCode::Numpad1 => {
                                              f.debug_tuple("VirtualKeyCode::Numpad1").finish()
                                            }
                                            VirtualKeyCode::Numpad2 => {
                                              f.debug_tuple("VirtualKeyCode::Numpad2").finish()
                                            }
                                            VirtualKeyCode::Numpad3 => {
                                              f.debug_tuple("VirtualKeyCode::Numpad3").finish()
                                            }
                                            VirtualKeyCode::Numpad4 => {
                                              f.debug_tuple("VirtualKeyCode::Numpad4").finish()
                                            }
                                            VirtualKeyCode::Numpad5 => {
                                              f.debug_tuple("VirtualKeyCode::Numpad5").finish()
                                            }
                                            VirtualKeyCode::Numpad6 => {
                                              f.debug_tuple("VirtualKeyCode::Numpad6").finish()
                                            }
                                            VirtualKeyCode::Numpad7 => {
                                              f.debug_tuple("VirtualKeyCode::Numpad7").finish()
                                            }
                                            VirtualKeyCode::Numpad8 => {
                                              f.debug_tuple("VirtualKeyCode::Numpad8").finish()
                                            }
                                            VirtualKeyCode::Numpad9 => {
                                              f.debug_tuple("VirtualKeyCode::Numpad9").finish()
                                            }
                                            VirtualKeyCode::NumpadAdd => {
                                              f.debug_tuple("VirtualKeyCode::NumpadAdd").finish()
                                            }
                                            VirtualKeyCode::NumpadDivide => {
                                              f.debug_tuple("VirtualKeyCode::NumpadDivide").finish()
                                            }
                                            VirtualKeyCode::NumpadDecimal => {
                                              f.debug_tuple("VirtualKeyCode::NumpadDecimal").finish()
                                            }
                                            VirtualKeyCode::NumpadComma => {
                                              f.debug_tuple("VirtualKeyCode::NumpadComma").finish()
                                            }
                                            VirtualKeyCode::NumpadEnter => {
                                              f.debug_tuple("VirtualKeyCode::NumpadEnter").finish()
                                            }
                                            VirtualKeyCode::NumpadEquals => {
                                              f.debug_tuple("VirtualKeyCode::NumpadEquals").finish()
                                            }
                                            VirtualKeyCode::NumpadMultiply => {
                                              f.debug_tuple("VirtualKeyCode::NumpadMultiply").finish()
                                            }
                                            VirtualKeyCode::NumpadSubtract => {
                                              f.debug_tuple("VirtualKeyCode::NumpadSubtract").finish()
                                            }
                                            VirtualKeyCode::AbntC1 => {
                                              f.debug_tuple("VirtualKeyCode::AbntC1").finish()
                                            }
                                            VirtualKeyCode::AbntC2 => {
                                              f.debug_tuple("VirtualKeyCode::AbntC2").finish()
                                            }
                                            VirtualKeyCode::Apostrophe => {
                                              f.debug_tuple("VirtualKeyCode::Apostrophe").finish()
                                            }
                                            VirtualKeyCode::Apps => {
                                              f.debug_tuple("VirtualKeyCode::Apps").finish()
                                            }
                                            VirtualKeyCode::Asterisk => {
                                              f.debug_tuple("VirtualKeyCode::Asterisk").finish()
                                            }
                                            VirtualKeyCode::At => {
                                              f.debug_tuple("VirtualKeyCode::At").finish()
                                            }
                                            VirtualKeyCode::Ax => {
                                              f.debug_tuple("VirtualKeyCode::Ax").finish()
                                            }
                                            VirtualKeyCode::Backslash => {
                                              f.debug_tuple("VirtualKeyCode::Backslash").finish()
                                            }
                                            VirtualKeyCode::Calculator => {
                                              f.debug_tuple("VirtualKeyCode::Calculator").finish()
                                            }
                                            VirtualKeyCode::Capital => {
                                              f.debug_tuple("VirtualKeyCode::Capital").finish()
                                            }
                                            VirtualKeyCode::Colon => {
                                              f.debug_tuple("VirtualKeyCode::Colon").finish()
                                            }
                                            VirtualKeyCode::Comma => {
                                              f.debug_tuple("VirtualKeyCode::Comma").finish()
                                            }
                                            VirtualKeyCode::Convert => {
                                              f.debug_tuple("VirtualKeyCode::Convert").finish()
                                            }
                                            VirtualKeyCode::Equals => {
                                              f.debug_tuple("VirtualKeyCode::Equals").finish()
                                            }
                                            VirtualKeyCode::Grave => {
                                              f.debug_tuple("VirtualKeyCode::Grave").finish()
                                            }
                                            VirtualKeyCode::Kana => {
                                              f.debug_tuple("VirtualKeyCode::Kana").finish()
                                            }
                                            VirtualKeyCode::Kanji => {
                                              f.debug_tuple("VirtualKeyCode::Kanji").finish()
                                            }
                                            VirtualKeyCode::LAlt => {
                                              f.debug_tuple("VirtualKeyCode::LAlt").finish()
                                            }
                                            VirtualKeyCode::LBracket => {
                                              f.debug_tuple("VirtualKeyCode::LBracket").finish()
                                            }
                                            VirtualKeyCode::LControl => {
                                              f.debug_tuple("VirtualKeyCode::LControl").finish()
                                            }
                                            VirtualKeyCode::LShift => {
                                              f.debug_tuple("VirtualKeyCode::LShift").finish()
                                            }
                                            VirtualKeyCode::LWin => {
                                              f.debug_tuple("VirtualKeyCode::LWin").finish()
                                            }
                                            VirtualKeyCode::Mail => {
                                              f.debug_tuple("VirtualKeyCode::Mail").finish()
                                            }
                                            VirtualKeyCode::MediaSelect => {
                                              f.debug_tuple("VirtualKeyCode::MediaSelect").finish()
                                            }
                                            VirtualKeyCode::MediaStop => {
                                              f.debug_tuple("VirtualKeyCode::MediaStop").finish()
                                            }
                                            VirtualKeyCode::Minus => {
                                              f.debug_tuple("VirtualKeyCode::Minus").finish()
                                            }
                                            VirtualKeyCode::Mute => {
                                              f.debug_tuple("VirtualKeyCode::Mute").finish()
                                            }
                                            VirtualKeyCode::MyComputer => {
                                              f.debug_tuple("VirtualKeyCode::MyComputer").finish()
                                            }
                                            VirtualKeyCode::NavigateForward => {
                                              f.debug_tuple("VirtualKeyCode::NavigateForward").finish()
                                            }
                                            VirtualKeyCode::NavigateBackward => {
                                              f.debug_tuple("VirtualKeyCode::NavigateBackward").finish()
                                            }
                                            VirtualKeyCode::NextTrack => {
                                              f.debug_tuple("VirtualKeyCode::NextTrack").finish()
                                            }
                                            VirtualKeyCode::NoConvert => {
                                              f.debug_tuple("VirtualKeyCode::NoConvert").finish()
                                            }
                                            VirtualKeyCode::Oem102 => {
                                              f.debug_tuple("VirtualKeyCode::Oem102").finish()
                                            }
                                            VirtualKeyCode::Period => {
                                              f.debug_tuple("VirtualKeyCode::Period").finish()
                                            }
                                            VirtualKeyCode::PlayPause => {
                                              f.debug_tuple("VirtualKeyCode::PlayPause").finish()
                                            }
                                            VirtualKeyCode::Plus => {
                                              f.debug_tuple("VirtualKeyCode::Plus").finish()
                                            }
                                            VirtualKeyCode::Power => {
                                              f.debug_tuple("VirtualKeyCode::Power").finish()
                                            }
                                            VirtualKeyCode::PrevTrack => {
                                              f.debug_tuple("VirtualKeyCode::PrevTrack").finish()
                                            }
                                            VirtualKeyCode::RAlt => {
                                              f.debug_tuple("VirtualKeyCode::RAlt").finish()
                                            }
                                            VirtualKeyCode::RBracket => {
                                              f.debug_tuple("VirtualKeyCode::RBracket").finish()
                                            }
                                            VirtualKeyCode::RControl => {
                                              f.debug_tuple("VirtualKeyCode::RControl").finish()
                                            }
                                            VirtualKeyCode::RShift => {
                                              f.debug_tuple("VirtualKeyCode::RShift").finish()
                                            }
                                            VirtualKeyCode::RWin => {
                                              f.debug_tuple("VirtualKeyCode::RWin").finish()
                                            }
                                            VirtualKeyCode::Semicolon => {
                                              f.debug_tuple("VirtualKeyCode::Semicolon").finish()
                                            }
                                            VirtualKeyCode::Slash => {
                                              f.debug_tuple("VirtualKeyCode::Slash").finish()
                                            }
                                            VirtualKeyCode::Sleep => {
                                              f.debug_tuple("VirtualKeyCode::Sleep").finish()
                                            }
                                            VirtualKeyCode::Stop => {
                                              f.debug_tuple("VirtualKeyCode::Stop").finish()
                                            }
                                            VirtualKeyCode::Sysrq => {
                                              f.debug_tuple("VirtualKeyCode::Sysrq").finish()
                                            }
                                            VirtualKeyCode::Tab => {
                                              f.debug_tuple("VirtualKeyCode::Tab").finish()
                                            }
                                            VirtualKeyCode::Underline => {
                                              f.debug_tuple("VirtualKeyCode::Underline").finish()
                                            }
                                            VirtualKeyCode::Unlabeled => {
                                              f.debug_tuple("VirtualKeyCode::Unlabeled").finish()
                                            }
                                            VirtualKeyCode::VolumeDown => {
                                              f.debug_tuple("VirtualKeyCode::VolumeDown").finish()
                                            }
                                            VirtualKeyCode::VolumeUp => {
                                              f.debug_tuple("VirtualKeyCode::VolumeUp").finish()
                                            }
                                            VirtualKeyCode::Wake => {
                                              f.debug_tuple("VirtualKeyCode::Wake").finish()
                                            }
                                            VirtualKeyCode::WebBack => {
                                              f.debug_tuple("VirtualKeyCode::WebBack").finish()
                                            }
                                            VirtualKeyCode::WebFavorites => {
                                              f.debug_tuple("VirtualKeyCode::WebFavorites").finish()
                                            }
                                            VirtualKeyCode::WebForward => {
                                              f.debug_tuple("VirtualKeyCode::WebForward").finish()
                                            }
                                            VirtualKeyCode::WebHome => {
                                              f.debug_tuple("VirtualKeyCode::WebHome").finish()
                                            }
                                            VirtualKeyCode::WebRefresh => {
                                              f.debug_tuple("VirtualKeyCode::WebRefresh").finish()
                                            }
                                            VirtualKeyCode::WebSearch => {
                                              f.debug_tuple("VirtualKeyCode::WebSearch").finish()
                                            }
                                            VirtualKeyCode::WebStop => {
                                              f.debug_tuple("VirtualKeyCode::WebStop").finish()
                                            }
                                            VirtualKeyCode::Yen => {
                                              f.debug_tuple("VirtualKeyCode::Yen").finish()
                                            }
                                            VirtualKeyCode::Copy => {
                                              f.debug_tuple("VirtualKeyCode::Copy").finish()
                                            }
                                            VirtualKeyCode::Paste => {
                                              f.debug_tuple("VirtualKeyCode::Paste").finish()
                                            }
                                            VirtualKeyCode::Cut => {
                                              f.debug_tuple("VirtualKeyCode::Cut").finish()
                                            }
                                          }
                                        }
                                      }
                                      #[derive(Clone, Copy)]
                                      pub enum MouseButton{
                                        Left,
                                        Right,
                                        Middle,
                                        Other(u16),
                                      }
                                      impl core::fmt::Debug for MouseButton {
                                        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                                          match self {
                                            MouseButton::Left => {
                                              f.debug_tuple("MouseButton::Left").finish()
                                            }
                                            MouseButton::Right => {
                                              f.debug_tuple("MouseButton::Right").finish()
                                            }
                                            MouseButton::Middle => {
                                              f.debug_tuple("MouseButton::Middle").finish()
                                            }
                                            MouseButton::Other(e) => {
                                              f.debug_tuple("MouseButton::Other").field(e).finish()
                                            }
                                          }
                                        }
                                      }
                                      #[derive(Clone)]
                                      pub struct Input {
                                        pub keys: wit_bindgen::rt::vec::Vec::<VirtualKeyCode>,
                                        pub mouse_position: Vec2,
                                        pub mouse_delta: Vec2,
                                        pub mouse_wheel: f32,
                                        pub mouse_buttons: wit_bindgen::rt::vec::Vec::<MouseButton>,
                                      }
                                      impl core::fmt::Debug for Input {
                                        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                                          f.debug_struct("Input").field("keys", &self.keys).field("mouse-position", &self.mouse_position).field("mouse-delta", &self.mouse_delta).field("mouse-wheel", &self.mouse_wheel).field("mouse-buttons", &self.mouse_buttons).finish()
                                        }
                                      }
                                      #[derive(Clone, Copy)]
                                      pub enum CursorIcon{
                                        /// The platform-dependent default cursor.
                                        DefaultIcon,
                                        /// A simple crosshair.
                                        Crosshair,
                                        /// A hand (often used to indicate links in web browsers).
                                        Hand,
                                        /// Self explanatory.
                                        Arrow,
                                        /// Indicates something is to be moved.
                                        Move,
                                        /// Indicates text that may be selected or edited.
                                        Text,
                                        /// Program busy indicator.
                                        Wait,
                                        /// Help indicator (often rendered as a "?")
                                        Help,
                                        /// Progress indicator. Shows that processing is being done. But in contrast
                                        /// with "Wait" the user may still interact with the program. Often rendered
                                        /// as a spinning beach ball, or an arrow with a watch or hourglass.
                                        Progress,
                                        /// Cursor showing that something cannot be done.
                                        NotAllowed,
                                        ContextMenu,
                                        Cell,
                                        VerticalText,
                                        Alias,
                                        Copy,
                                        NoDrop,
                                        /// Indicates something can be grabbed.
                                        Grab,
                                        /// Indicates something is grabbed.
                                        Grabbing,
                                        AllScroll,
                                        ZoomIn,
                                        ZoomOut,
                                        /// Indicate that some edge is to be moved. For example, the 'SeResize' cursor
                                        /// is used when the movement starts from the south-east corner of the box.
                                        EResize,
                                        NResize,
                                        NeResize,
                                        NwResize,
                                        SResize,
                                        SeResize,
                                        SwResize,
                                        WResize,
                                        EwResize,
                                        NsResize,
                                        NeswResize,
                                        NwseResize,
                                        ColResize,
                                        RowResize,
                                      }
                                      impl core::fmt::Debug for CursorIcon {
                                        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                                          match self {
                                            CursorIcon::DefaultIcon => {
                                              f.debug_tuple("CursorIcon::DefaultIcon").finish()
                                            }
                                            CursorIcon::Crosshair => {
                                              f.debug_tuple("CursorIcon::Crosshair").finish()
                                            }
                                            CursorIcon::Hand => {
                                              f.debug_tuple("CursorIcon::Hand").finish()
                                            }
                                            CursorIcon::Arrow => {
                                              f.debug_tuple("CursorIcon::Arrow").finish()
                                            }
                                            CursorIcon::Move => {
                                              f.debug_tuple("CursorIcon::Move").finish()
                                            }
                                            CursorIcon::Text => {
                                              f.debug_tuple("CursorIcon::Text").finish()
                                            }
                                            CursorIcon::Wait => {
                                              f.debug_tuple("CursorIcon::Wait").finish()
                                            }
                                            CursorIcon::Help => {
                                              f.debug_tuple("CursorIcon::Help").finish()
                                            }
                                            CursorIcon::Progress => {
                                              f.debug_tuple("CursorIcon::Progress").finish()
                                            }
                                            CursorIcon::NotAllowed => {
                                              f.debug_tuple("CursorIcon::NotAllowed").finish()
                                            }
                                            CursorIcon::ContextMenu => {
                                              f.debug_tuple("CursorIcon::ContextMenu").finish()
                                            }
                                            CursorIcon::Cell => {
                                              f.debug_tuple("CursorIcon::Cell").finish()
                                            }
                                            CursorIcon::VerticalText => {
                                              f.debug_tuple("CursorIcon::VerticalText").finish()
                                            }
                                            CursorIcon::Alias => {
                                              f.debug_tuple("CursorIcon::Alias").finish()
                                            }
                                            CursorIcon::Copy => {
                                              f.debug_tuple("CursorIcon::Copy").finish()
                                            }
                                            CursorIcon::NoDrop => {
                                              f.debug_tuple("CursorIcon::NoDrop").finish()
                                            }
                                            CursorIcon::Grab => {
                                              f.debug_tuple("CursorIcon::Grab").finish()
                                            }
                                            CursorIcon::Grabbing => {
                                              f.debug_tuple("CursorIcon::Grabbing").finish()
                                            }
                                            CursorIcon::AllScroll => {
                                              f.debug_tuple("CursorIcon::AllScroll").finish()
                                            }
                                            CursorIcon::ZoomIn => {
                                              f.debug_tuple("CursorIcon::ZoomIn").finish()
                                            }
                                            CursorIcon::ZoomOut => {
                                              f.debug_tuple("CursorIcon::ZoomOut").finish()
                                            }
                                            CursorIcon::EResize => {
                                              f.debug_tuple("CursorIcon::EResize").finish()
                                            }
                                            CursorIcon::NResize => {
                                              f.debug_tuple("CursorIcon::NResize").finish()
                                            }
                                            CursorIcon::NeResize => {
                                              f.debug_tuple("CursorIcon::NeResize").finish()
                                            }
                                            CursorIcon::NwResize => {
                                              f.debug_tuple("CursorIcon::NwResize").finish()
                                            }
                                            CursorIcon::SResize => {
                                              f.debug_tuple("CursorIcon::SResize").finish()
                                            }
                                            CursorIcon::SeResize => {
                                              f.debug_tuple("CursorIcon::SeResize").finish()
                                            }
                                            CursorIcon::SwResize => {
                                              f.debug_tuple("CursorIcon::SwResize").finish()
                                            }
                                            CursorIcon::WResize => {
                                              f.debug_tuple("CursorIcon::WResize").finish()
                                            }
                                            CursorIcon::EwResize => {
                                              f.debug_tuple("CursorIcon::EwResize").finish()
                                            }
                                            CursorIcon::NsResize => {
                                              f.debug_tuple("CursorIcon::NsResize").finish()
                                            }
                                            CursorIcon::NeswResize => {
                                              f.debug_tuple("CursorIcon::NeswResize").finish()
                                            }
                                            CursorIcon::NwseResize => {
                                              f.debug_tuple("CursorIcon::NwseResize").finish()
                                            }
                                            CursorIcon::ColResize => {
                                              f.debug_tuple("CursorIcon::ColResize").finish()
                                            }
                                            CursorIcon::RowResize => {
                                              f.debug_tuple("CursorIcon::RowResize").finish()
                                            }
                                          }
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn get() -> Input{
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          
                                          #[repr(align(4))]
                                          struct RetArea([u8; 36]);
                                          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                          let ptr0 = ret_area.as_mut_ptr() as i32;
                                          #[link(wasm_import_module = "client-input")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "get")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-input_get")]
                                            fn wit_import(
                                            _: i32, );
                                          }
                                          wit_import(ptr0);
                                          let base1 = *((ptr0 + 0) as *const i32);
                                          let len1 = *((ptr0 + 4) as *const i32);
                                          let mut result1 = Vec::with_capacity(len1 as usize);
                                          for i in 0..len1 {
                                            let base = base1 + i *1;
                                            result1.push({#[cfg(debug_assertions)]{match i32::from(*((base + 0) as *const u8)) {
                                              0 => VirtualKeyCode::Key1,
                                              1 => VirtualKeyCode::Key2,
                                              2 => VirtualKeyCode::Key3,
                                              3 => VirtualKeyCode::Key4,
                                              4 => VirtualKeyCode::Key5,
                                              5 => VirtualKeyCode::Key6,
                                              6 => VirtualKeyCode::Key7,
                                              7 => VirtualKeyCode::Key8,
                                              8 => VirtualKeyCode::Key9,
                                              9 => VirtualKeyCode::Key0,
                                              10 => VirtualKeyCode::A,
                                              11 => VirtualKeyCode::B,
                                              12 => VirtualKeyCode::C,
                                              13 => VirtualKeyCode::D,
                                              14 => VirtualKeyCode::E,
                                              15 => VirtualKeyCode::F,
                                              16 => VirtualKeyCode::G,
                                              17 => VirtualKeyCode::H,
                                              18 => VirtualKeyCode::I,
                                              19 => VirtualKeyCode::J,
                                              20 => VirtualKeyCode::K,
                                              21 => VirtualKeyCode::L,
                                              22 => VirtualKeyCode::M,
                                              23 => VirtualKeyCode::N,
                                              24 => VirtualKeyCode::O,
                                              25 => VirtualKeyCode::P,
                                              26 => VirtualKeyCode::Q,
                                              27 => VirtualKeyCode::R,
                                              28 => VirtualKeyCode::S,
                                              29 => VirtualKeyCode::T,
                                              30 => VirtualKeyCode::U,
                                              31 => VirtualKeyCode::V,
                                              32 => VirtualKeyCode::W,
                                              33 => VirtualKeyCode::X,
                                              34 => VirtualKeyCode::Y,
                                              35 => VirtualKeyCode::Z,
                                              36 => VirtualKeyCode::Escape,
                                              37 => VirtualKeyCode::F1,
                                              38 => VirtualKeyCode::F2,
                                              39 => VirtualKeyCode::F3,
                                              40 => VirtualKeyCode::F4,
                                              41 => VirtualKeyCode::F5,
                                              42 => VirtualKeyCode::F6,
                                              43 => VirtualKeyCode::F7,
                                              44 => VirtualKeyCode::F8,
                                              45 => VirtualKeyCode::F9,
                                              46 => VirtualKeyCode::F10,
                                              47 => VirtualKeyCode::F11,
                                              48 => VirtualKeyCode::F12,
                                              49 => VirtualKeyCode::F13,
                                              50 => VirtualKeyCode::F14,
                                              51 => VirtualKeyCode::F15,
                                              52 => VirtualKeyCode::F16,
                                              53 => VirtualKeyCode::F17,
                                              54 => VirtualKeyCode::F18,
                                              55 => VirtualKeyCode::F19,
                                              56 => VirtualKeyCode::F20,
                                              57 => VirtualKeyCode::F21,
                                              58 => VirtualKeyCode::F22,
                                              59 => VirtualKeyCode::F23,
                                              60 => VirtualKeyCode::F24,
                                              61 => VirtualKeyCode::Snapshot,
                                              62 => VirtualKeyCode::Scroll,
                                              63 => VirtualKeyCode::Pause,
                                              64 => VirtualKeyCode::Insert,
                                              65 => VirtualKeyCode::Home,
                                              66 => VirtualKeyCode::Delete,
                                              67 => VirtualKeyCode::End,
                                              68 => VirtualKeyCode::PageDown,
                                              69 => VirtualKeyCode::PageUp,
                                              70 => VirtualKeyCode::Left,
                                              71 => VirtualKeyCode::Up,
                                              72 => VirtualKeyCode::Right,
                                              73 => VirtualKeyCode::Down,
                                              74 => VirtualKeyCode::Back,
                                              75 => VirtualKeyCode::Return,
                                              76 => VirtualKeyCode::Space,
                                              77 => VirtualKeyCode::Compose,
                                              78 => VirtualKeyCode::Caret,
                                              79 => VirtualKeyCode::Numlock,
                                              80 => VirtualKeyCode::Numpad0,
                                              81 => VirtualKeyCode::Numpad1,
                                              82 => VirtualKeyCode::Numpad2,
                                              83 => VirtualKeyCode::Numpad3,
                                              84 => VirtualKeyCode::Numpad4,
                                              85 => VirtualKeyCode::Numpad5,
                                              86 => VirtualKeyCode::Numpad6,
                                              87 => VirtualKeyCode::Numpad7,
                                              88 => VirtualKeyCode::Numpad8,
                                              89 => VirtualKeyCode::Numpad9,
                                              90 => VirtualKeyCode::NumpadAdd,
                                              91 => VirtualKeyCode::NumpadDivide,
                                              92 => VirtualKeyCode::NumpadDecimal,
                                              93 => VirtualKeyCode::NumpadComma,
                                              94 => VirtualKeyCode::NumpadEnter,
                                              95 => VirtualKeyCode::NumpadEquals,
                                              96 => VirtualKeyCode::NumpadMultiply,
                                              97 => VirtualKeyCode::NumpadSubtract,
                                              98 => VirtualKeyCode::AbntC1,
                                              99 => VirtualKeyCode::AbntC2,
                                              100 => VirtualKeyCode::Apostrophe,
                                              101 => VirtualKeyCode::Apps,
                                              102 => VirtualKeyCode::Asterisk,
                                              103 => VirtualKeyCode::At,
                                              104 => VirtualKeyCode::Ax,
                                              105 => VirtualKeyCode::Backslash,
                                              106 => VirtualKeyCode::Calculator,
                                              107 => VirtualKeyCode::Capital,
                                              108 => VirtualKeyCode::Colon,
                                              109 => VirtualKeyCode::Comma,
                                              110 => VirtualKeyCode::Convert,
                                              111 => VirtualKeyCode::Equals,
                                              112 => VirtualKeyCode::Grave,
                                              113 => VirtualKeyCode::Kana,
                                              114 => VirtualKeyCode::Kanji,
                                              115 => VirtualKeyCode::LAlt,
                                              116 => VirtualKeyCode::LBracket,
                                              117 => VirtualKeyCode::LControl,
                                              118 => VirtualKeyCode::LShift,
                                              119 => VirtualKeyCode::LWin,
                                              120 => VirtualKeyCode::Mail,
                                              121 => VirtualKeyCode::MediaSelect,
                                              122 => VirtualKeyCode::MediaStop,
                                              123 => VirtualKeyCode::Minus,
                                              124 => VirtualKeyCode::Mute,
                                              125 => VirtualKeyCode::MyComputer,
                                              126 => VirtualKeyCode::NavigateForward,
                                              127 => VirtualKeyCode::NavigateBackward,
                                              128 => VirtualKeyCode::NextTrack,
                                              129 => VirtualKeyCode::NoConvert,
                                              130 => VirtualKeyCode::Oem102,
                                              131 => VirtualKeyCode::Period,
                                              132 => VirtualKeyCode::PlayPause,
                                              133 => VirtualKeyCode::Plus,
                                              134 => VirtualKeyCode::Power,
                                              135 => VirtualKeyCode::PrevTrack,
                                              136 => VirtualKeyCode::RAlt,
                                              137 => VirtualKeyCode::RBracket,
                                              138 => VirtualKeyCode::RControl,
                                              139 => VirtualKeyCode::RShift,
                                              140 => VirtualKeyCode::RWin,
                                              141 => VirtualKeyCode::Semicolon,
                                              142 => VirtualKeyCode::Slash,
                                              143 => VirtualKeyCode::Sleep,
                                              144 => VirtualKeyCode::Stop,
                                              145 => VirtualKeyCode::Sysrq,
                                              146 => VirtualKeyCode::Tab,
                                              147 => VirtualKeyCode::Underline,
                                              148 => VirtualKeyCode::Unlabeled,
                                              149 => VirtualKeyCode::VolumeDown,
                                              150 => VirtualKeyCode::VolumeUp,
                                              151 => VirtualKeyCode::Wake,
                                              152 => VirtualKeyCode::WebBack,
                                              153 => VirtualKeyCode::WebFavorites,
                                              154 => VirtualKeyCode::WebForward,
                                              155 => VirtualKeyCode::WebHome,
                                              156 => VirtualKeyCode::WebRefresh,
                                              157 => VirtualKeyCode::WebSearch,
                                              158 => VirtualKeyCode::WebStop,
                                              159 => VirtualKeyCode::Yen,
                                              160 => VirtualKeyCode::Copy,
                                              161 => VirtualKeyCode::Paste,
                                              162 => VirtualKeyCode::Cut,
                                              _ => panic!("invalid enum discriminant"),
                                            }}#[cfg(not(debug_assertions))]{core::mem::transmute::<_, VirtualKeyCode>(i32::from(*((base + 0) as *const u8)) as u8)}});
                                          }
                                          wit_bindgen::rt::dealloc(base1, (len1 as usize) * 1, 1);
                                          let base2 = *((ptr0 + 28) as *const i32);
                                          let len2 = *((ptr0 + 32) as *const i32);
                                          let mut result2 = Vec::with_capacity(len2 as usize);
                                          for i in 0..len2 {
                                            let base = base2 + i *4;
                                            result2.push({{match i32::from(*((base + 0) as *const u8)) {
                                              0 => MouseButton::Left,
                                              1 => MouseButton::Right,
                                              2 => MouseButton::Middle,
                                              #[cfg(debug_assertions)]3 => MouseButton::Other(i32::from(*((base + 2) as *const u16)) as u16),
                                              #[cfg(not(debug_assertions))]_ => MouseButton::Other(i32::from(*((base + 2) as *const u16)) as u16),
                                              #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                            }}});
                                          }
                                          wit_bindgen::rt::dealloc(base2, (len2 as usize) * 4, 2);
                                          Input{keys:result1, mouse_position:super::types::Vec2{x:*((ptr0 + 8) as *const f32), y:*((ptr0 + 12) as *const f32), }, mouse_delta:super::types::Vec2{x:*((ptr0 + 16) as *const f32), y:*((ptr0 + 20) as *const f32), }, mouse_wheel:*((ptr0 + 24) as *const f32), mouse_buttons:result2, }
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn get_previous() -> Input{
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          
                                          #[repr(align(4))]
                                          struct RetArea([u8; 36]);
                                          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                          let ptr0 = ret_area.as_mut_ptr() as i32;
                                          #[link(wasm_import_module = "client-input")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "get-previous")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-input_get-previous")]
                                            fn wit_import(
                                            _: i32, );
                                          }
                                          wit_import(ptr0);
                                          let base1 = *((ptr0 + 0) as *const i32);
                                          let len1 = *((ptr0 + 4) as *const i32);
                                          let mut result1 = Vec::with_capacity(len1 as usize);
                                          for i in 0..len1 {
                                            let base = base1 + i *1;
                                            result1.push({#[cfg(debug_assertions)]{match i32::from(*((base + 0) as *const u8)) {
                                              0 => VirtualKeyCode::Key1,
                                              1 => VirtualKeyCode::Key2,
                                              2 => VirtualKeyCode::Key3,
                                              3 => VirtualKeyCode::Key4,
                                              4 => VirtualKeyCode::Key5,
                                              5 => VirtualKeyCode::Key6,
                                              6 => VirtualKeyCode::Key7,
                                              7 => VirtualKeyCode::Key8,
                                              8 => VirtualKeyCode::Key9,
                                              9 => VirtualKeyCode::Key0,
                                              10 => VirtualKeyCode::A,
                                              11 => VirtualKeyCode::B,
                                              12 => VirtualKeyCode::C,
                                              13 => VirtualKeyCode::D,
                                              14 => VirtualKeyCode::E,
                                              15 => VirtualKeyCode::F,
                                              16 => VirtualKeyCode::G,
                                              17 => VirtualKeyCode::H,
                                              18 => VirtualKeyCode::I,
                                              19 => VirtualKeyCode::J,
                                              20 => VirtualKeyCode::K,
                                              21 => VirtualKeyCode::L,
                                              22 => VirtualKeyCode::M,
                                              23 => VirtualKeyCode::N,
                                              24 => VirtualKeyCode::O,
                                              25 => VirtualKeyCode::P,
                                              26 => VirtualKeyCode::Q,
                                              27 => VirtualKeyCode::R,
                                              28 => VirtualKeyCode::S,
                                              29 => VirtualKeyCode::T,
                                              30 => VirtualKeyCode::U,
                                              31 => VirtualKeyCode::V,
                                              32 => VirtualKeyCode::W,
                                              33 => VirtualKeyCode::X,
                                              34 => VirtualKeyCode::Y,
                                              35 => VirtualKeyCode::Z,
                                              36 => VirtualKeyCode::Escape,
                                              37 => VirtualKeyCode::F1,
                                              38 => VirtualKeyCode::F2,
                                              39 => VirtualKeyCode::F3,
                                              40 => VirtualKeyCode::F4,
                                              41 => VirtualKeyCode::F5,
                                              42 => VirtualKeyCode::F6,
                                              43 => VirtualKeyCode::F7,
                                              44 => VirtualKeyCode::F8,
                                              45 => VirtualKeyCode::F9,
                                              46 => VirtualKeyCode::F10,
                                              47 => VirtualKeyCode::F11,
                                              48 => VirtualKeyCode::F12,
                                              49 => VirtualKeyCode::F13,
                                              50 => VirtualKeyCode::F14,
                                              51 => VirtualKeyCode::F15,
                                              52 => VirtualKeyCode::F16,
                                              53 => VirtualKeyCode::F17,
                                              54 => VirtualKeyCode::F18,
                                              55 => VirtualKeyCode::F19,
                                              56 => VirtualKeyCode::F20,
                                              57 => VirtualKeyCode::F21,
                                              58 => VirtualKeyCode::F22,
                                              59 => VirtualKeyCode::F23,
                                              60 => VirtualKeyCode::F24,
                                              61 => VirtualKeyCode::Snapshot,
                                              62 => VirtualKeyCode::Scroll,
                                              63 => VirtualKeyCode::Pause,
                                              64 => VirtualKeyCode::Insert,
                                              65 => VirtualKeyCode::Home,
                                              66 => VirtualKeyCode::Delete,
                                              67 => VirtualKeyCode::End,
                                              68 => VirtualKeyCode::PageDown,
                                              69 => VirtualKeyCode::PageUp,
                                              70 => VirtualKeyCode::Left,
                                              71 => VirtualKeyCode::Up,
                                              72 => VirtualKeyCode::Right,
                                              73 => VirtualKeyCode::Down,
                                              74 => VirtualKeyCode::Back,
                                              75 => VirtualKeyCode::Return,
                                              76 => VirtualKeyCode::Space,
                                              77 => VirtualKeyCode::Compose,
                                              78 => VirtualKeyCode::Caret,
                                              79 => VirtualKeyCode::Numlock,
                                              80 => VirtualKeyCode::Numpad0,
                                              81 => VirtualKeyCode::Numpad1,
                                              82 => VirtualKeyCode::Numpad2,
                                              83 => VirtualKeyCode::Numpad3,
                                              84 => VirtualKeyCode::Numpad4,
                                              85 => VirtualKeyCode::Numpad5,
                                              86 => VirtualKeyCode::Numpad6,
                                              87 => VirtualKeyCode::Numpad7,
                                              88 => VirtualKeyCode::Numpad8,
                                              89 => VirtualKeyCode::Numpad9,
                                              90 => VirtualKeyCode::NumpadAdd,
                                              91 => VirtualKeyCode::NumpadDivide,
                                              92 => VirtualKeyCode::NumpadDecimal,
                                              93 => VirtualKeyCode::NumpadComma,
                                              94 => VirtualKeyCode::NumpadEnter,
                                              95 => VirtualKeyCode::NumpadEquals,
                                              96 => VirtualKeyCode::NumpadMultiply,
                                              97 => VirtualKeyCode::NumpadSubtract,
                                              98 => VirtualKeyCode::AbntC1,
                                              99 => VirtualKeyCode::AbntC2,
                                              100 => VirtualKeyCode::Apostrophe,
                                              101 => VirtualKeyCode::Apps,
                                              102 => VirtualKeyCode::Asterisk,
                                              103 => VirtualKeyCode::At,
                                              104 => VirtualKeyCode::Ax,
                                              105 => VirtualKeyCode::Backslash,
                                              106 => VirtualKeyCode::Calculator,
                                              107 => VirtualKeyCode::Capital,
                                              108 => VirtualKeyCode::Colon,
                                              109 => VirtualKeyCode::Comma,
                                              110 => VirtualKeyCode::Convert,
                                              111 => VirtualKeyCode::Equals,
                                              112 => VirtualKeyCode::Grave,
                                              113 => VirtualKeyCode::Kana,
                                              114 => VirtualKeyCode::Kanji,
                                              115 => VirtualKeyCode::LAlt,
                                              116 => VirtualKeyCode::LBracket,
                                              117 => VirtualKeyCode::LControl,
                                              118 => VirtualKeyCode::LShift,
                                              119 => VirtualKeyCode::LWin,
                                              120 => VirtualKeyCode::Mail,
                                              121 => VirtualKeyCode::MediaSelect,
                                              122 => VirtualKeyCode::MediaStop,
                                              123 => VirtualKeyCode::Minus,
                                              124 => VirtualKeyCode::Mute,
                                              125 => VirtualKeyCode::MyComputer,
                                              126 => VirtualKeyCode::NavigateForward,
                                              127 => VirtualKeyCode::NavigateBackward,
                                              128 => VirtualKeyCode::NextTrack,
                                              129 => VirtualKeyCode::NoConvert,
                                              130 => VirtualKeyCode::Oem102,
                                              131 => VirtualKeyCode::Period,
                                              132 => VirtualKeyCode::PlayPause,
                                              133 => VirtualKeyCode::Plus,
                                              134 => VirtualKeyCode::Power,
                                              135 => VirtualKeyCode::PrevTrack,
                                              136 => VirtualKeyCode::RAlt,
                                              137 => VirtualKeyCode::RBracket,
                                              138 => VirtualKeyCode::RControl,
                                              139 => VirtualKeyCode::RShift,
                                              140 => VirtualKeyCode::RWin,
                                              141 => VirtualKeyCode::Semicolon,
                                              142 => VirtualKeyCode::Slash,
                                              143 => VirtualKeyCode::Sleep,
                                              144 => VirtualKeyCode::Stop,
                                              145 => VirtualKeyCode::Sysrq,
                                              146 => VirtualKeyCode::Tab,
                                              147 => VirtualKeyCode::Underline,
                                              148 => VirtualKeyCode::Unlabeled,
                                              149 => VirtualKeyCode::VolumeDown,
                                              150 => VirtualKeyCode::VolumeUp,
                                              151 => VirtualKeyCode::Wake,
                                              152 => VirtualKeyCode::WebBack,
                                              153 => VirtualKeyCode::WebFavorites,
                                              154 => VirtualKeyCode::WebForward,
                                              155 => VirtualKeyCode::WebHome,
                                              156 => VirtualKeyCode::WebRefresh,
                                              157 => VirtualKeyCode::WebSearch,
                                              158 => VirtualKeyCode::WebStop,
                                              159 => VirtualKeyCode::Yen,
                                              160 => VirtualKeyCode::Copy,
                                              161 => VirtualKeyCode::Paste,
                                              162 => VirtualKeyCode::Cut,
                                              _ => panic!("invalid enum discriminant"),
                                            }}#[cfg(not(debug_assertions))]{core::mem::transmute::<_, VirtualKeyCode>(i32::from(*((base + 0) as *const u8)) as u8)}});
                                          }
                                          wit_bindgen::rt::dealloc(base1, (len1 as usize) * 1, 1);
                                          let base2 = *((ptr0 + 28) as *const i32);
                                          let len2 = *((ptr0 + 32) as *const i32);
                                          let mut result2 = Vec::with_capacity(len2 as usize);
                                          for i in 0..len2 {
                                            let base = base2 + i *4;
                                            result2.push({{match i32::from(*((base + 0) as *const u8)) {
                                              0 => MouseButton::Left,
                                              1 => MouseButton::Right,
                                              2 => MouseButton::Middle,
                                              #[cfg(debug_assertions)]3 => MouseButton::Other(i32::from(*((base + 2) as *const u16)) as u16),
                                              #[cfg(not(debug_assertions))]_ => MouseButton::Other(i32::from(*((base + 2) as *const u16)) as u16),
                                              #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                            }}});
                                          }
                                          wit_bindgen::rt::dealloc(base2, (len2 as usize) * 4, 2);
                                          Input{keys:result1, mouse_position:super::types::Vec2{x:*((ptr0 + 8) as *const f32), y:*((ptr0 + 12) as *const f32), }, mouse_delta:super::types::Vec2{x:*((ptr0 + 16) as *const f32), y:*((ptr0 + 20) as *const f32), }, mouse_wheel:*((ptr0 + 24) as *const f32), mouse_buttons:result2, }
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn set_cursor(icon: CursorIcon,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let result0 = match icon {
                                            CursorIcon::DefaultIcon=> {
                                              0i32
                                            }
                                            CursorIcon::Crosshair=> {
                                              1i32
                                            }
                                            CursorIcon::Hand=> {
                                              2i32
                                            }
                                            CursorIcon::Arrow=> {
                                              3i32
                                            }
                                            CursorIcon::Move=> {
                                              4i32
                                            }
                                            CursorIcon::Text=> {
                                              5i32
                                            }
                                            CursorIcon::Wait=> {
                                              6i32
                                            }
                                            CursorIcon::Help=> {
                                              7i32
                                            }
                                            CursorIcon::Progress=> {
                                              8i32
                                            }
                                            CursorIcon::NotAllowed=> {
                                              9i32
                                            }
                                            CursorIcon::ContextMenu=> {
                                              10i32
                                            }
                                            CursorIcon::Cell=> {
                                              11i32
                                            }
                                            CursorIcon::VerticalText=> {
                                              12i32
                                            }
                                            CursorIcon::Alias=> {
                                              13i32
                                            }
                                            CursorIcon::Copy=> {
                                              14i32
                                            }
                                            CursorIcon::NoDrop=> {
                                              15i32
                                            }
                                            CursorIcon::Grab=> {
                                              16i32
                                            }
                                            CursorIcon::Grabbing=> {
                                              17i32
                                            }
                                            CursorIcon::AllScroll=> {
                                              18i32
                                            }
                                            CursorIcon::ZoomIn=> {
                                              19i32
                                            }
                                            CursorIcon::ZoomOut=> {
                                              20i32
                                            }
                                            CursorIcon::EResize=> {
                                              21i32
                                            }
                                            CursorIcon::NResize=> {
                                              22i32
                                            }
                                            CursorIcon::NeResize=> {
                                              23i32
                                            }
                                            CursorIcon::NwResize=> {
                                              24i32
                                            }
                                            CursorIcon::SResize=> {
                                              25i32
                                            }
                                            CursorIcon::SeResize=> {
                                              26i32
                                            }
                                            CursorIcon::SwResize=> {
                                              27i32
                                            }
                                            CursorIcon::WResize=> {
                                              28i32
                                            }
                                            CursorIcon::EwResize=> {
                                              29i32
                                            }
                                            CursorIcon::NsResize=> {
                                              30i32
                                            }
                                            CursorIcon::NeswResize=> {
                                              31i32
                                            }
                                            CursorIcon::NwseResize=> {
                                              32i32
                                            }
                                            CursorIcon::ColResize=> {
                                              33i32
                                            }
                                            CursorIcon::RowResize=> {
                                              34i32
                                            }
                                          };
                                          
                                          #[link(wasm_import_module = "client-input")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "set-cursor")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-input_set-cursor")]
                                            fn wit_import(
                                            _: i32, );
                                          }
                                          wit_import(result0);
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn set_cursor_visible(visible: bool,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          
                                          #[link(wasm_import_module = "client-input")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "set-cursor-visible")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-input_set-cursor-visible")]
                                            fn wit_import(
                                            _: i32, );
                                          }
                                          wit_import(match visible { true => 1, false => 0 });
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn set_cursor_lock(locked: bool,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          
                                          #[link(wasm_import_module = "client-input")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "set-cursor-lock")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-input_set-cursor-lock")]
                                            fn wit_import(
                                            _: i32, );
                                          }
                                          wit_import(match locked { true => 1, false => 0 });
                                        }
                                      }
                                      
                                    }
                                    
                                    
                                    #[allow(clippy::all)]
                                    pub mod client_camera{
                                      #[used]
                                      #[doc(hidden)]
                                      #[cfg(target_arch = "wasm32")]
                                      static __FORCE_SECTION_REF: fn() = super::__link_section;
                                      
                                      pub type Vec3 = super::types::Vec3;
                                      pub type Vec2 = super::types::Vec2;
                                      pub type Ray = super::types::Ray;
                                      pub type EntityId = super::types::EntityId;
                                      #[allow(clippy::all)]
                                      pub fn clip_space_ray(camera: EntityId,clip_space_pos: Vec2,) -> Ray{
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          
                                          #[repr(align(4))]
                                          struct RetArea([u8; 24]);
                                          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                          let super::types::EntityId{ id0:id00, id1:id10, } = camera;
                                          let super::types::Vec2{ x:x1, y:y1, } = clip_space_pos;
                                          let ptr2 = ret_area.as_mut_ptr() as i32;
                                          #[link(wasm_import_module = "client-camera")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "clip-space-ray")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-camera_clip-space-ray")]
                                            fn wit_import(
                                            _: i64, _: i64, _: f32, _: f32, _: i32, );
                                          }
                                          wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), ptr2);
                                          super::types::Ray{origin:super::types::Vec3{x:*((ptr2 + 0) as *const f32), y:*((ptr2 + 4) as *const f32), z:*((ptr2 + 8) as *const f32), }, dir:super::types::Vec3{x:*((ptr2 + 12) as *const f32), y:*((ptr2 + 16) as *const f32), z:*((ptr2 + 20) as *const f32), }, }
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn screen_to_clip_space(screen_pos: Vec2,) -> Vec2{
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          
                                          #[repr(align(4))]
                                          struct RetArea([u8; 8]);
                                          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                          let super::types::Vec2{ x:x0, y:y0, } = screen_pos;
                                          let ptr1 = ret_area.as_mut_ptr() as i32;
                                          #[link(wasm_import_module = "client-camera")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "screen-to-clip-space")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-camera_screen-to-clip-space")]
                                            fn wit_import(
                                            _: f32, _: f32, _: i32, );
                                          }
                                          wit_import(wit_bindgen::rt::as_f32(x0), wit_bindgen::rt::as_f32(y0), ptr1);
                                          super::types::Vec2{x:*((ptr1 + 0) as *const f32), y:*((ptr1 + 4) as *const f32), }
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn screen_to_world_direction(camera: EntityId,screen_pos: Vec2,) -> Ray{
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          
                                          #[repr(align(4))]
                                          struct RetArea([u8; 24]);
                                          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                          let super::types::EntityId{ id0:id00, id1:id10, } = camera;
                                          let super::types::Vec2{ x:x1, y:y1, } = screen_pos;
                                          let ptr2 = ret_area.as_mut_ptr() as i32;
                                          #[link(wasm_import_module = "client-camera")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "screen-to-world-direction")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-camera_screen-to-world-direction")]
                                            fn wit_import(
                                            _: i64, _: i64, _: f32, _: f32, _: i32, );
                                          }
                                          wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), ptr2);
                                          super::types::Ray{origin:super::types::Vec3{x:*((ptr2 + 0) as *const f32), y:*((ptr2 + 4) as *const f32), z:*((ptr2 + 8) as *const f32), }, dir:super::types::Vec3{x:*((ptr2 + 12) as *const f32), y:*((ptr2 + 16) as *const f32), z:*((ptr2 + 20) as *const f32), }, }
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn world_to_screen(camera: EntityId,screen_pos: Vec3,) -> Vec2{
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          
                                          #[repr(align(4))]
                                          struct RetArea([u8; 8]);
                                          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                          let super::types::EntityId{ id0:id00, id1:id10, } = camera;
                                          let super::types::Vec3{ x:x1, y:y1, z:z1, } = screen_pos;
                                          let ptr2 = ret_area.as_mut_ptr() as i32;
                                          #[link(wasm_import_module = "client-camera")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "world-to-screen")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-camera_world-to-screen")]
                                            fn wit_import(
                                            _: i64, _: i64, _: f32, _: f32, _: f32, _: i32, );
                                          }
                                          wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1), ptr2);
                                          super::types::Vec2{x:*((ptr2 + 0) as *const f32), y:*((ptr2 + 4) as *const f32), }
                                        }
                                      }
                                      
                                    }
                                    
                                    
                                    #[allow(clippy::all)]
                                    pub mod client_window{
                                      #[used]
                                      #[doc(hidden)]
                                      #[cfg(target_arch = "wasm32")]
                                      static __FORCE_SECTION_REF: fn() = super::__link_section;
                                      
                                      #[allow(clippy::all)]
                                      pub fn set_fullscreen(fullscreen: bool,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          
                                          #[link(wasm_import_module = "client-window")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "set-fullscreen")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "client-window_set-fullscreen")]
                                            fn wit_import(
                                            _: i32, );
                                          }
                                          wit_import(match fullscreen { true => 1, false => 0 });
                                        }
                                      }
                                      
                                    }
                                    
                                    
                                    #[allow(clippy::all)]
                                    pub mod server_physics{
                                      #[used]
                                      #[doc(hidden)]
                                      #[cfg(target_arch = "wasm32")]
                                      static __FORCE_SECTION_REF: fn() = super::__link_section;
                                      
                                      pub type EntityId = super::types::EntityId;
                                      pub type Vec3 = super::types::Vec3;
                                      pub type Mat4 = super::types::Mat4;
                                      #[repr(C)]
                                      #[derive(Copy, Clone)]
                                      pub struct CharacterCollision {
                                        pub side: bool,
                                        pub up: bool,
                                        pub down: bool,
                                      }
                                      impl core::fmt::Debug for CharacterCollision {
                                        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                                          f.debug_struct("CharacterCollision").field("side", &self.side).field("up", &self.up).field("down", &self.down).finish()
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn add_force(entity: EntityId,force: Vec3,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                          let super::types::Vec3{ x:x1, y:y1, z:z1, } = force;
                                          
                                          #[link(wasm_import_module = "server-physics")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "add-force")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "server-physics_add-force")]
                                            fn wit_import(
                                            _: i64, _: i64, _: f32, _: f32, _: f32, );
                                          }
                                          wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1));
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn add_impulse(entity: EntityId,impulse: Vec3,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                          let super::types::Vec3{ x:x1, y:y1, z:z1, } = impulse;
                                          
                                          #[link(wasm_import_module = "server-physics")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "add-impulse")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "server-physics_add-impulse")]
                                            fn wit_import(
                                            _: i64, _: i64, _: f32, _: f32, _: f32, );
                                          }
                                          wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1));
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn add_radial_impulse(position: Vec3,impulse: f32,radius: f32,falloff_radius: Option<f32>,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let super::types::Vec3{ x:x0, y:y0, z:z0, } = position;
                                          let (result1_0,result1_1,) = match falloff_radius {
                                            Some(e) => (1i32, wit_bindgen::rt::as_f32(e)),
                                            None => {
                                              (0i32, 0.0f32)
                                            },
                                          };
                                          #[link(wasm_import_module = "server-physics")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "add-radial-impulse")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "server-physics_add-radial-impulse")]
                                            fn wit_import(
                                            _: f32, _: f32, _: f32, _: f32, _: f32, _: i32, _: f32, );
                                          }
                                          wit_import(wit_bindgen::rt::as_f32(x0), wit_bindgen::rt::as_f32(y0), wit_bindgen::rt::as_f32(z0), wit_bindgen::rt::as_f32(impulse), wit_bindgen::rt::as_f32(radius), result1_0, result1_1);
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn add_force_at_position(entity: EntityId,force: Vec3,position: Vec3,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                          let super::types::Vec3{ x:x1, y:y1, z:z1, } = force;
                                          let super::types::Vec3{ x:x2, y:y2, z:z2, } = position;
                                          
                                          #[link(wasm_import_module = "server-physics")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "add-force-at-position")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "server-physics_add-force-at-position")]
                                            fn wit_import(
                                            _: i64, _: i64, _: f32, _: f32, _: f32, _: f32, _: f32, _: f32, );
                                          }
                                          wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1), wit_bindgen::rt::as_f32(x2), wit_bindgen::rt::as_f32(y2), wit_bindgen::rt::as_f32(z2));
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn add_impulse_at_position(entity: EntityId,impulse: Vec3,position: Vec3,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                          let super::types::Vec3{ x:x1, y:y1, z:z1, } = impulse;
                                          let super::types::Vec3{ x:x2, y:y2, z:z2, } = position;
                                          
                                          #[link(wasm_import_module = "server-physics")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "add-impulse-at-position")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "server-physics_add-impulse-at-position")]
                                            fn wit_import(
                                            _: i64, _: i64, _: f32, _: f32, _: f32, _: f32, _: f32, _: f32, );
                                          }
                                          wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1), wit_bindgen::rt::as_f32(x2), wit_bindgen::rt::as_f32(y2), wit_bindgen::rt::as_f32(z2));
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn get_velocity_at_position(entity: EntityId,position: Vec3,) -> Vec3{
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          
                                          #[repr(align(4))]
                                          struct RetArea([u8; 12]);
                                          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                          let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                          let super::types::Vec3{ x:x1, y:y1, z:z1, } = position;
                                          let ptr2 = ret_area.as_mut_ptr() as i32;
                                          #[link(wasm_import_module = "server-physics")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "get-velocity-at-position")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "server-physics_get-velocity-at-position")]
                                            fn wit_import(
                                            _: i64, _: i64, _: f32, _: f32, _: f32, _: i32, );
                                          }
                                          wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1), ptr2);
                                          super::types::Vec3{x:*((ptr2 + 0) as *const f32), y:*((ptr2 + 4) as *const f32), z:*((ptr2 + 8) as *const f32), }
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn set_gravity(gravity: Vec3,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let super::types::Vec3{ x:x0, y:y0, z:z0, } = gravity;
                                          
                                          #[link(wasm_import_module = "server-physics")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "set-gravity")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "server-physics_set-gravity")]
                                            fn wit_import(
                                            _: f32, _: f32, _: f32, );
                                          }
                                          wit_import(wit_bindgen::rt::as_f32(x0), wit_bindgen::rt::as_f32(y0), wit_bindgen::rt::as_f32(z0));
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn unfreeze(entity: EntityId,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                          
                                          #[link(wasm_import_module = "server-physics")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "unfreeze")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "server-physics_unfreeze")]
                                            fn wit_import(
                                            _: i64, _: i64, );
                                          }
                                          wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10));
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn freeze(entity: EntityId,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                          
                                          #[link(wasm_import_module = "server-physics")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "freeze")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "server-physics_freeze")]
                                            fn wit_import(
                                            _: i64, _: i64, );
                                          }
                                          wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10));
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn start_motor(entity: EntityId,velocity: f32,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                          
                                          #[link(wasm_import_module = "server-physics")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "start-motor")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "server-physics_start-motor")]
                                            fn wit_import(
                                            _: i64, _: i64, _: f32, );
                                          }
                                          wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(velocity));
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn stop_motor(entity: EntityId,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                          
                                          #[link(wasm_import_module = "server-physics")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "stop-motor")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "server-physics_stop-motor")]
                                            fn wit_import(
                                            _: i64, _: i64, );
                                          }
                                          wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10));
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn create_revolute_joint(actor0: EntityId,transform0: Mat4,actor1: EntityId,transform1: Mat4,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          
                                          #[repr(align(8))]
                                          struct RetArea([u8; 160]);
                                          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                          let ptr0 = ret_area.as_mut_ptr() as i32;let super::types::EntityId{ id0:id01, id1:id11, } = actor0;
                                          *((ptr0 + 0) as *mut i64) = wit_bindgen::rt::as_i64(id01);
                                          *((ptr0 + 8) as *mut i64) = wit_bindgen::rt::as_i64(id11);
                                          let super::types::Mat4{ x:x2, y:y2, z:z2, w:w2, } = transform0;
                                          let super::types::Vec4{ x:x3, y:y3, z:z3, w:w3, } = x2;
                                          *((ptr0 + 16) as *mut f32) = wit_bindgen::rt::as_f32(x3);
                                          *((ptr0 + 20) as *mut f32) = wit_bindgen::rt::as_f32(y3);
                                          *((ptr0 + 24) as *mut f32) = wit_bindgen::rt::as_f32(z3);
                                          *((ptr0 + 28) as *mut f32) = wit_bindgen::rt::as_f32(w3);
                                          let super::types::Vec4{ x:x4, y:y4, z:z4, w:w4, } = y2;
                                          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x4);
                                          *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y4);
                                          *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z4);
                                          *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w4);
                                          let super::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = z2;
                                          *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(x5);
                                          *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(y5);
                                          *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(z5);
                                          *((ptr0 + 60) as *mut f32) = wit_bindgen::rt::as_f32(w5);
                                          let super::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = w2;
                                          *((ptr0 + 64) as *mut f32) = wit_bindgen::rt::as_f32(x6);
                                          *((ptr0 + 68) as *mut f32) = wit_bindgen::rt::as_f32(y6);
                                          *((ptr0 + 72) as *mut f32) = wit_bindgen::rt::as_f32(z6);
                                          *((ptr0 + 76) as *mut f32) = wit_bindgen::rt::as_f32(w6);
                                          let super::types::EntityId{ id0:id07, id1:id17, } = actor1;
                                          *((ptr0 + 80) as *mut i64) = wit_bindgen::rt::as_i64(id07);
                                          *((ptr0 + 88) as *mut i64) = wit_bindgen::rt::as_i64(id17);
                                          let super::types::Mat4{ x:x8, y:y8, z:z8, w:w8, } = transform1;
                                          let super::types::Vec4{ x:x9, y:y9, z:z9, w:w9, } = x8;
                                          *((ptr0 + 96) as *mut f32) = wit_bindgen::rt::as_f32(x9);
                                          *((ptr0 + 100) as *mut f32) = wit_bindgen::rt::as_f32(y9);
                                          *((ptr0 + 104) as *mut f32) = wit_bindgen::rt::as_f32(z9);
                                          *((ptr0 + 108) as *mut f32) = wit_bindgen::rt::as_f32(w9);
                                          let super::types::Vec4{ x:x10, y:y10, z:z10, w:w10, } = y8;
                                          *((ptr0 + 112) as *mut f32) = wit_bindgen::rt::as_f32(x10);
                                          *((ptr0 + 116) as *mut f32) = wit_bindgen::rt::as_f32(y10);
                                          *((ptr0 + 120) as *mut f32) = wit_bindgen::rt::as_f32(z10);
                                          *((ptr0 + 124) as *mut f32) = wit_bindgen::rt::as_f32(w10);
                                          let super::types::Vec4{ x:x11, y:y11, z:z11, w:w11, } = z8;
                                          *((ptr0 + 128) as *mut f32) = wit_bindgen::rt::as_f32(x11);
                                          *((ptr0 + 132) as *mut f32) = wit_bindgen::rt::as_f32(y11);
                                          *((ptr0 + 136) as *mut f32) = wit_bindgen::rt::as_f32(z11);
                                          *((ptr0 + 140) as *mut f32) = wit_bindgen::rt::as_f32(w11);
                                          let super::types::Vec4{ x:x12, y:y12, z:z12, w:w12, } = w8;
                                          *((ptr0 + 144) as *mut f32) = wit_bindgen::rt::as_f32(x12);
                                          *((ptr0 + 148) as *mut f32) = wit_bindgen::rt::as_f32(y12);
                                          *((ptr0 + 152) as *mut f32) = wit_bindgen::rt::as_f32(z12);
                                          *((ptr0 + 156) as *mut f32) = wit_bindgen::rt::as_f32(w12);
                                          
                                          #[link(wasm_import_module = "server-physics")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "create-revolute-joint")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "server-physics_create-revolute-joint")]
                                            fn wit_import(
                                            _: i32, );
                                          }
                                          wit_import(ptr0);
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn raycast_first(origin: Vec3,direction: Vec3,) -> Option<(EntityId,f32,)>{
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          
                                          #[repr(align(8))]
                                          struct RetArea([u8; 32]);
                                          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                          let super::types::Vec3{ x:x0, y:y0, z:z0, } = origin;
                                          let super::types::Vec3{ x:x1, y:y1, z:z1, } = direction;
                                          let ptr2 = ret_area.as_mut_ptr() as i32;
                                          #[link(wasm_import_module = "server-physics")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "raycast-first")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "server-physics_raycast-first")]
                                            fn wit_import(
                                            _: f32, _: f32, _: f32, _: f32, _: f32, _: f32, _: i32, );
                                          }
                                          wit_import(wit_bindgen::rt::as_f32(x0), wit_bindgen::rt::as_f32(y0), wit_bindgen::rt::as_f32(z0), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1), ptr2);
                                          match i32::from(*((ptr2 + 0) as *const u8)) {
                                            0 => None,
                                            1 => Some((super::types::EntityId{id0:*((ptr2 + 8) as *const i64) as u64, id1:*((ptr2 + 16) as *const i64) as u64, }, *((ptr2 + 24) as *const f32))),
                                            #[cfg(not(debug_assertions))]
                                            _ => core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn raycast(origin: Vec3,direction: Vec3,) -> wit_bindgen::rt::vec::Vec::<(EntityId,f32,)>{
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          
                                          #[repr(align(4))]
                                          struct RetArea([u8; 8]);
                                          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                          let super::types::Vec3{ x:x0, y:y0, z:z0, } = origin;
                                          let super::types::Vec3{ x:x1, y:y1, z:z1, } = direction;
                                          let ptr2 = ret_area.as_mut_ptr() as i32;
                                          #[link(wasm_import_module = "server-physics")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "raycast")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "server-physics_raycast")]
                                            fn wit_import(
                                            _: f32, _: f32, _: f32, _: f32, _: f32, _: f32, _: i32, );
                                          }
                                          wit_import(wit_bindgen::rt::as_f32(x0), wit_bindgen::rt::as_f32(y0), wit_bindgen::rt::as_f32(z0), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1), ptr2);
                                          let len3 = *((ptr2 + 4) as *const i32) as usize;
                                          Vec::from_raw_parts(*((ptr2 + 0) as *const i32) as *mut _, len3, len3)
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn move_character(entity: EntityId,displacement: Vec3,min_dist: f32,elapsed_time: f32,) -> CharacterCollision{
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          
                                          #[repr(align(1))]
                                          struct RetArea([u8; 3]);
                                          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                          let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                          let super::types::Vec3{ x:x1, y:y1, z:z1, } = displacement;
                                          let ptr2 = ret_area.as_mut_ptr() as i32;
                                          #[link(wasm_import_module = "server-physics")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "move-character")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "server-physics_move-character")]
                                            fn wit_import(
                                            _: i64, _: i64, _: f32, _: f32, _: f32, _: f32, _: f32, _: i32, );
                                          }
                                          wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1), wit_bindgen::rt::as_f32(min_dist), wit_bindgen::rt::as_f32(elapsed_time), ptr2);
                                          CharacterCollision{side:{
                                            #[cfg(not(debug_assertions))]
                                            { core::mem::transmute::<u8, bool>(i32::from(*((ptr2 + 0) as *const u8)) as u8) }
                                            #[cfg(debug_assertions)]
                                            {
                                              match i32::from(*((ptr2 + 0) as *const u8)) {
                                                0 => false,
                                                1 => true,
                                                _ => panic!("invalid bool discriminant"),
                                              }
                                            }
                                          }, up:{
                                            #[cfg(not(debug_assertions))]
                                            { core::mem::transmute::<u8, bool>(i32::from(*((ptr2 + 1) as *const u8)) as u8) }
                                            #[cfg(debug_assertions)]
                                            {
                                              match i32::from(*((ptr2 + 1) as *const u8)) {
                                                0 => false,
                                                1 => true,
                                                _ => panic!("invalid bool discriminant"),
                                              }
                                            }
                                          }, down:{
                                            #[cfg(not(debug_assertions))]
                                            { core::mem::transmute::<u8, bool>(i32::from(*((ptr2 + 2) as *const u8)) as u8) }
                                            #[cfg(debug_assertions)]
                                            {
                                              match i32::from(*((ptr2 + 2) as *const u8)) {
                                                0 => false,
                                                1 => true,
                                                _ => panic!("invalid bool discriminant"),
                                              }
                                            }
                                          }, }
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn set_character_position(entity: EntityId,position: Vec3,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                          let super::types::Vec3{ x:x1, y:y1, z:z1, } = position;
                                          
                                          #[link(wasm_import_module = "server-physics")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "set-character-position")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "server-physics_set-character-position")]
                                            fn wit_import(
                                            _: i64, _: i64, _: f32, _: f32, _: f32, );
                                          }
                                          wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1));
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn set_character_foot_position(entity: EntityId,position: Vec3,){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                          let super::types::Vec3{ x:x1, y:y1, z:z1, } = position;
                                          
                                          #[link(wasm_import_module = "server-physics")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "set-character-foot-position")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "server-physics_set-character-foot-position")]
                                            fn wit_import(
                                            _: i64, _: i64, _: f32, _: f32, _: f32, );
                                          }
                                          wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1));
                                        }
                                      }
                                      
                                    }
                                    
                                    
                                    #[allow(clippy::all)]
                                    pub mod server_message{
                                      #[used]
                                      #[doc(hidden)]
                                      #[cfg(target_arch = "wasm32")]
                                      static __FORCE_SECTION_REF: fn() = super::__link_section;
                                      
                                      pub type EntityId = super::types::EntityId;
                                      #[derive(Clone)]
                                      pub enum Target<'a,>{
                                        ClientBroadcastUnreliable,
                                        ClientBroadcastReliable,
                                        ClientTargetedUnreliable(&'a str),
                                        ClientTargetedReliable(&'a str),
                                        LocalBroadcast,
                                        Local(EntityId),
                                      }
                                      impl<'a,> core::fmt::Debug for Target<'a,> {
                                        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                                          match self {
                                            Target::ClientBroadcastUnreliable => {
                                              f.debug_tuple("Target::ClientBroadcastUnreliable").finish()
                                            }
                                            Target::ClientBroadcastReliable => {
                                              f.debug_tuple("Target::ClientBroadcastReliable").finish()
                                            }
                                            Target::ClientTargetedUnreliable(e) => {
                                              f.debug_tuple("Target::ClientTargetedUnreliable").field(e).finish()
                                            }
                                            Target::ClientTargetedReliable(e) => {
                                              f.debug_tuple("Target::ClientTargetedReliable").field(e).finish()
                                            }
                                            Target::LocalBroadcast => {
                                              f.debug_tuple("Target::LocalBroadcast").finish()
                                            }
                                            Target::Local(e) => {
                                              f.debug_tuple("Target::Local").field(e).finish()
                                            }
                                          }
                                        }
                                      }
                                      #[allow(clippy::all)]
                                      pub fn send(target_id: Target<'_,>,name: &str,data: &[u8],){
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        unsafe {
                                          let (result3_0,result3_1,result3_2,) = match target_id {
                                            Target::ClientBroadcastUnreliable=> {
                                              (0i32, 0i64, 0i64)
                                            }
                                            Target::ClientBroadcastReliable=> {
                                              (1i32, 0i64, 0i64)
                                            }
                                            Target::ClientTargetedUnreliable(e) => {
                                              let vec0 = e;
                                              let ptr0 = vec0.as_ptr() as i32;
                                              let len0 = vec0.len() as i32;
                                              
                                              (2i32, i64::from(ptr0), i64::from(len0))
                                            },
                                            Target::ClientTargetedReliable(e) => {
                                              let vec1 = e;
                                              let ptr1 = vec1.as_ptr() as i32;
                                              let len1 = vec1.len() as i32;
                                              
                                              (3i32, i64::from(ptr1), i64::from(len1))
                                            },
                                            Target::LocalBroadcast=> {
                                              (4i32, 0i64, 0i64)
                                            }
                                            Target::Local(e) => {
                                              let super::types::EntityId{ id0:id02, id1:id12, } = e;
                                              
                                              (5i32, wit_bindgen::rt::as_i64(id02), wit_bindgen::rt::as_i64(id12))
                                            },
                                          };
                                          let vec4 = name;
                                          let ptr4 = vec4.as_ptr() as i32;
                                          let len4 = vec4.len() as i32;
                                          let vec5 = data;
                                          let ptr5 = vec5.as_ptr() as i32;
                                          let len5 = vec5.len() as i32;
                                          
                                          #[link(wasm_import_module = "server-message")]
                                          extern "C" {
                                            #[cfg_attr(target_arch = "wasm32", link_name = "send")]
                                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "server-message_send")]
                                            fn wit_import(
                                            _: i32, _: i64, _: i64, _: i32, _: i32, _: i32, _: i32, );
                                          }
                                          wit_import(result3_0, result3_1, result3_2, ptr4, len4, ptr5, len5);
                                        }
                                      }
                                      
                                    }
                                    
                                    
                                    #[allow(clippy::all)]
                                    pub mod guest{
                                      #[used]
                                      #[doc(hidden)]
                                      #[cfg(target_arch = "wasm32")]
                                      static __FORCE_SECTION_REF: fn() = super::__link_section;
                                      
                                      pub type EntityId = super::types::EntityId;
                                      #[derive(Clone)]
                                      pub enum Source{
                                        Runtime,
                                        Local(EntityId),
                                        Server,
                                        Client(wit_bindgen::rt::string::String),
                                      }
                                      impl core::fmt::Debug for Source {
                                        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                                          match self {
                                            Source::Runtime => {
                                              f.debug_tuple("Source::Runtime").finish()
                                            }
                                            Source::Local(e) => {
                                              f.debug_tuple("Source::Local").field(e).finish()
                                            }
                                            Source::Server => {
                                              f.debug_tuple("Source::Server").finish()
                                            }
                                            Source::Client(e) => {
                                              f.debug_tuple("Source::Client").field(e).finish()
                                            }
                                          }
                                        }
                                      }
                                      pub trait Guest {
                                        fn init();
                                        fn exec(time: f32,message_source: Source,message_name: wit_bindgen::rt::string::String,message_data: wit_bindgen::rt::vec::Vec::<u8>,);
                                      }
                                      
                                      #[doc(hidden)]
                                      pub unsafe fn call_init<T: Guest>() {
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        
                                        // Before executing any other code, use this function to run all static
                                        // constructors, if they have not yet been run. This is a hack required
                                        // to work around wasi-libc ctors calling import functions to initialize
                                        // the environment.
                                        //
                                        // This functionality will be removed once rust 1.69.0 is stable, at which
                                        // point wasi-libc will no longer have this behavior.
                                        //
                                        // See
                                        // https://github.com/bytecodealliance/preview2-prototyping/issues/99
                                        // for more details.
                                        #[cfg(target_arch="wasm32")]
                                        wit_bindgen::rt::run_ctors_once();
                                        
                                        T::init();
                                      }
                                      
                                      #[doc(hidden)]
                                      pub unsafe fn call_exec<T: Guest>(arg0: f32,arg1: i32,arg2: i64,arg3: i64,arg4: i32,arg5: i32,arg6: i32,arg7: i32,) {
                                        
                                        #[allow(unused_imports)]
                                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                        
                                        // Before executing any other code, use this function to run all static
                                        // constructors, if they have not yet been run. This is a hack required
                                        // to work around wasi-libc ctors calling import functions to initialize
                                        // the environment.
                                        //
                                        // This functionality will be removed once rust 1.69.0 is stable, at which
                                        // point wasi-libc will no longer have this behavior.
                                        //
                                        // See
                                        // https://github.com/bytecodealliance/preview2-prototyping/issues/99
                                        // for more details.
                                        #[cfg(target_arch="wasm32")]
                                        wit_bindgen::rt::run_ctors_once();
                                        
                                        let len1 = arg5 as usize;
                                        let len2 = arg7 as usize;
                                        T::exec(arg0, {{match arg1 {
                                          0 => Source::Runtime,
                                          1 => Source::Local(super::types::EntityId{id0:arg2 as u64, id1:arg3 as u64, }),
                                          2 => Source::Server,
                                          #[cfg(debug_assertions)]3 => Source::Client({
                                            let len0 = arg3 as i32 as usize;
                                            
                                            {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(arg2 as i32 as *mut _, len0, len0))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(arg2 as i32 as *mut _, len0, len0)).unwrap()}}
                                          }),
                                          #[cfg(not(debug_assertions))]_ => Source::Client({
                                            let len0 = arg3 as i32 as usize;
                                            
                                            {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(arg2 as i32 as *mut _, len0, len0))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(arg2 as i32 as *mut _, len0, len0)).unwrap()}}
                                          }),
                                          #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                        }}}, {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(arg4 as *mut _, len1, len1))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(arg4 as *mut _, len1, len1)).unwrap()}}, Vec::from_raw_parts(arg6 as *mut _, len2, len2));
                                      }
                                      
                                    }
                                    
                                    
                                    /// Declares the export of the component's world for the
                                    /// given type.
                                    
                                    macro_rules! export_bindings(($t:ident) => {
                                      const _: () = {
                                        
                                        #[doc(hidden)]
                                        #[export_name = "guest#init"]
                                        #[allow(non_snake_case)]
                                        unsafe extern "C" fn __export_guest_init() {
                                          guest::call_init::<$t>()
                                        }
                                        
                                        #[doc(hidden)]
                                        #[export_name = "guest#exec"]
                                        #[allow(non_snake_case)]
                                        unsafe extern "C" fn __export_guest_exec(arg0: f32,arg1: i32,arg2: i64,arg3: i64,arg4: i32,arg5: i32,arg6: i32,arg7: i32,) {
                                          guest::call_exec::<$t>(arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,)
                                        }
                                        
                                      };
                                      
                                      #[used]
                                      #[doc(hidden)]
                                      #[cfg(target_arch = "wasm32")]
                                      static __FORCE_SECTION_REF: fn() = __link_section;
                                    });
                                    
                                    #[cfg(target_arch = "wasm32")]
                                    #[link_section = "component-type:bindings"]
                                    #[doc(hidden)]pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 35446] = [2, 0, 3, 119, 105, 116, 4, 109, 97, 105, 110, 8, 98, 105, 110, 100, 105, 110, 103, 115, 0, 97, 115, 109, 12, 0, 1, 0, 7, 157, 2, 1, 65, 2, 1, 66, 22, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 111, 2, 119, 119, 4, 4, 117, 108, 105, 100, 0, 3, 0, 12, 1, 114, 2, 6, 111, 114, 105, 103, 105, 110, 3, 3, 100, 105, 114, 3, 4, 3, 114, 97, 121, 0, 3, 0, 14, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 16, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 18, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 20, 4, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 11, 21, 1, 5, 116, 121, 112, 101, 115, 10, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 3, 0, 0, 7, 250, 3, 1, 65, 7, 1, 66, 22, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 111, 2, 119, 119, 4, 4, 117, 108, 105, 100, 0, 3, 0, 12, 1, 114, 2, 6, 111, 114, 105, 103, 105, 110, 3, 3, 100, 105, 114, 3, 4, 3, 114, 97, 121, 0, 3, 0, 14, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 16, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 18, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 20, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 2, 3, 0, 0, 4, 118, 101, 99, 51, 2, 3, 0, 0, 4, 113, 117, 97, 116, 1, 66, 11, 2, 3, 2, 1, 1, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 2, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 2, 3, 2, 1, 3, 4, 4, 113, 117, 97, 116, 0, 3, 0, 4, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 1, 0, 4, 12, 115, 101, 116, 45, 108, 105, 115, 116, 101, 110, 101, 114, 0, 1, 6, 4, 11, 115, 101, 116, 45, 101, 109, 105, 116, 116, 101, 114, 0, 1, 6, 1, 64, 2, 5, 115, 111, 117, 110, 100, 115, 7, 101, 109, 105, 116, 116, 101, 114, 1, 1, 0, 4, 20, 112, 108, 97, 121, 45, 115, 111, 117, 110, 100, 45, 111, 110, 45, 101, 110, 116, 105, 116, 121, 0, 1, 7, 4, 11, 119, 111, 114, 108, 100, 45, 97, 117, 100, 105, 111, 28, 112, 107, 103, 58, 47, 119, 111, 114, 108, 100, 45, 97, 117, 100, 105, 111, 47, 119, 111, 114, 108, 100, 45, 97, 117, 100, 105, 111, 5, 4, 11, 33, 1, 11, 119, 111, 114, 108, 100, 45, 97, 117, 100, 105, 111, 16, 112, 107, 103, 58, 47, 119, 111, 114, 108, 100, 45, 97, 117, 100, 105, 111, 3, 2, 0, 7, 190, 9, 1, 65, 7, 1, 66, 22, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 111, 2, 119, 119, 4, 4, 117, 108, 105, 100, 0, 3, 0, 12, 1, 114, 2, 6, 111, 114, 105, 103, 105, 110, 3, 3, 100, 105, 114, 3, 4, 3, 114, 97, 121, 0, 3, 0, 14, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 16, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 18, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 20, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 2, 3, 0, 0, 4, 118, 101, 99, 51, 2, 3, 0, 0, 4, 109, 97, 116, 52, 1, 66, 43, 2, 3, 2, 1, 1, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 2, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 2, 3, 2, 1, 3, 4, 4, 109, 97, 116, 52, 0, 3, 0, 4, 1, 114, 3, 4, 115, 105, 100, 101, 127, 2, 117, 112, 127, 4, 100, 111, 119, 110, 127, 4, 19, 99, 104, 97, 114, 97, 99, 116, 101, 114, 45, 99, 111, 108, 108, 105, 115, 105, 111, 110, 0, 3, 0, 6, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 102, 111, 114, 99, 101, 3, 1, 0, 4, 9, 97, 100, 100, 45, 102, 111, 114, 99, 101, 0, 1, 8, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 109, 112, 117, 108, 115, 101, 3, 1, 0, 4, 11, 97, 100, 100, 45, 105, 109, 112, 117, 108, 115, 101, 0, 1, 9, 1, 107, 118, 1, 64, 4, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 7, 105, 109, 112, 117, 108, 115, 101, 118, 6, 114, 97, 100, 105, 117, 115, 118, 14, 102, 97, 108, 108, 111, 102, 102, 45, 114, 97, 100, 105, 117, 115, 10, 1, 0, 4, 18, 97, 100, 100, 45, 114, 97, 100, 105, 97, 108, 45, 105, 109, 112, 117, 108, 115, 101, 0, 1, 11, 1, 64, 3, 6, 101, 110, 116, 105, 116, 121, 1, 5, 102, 111, 114, 99, 101, 3, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 1, 0, 4, 21, 97, 100, 100, 45, 102, 111, 114, 99, 101, 45, 97, 116, 45, 112, 111, 115, 105, 116, 105, 111, 110, 0, 1, 12, 1, 64, 3, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 109, 112, 117, 108, 115, 101, 3, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 1, 0, 4, 23, 97, 100, 100, 45, 105, 109, 112, 117, 108, 115, 101, 45, 97, 116, 45, 112, 111, 115, 105, 116, 105, 111, 110, 0, 1, 13, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 0, 3, 4, 24, 103, 101, 116, 45, 118, 101, 108, 111, 99, 105, 116, 121, 45, 97, 116, 45, 112, 111, 115, 105, 116, 105, 111, 110, 0, 1, 14, 1, 64, 1, 7, 103, 114, 97, 118, 105, 116, 121, 3, 1, 0, 4, 11, 115, 101, 116, 45, 103, 114, 97, 118, 105, 116, 121, 0, 1, 15, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 1, 0, 4, 8, 117, 110, 102, 114, 101, 101, 122, 101, 0, 1, 16, 4, 6, 102, 114, 101, 101, 122, 101, 0, 1, 16, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 8, 118, 101, 108, 111, 99, 105, 116, 121, 118, 1, 0, 4, 11, 115, 116, 97, 114, 116, 45, 109, 111, 116, 111, 114, 0, 1, 17, 4, 10, 115, 116, 111, 112, 45, 109, 111, 116, 111, 114, 0, 1, 16, 1, 64, 4, 6, 97, 99, 116, 111, 114, 48, 1, 10, 116, 114, 97, 110, 115, 102, 111, 114, 109, 48, 5, 6, 97, 99, 116, 111, 114, 49, 1, 10, 116, 114, 97, 110, 115, 102, 111, 114, 109, 49, 5, 1, 0, 4, 21, 99, 114, 101, 97, 116, 101, 45, 114, 101, 118, 111, 108, 117, 116, 101, 45, 106, 111, 105, 110, 116, 0, 1, 18, 1, 111, 2, 1, 118, 1, 107, 19, 1, 64, 2, 6, 111, 114, 105, 103, 105, 110, 3, 9, 100, 105, 114, 101, 99, 116, 105, 111, 110, 3, 0, 20, 4, 13, 114, 97, 121, 99, 97, 115, 116, 45, 102, 105, 114, 115, 116, 0, 1, 21, 1, 112, 19, 1, 64, 2, 6, 111, 114, 105, 103, 105, 110, 3, 9, 100, 105, 114, 101, 99, 116, 105, 111, 110, 3, 0, 22, 4, 7, 114, 97, 121, 99, 97, 115, 116, 0, 1, 23, 1, 64, 4, 6, 101, 110, 116, 105, 116, 121, 1, 12, 100, 105, 115, 112, 108, 97, 99, 101, 109, 101, 110, 116, 3, 8, 109, 105, 110, 45, 100, 105, 115, 116, 118, 12, 101, 108, 97, 112, 115, 101, 100, 45, 116, 105, 109, 101, 118, 0, 7, 4, 14, 109, 111, 118, 101, 45, 99, 104, 97, 114, 97, 99, 116, 101, 114, 0, 1, 24, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 1, 0, 4, 22, 115, 101, 116, 45, 99, 104, 97, 114, 97, 99, 116, 101, 114, 45, 112, 111, 115, 105, 116, 105, 111, 110, 0, 1, 25, 4, 27, 115, 101, 116, 45, 99, 104, 97, 114, 97, 99, 116, 101, 114, 45, 102, 111, 111, 116, 45, 112, 111, 115, 105, 116, 105, 111, 110, 0, 1, 25, 4, 14, 115, 101, 114, 118, 101, 114, 45, 112, 104, 121, 115, 105, 99, 115, 34, 112, 107, 103, 58, 47, 115, 101, 114, 118, 101, 114, 45, 112, 104, 121, 115, 105, 99, 115, 47, 115, 101, 114, 118, 101, 114, 45, 112, 104, 121, 115, 105, 99, 115, 5, 4, 11, 39, 1, 14, 115, 101, 114, 118, 101, 114, 45, 112, 104, 121, 115, 105, 99, 115, 19, 112, 107, 103, 58, 47, 115, 101, 114, 118, 101, 114, 45, 112, 104, 121, 115, 105, 99, 115, 3, 4, 0, 7, 189, 4, 1, 65, 5, 1, 66, 22, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 111, 2, 119, 119, 4, 4, 117, 108, 105, 100, 0, 3, 0, 12, 1, 114, 2, 6, 111, 114, 105, 103, 105, 110, 3, 3, 100, 105, 114, 3, 4, 3, 114, 97, 121, 0, 3, 0, 14, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 16, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 18, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 20, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 66, 7, 2, 3, 2, 1, 1, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 1, 113, 6, 27, 99, 108, 105, 101, 110, 116, 45, 98, 114, 111, 97, 100, 99, 97, 115, 116, 45, 117, 110, 114, 101, 108, 105, 97, 98, 108, 101, 0, 0, 25, 99, 108, 105, 101, 110, 116, 45, 98, 114, 111, 97, 100, 99, 97, 115, 116, 45, 114, 101, 108, 105, 97, 98, 108, 101, 0, 0, 26, 99, 108, 105, 101, 110, 116, 45, 116, 97, 114, 103, 101, 116, 101, 100, 45, 117, 110, 114, 101, 108, 105, 97, 98, 108, 101, 1, 115, 0, 24, 99, 108, 105, 101, 110, 116, 45, 116, 97, 114, 103, 101, 116, 101, 100, 45, 114, 101, 108, 105, 97, 98, 108, 101, 1, 115, 0, 15, 108, 111, 99, 97, 108, 45, 98, 114, 111, 97, 100, 99, 97, 115, 116, 0, 0, 5, 108, 111, 99, 97, 108, 1, 1, 0, 4, 6, 116, 97, 114, 103, 101, 116, 0, 3, 0, 2, 1, 112, 125, 1, 64, 3, 9, 116, 97, 114, 103, 101, 116, 45, 105, 100, 3, 4, 110, 97, 109, 101, 115, 4, 100, 97, 116, 97, 4, 1, 0, 4, 4, 115, 101, 110, 100, 0, 1, 5, 4, 14, 115, 101, 114, 118, 101, 114, 45, 109, 101, 115, 115, 97, 103, 101, 34, 112, 107, 103, 58, 47, 115, 101, 114, 118, 101, 114, 45, 109, 101, 115, 115, 97, 103, 101, 47, 115, 101, 114, 118, 101, 114, 45, 109, 101, 115, 115, 97, 103, 101, 5, 2, 11, 39, 1, 14, 115, 101, 114, 118, 101, 114, 45, 109, 101, 115, 115, 97, 103, 101, 19, 112, 107, 103, 58, 47, 115, 101, 114, 118, 101, 114, 45, 109, 101, 115, 115, 97, 103, 101, 3, 6, 0, 7, 75, 1, 65, 2, 1, 66, 3, 1, 107, 115, 1, 64, 1, 4, 112, 97, 116, 104, 115, 0, 0, 4, 3, 117, 114, 108, 0, 1, 1, 4, 12, 115, 101, 114, 118, 101, 114, 45, 97, 115, 115, 101, 116, 30, 112, 107, 103, 58, 47, 115, 101, 114, 118, 101, 114, 45, 97, 115, 115, 101, 116, 47, 115, 101, 114, 118, 101, 114, 45, 97, 115, 115, 101, 116, 5, 0, 11, 35, 1, 12, 115, 101, 114, 118, 101, 114, 45, 97, 115, 115, 101, 116, 17, 112, 107, 103, 58, 47, 115, 101, 114, 118, 101, 114, 45, 97, 115, 115, 101, 116, 3, 8, 0, 7, 131, 3, 1, 65, 5, 1, 66, 22, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 111, 2, 119, 119, 4, 4, 117, 108, 105, 100, 0, 3, 0, 12, 1, 114, 2, 6, 111, 114, 105, 103, 105, 110, 3, 3, 100, 105, 114, 3, 4, 3, 114, 97, 121, 0, 3, 0, 14, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 16, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 18, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 20, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 66, 5, 2, 3, 2, 1, 1, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 1, 107, 1, 1, 64, 1, 7, 117, 115, 101, 114, 45, 105, 100, 115, 0, 2, 4, 14, 103, 101, 116, 45, 98, 121, 45, 117, 115, 101, 114, 45, 105, 100, 0, 1, 3, 4, 6, 112, 108, 97, 121, 101, 114, 18, 112, 107, 103, 58, 47, 112, 108, 97, 121, 101, 114, 47, 112, 108, 97, 121, 101, 114, 5, 2, 11, 23, 1, 6, 112, 108, 97, 121, 101, 114, 11, 112, 107, 103, 58, 47, 112, 108, 97, 121, 101, 114, 3, 10, 0, 7, 226, 3, 1, 65, 5, 1, 66, 22, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 111, 2, 119, 119, 4, 4, 117, 108, 105, 100, 0, 3, 0, 12, 1, 114, 2, 6, 111, 114, 105, 103, 105, 110, 3, 3, 100, 105, 114, 3, 4, 3, 114, 97, 121, 0, 3, 0, 14, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 16, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 18, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 20, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 66, 9, 2, 3, 2, 1, 1, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 1, 113, 4, 7, 114, 117, 110, 116, 105, 109, 101, 0, 0, 5, 108, 111, 99, 97, 108, 1, 1, 0, 6, 115, 101, 114, 118, 101, 114, 0, 0, 6, 99, 108, 105, 101, 110, 116, 1, 115, 0, 4, 6, 115, 111, 117, 114, 99, 101, 0, 3, 0, 2, 1, 64, 0, 1, 0, 4, 4, 105, 110, 105, 116, 0, 1, 4, 1, 112, 125, 1, 64, 4, 4, 116, 105, 109, 101, 118, 14, 109, 101, 115, 115, 97, 103, 101, 45, 115, 111, 117, 114, 99, 101, 3, 12, 109, 101, 115, 115, 97, 103, 101, 45, 110, 97, 109, 101, 115, 12, 109, 101, 115, 115, 97, 103, 101, 45, 100, 97, 116, 97, 5, 1, 0, 4, 4, 101, 120, 101, 99, 0, 1, 6, 4, 5, 103, 117, 101, 115, 116, 16, 112, 107, 103, 58, 47, 103, 117, 101, 115, 116, 47, 103, 117, 101, 115, 116, 5, 2, 11, 21, 1, 5, 103, 117, 101, 115, 116, 10, 112, 107, 103, 58, 47, 103, 117, 101, 115, 116, 3, 12, 0, 7, 92, 1, 65, 2, 1, 66, 2, 1, 64, 1, 10, 102, 117, 108, 108, 115, 99, 114, 101, 101, 110, 127, 1, 0, 4, 14, 115, 101, 116, 45, 102, 117, 108, 108, 115, 99, 114, 101, 101, 110, 0, 1, 0, 4, 13, 99, 108, 105, 101, 110, 116, 45, 119, 105, 110, 100, 111, 119, 32, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 119, 105, 110, 100, 111, 119, 47, 99, 108, 105, 101, 110, 116, 45, 119, 105, 110, 100, 111, 119, 5, 0, 11, 37, 1, 13, 99, 108, 105, 101, 110, 116, 45, 119, 105, 110, 100, 111, 119, 18, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 119, 105, 110, 100, 111, 119, 3, 14, 0, 7, 157, 8, 1, 65, 5, 1, 66, 22, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 111, 2, 119, 119, 4, 4, 117, 108, 105, 100, 0, 3, 0, 12, 1, 114, 2, 6, 111, 114, 105, 103, 105, 110, 3, 3, 100, 105, 114, 3, 4, 3, 114, 97, 121, 0, 3, 0, 14, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 16, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 18, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 20, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 4, 117, 108, 105, 100, 1, 66, 13, 2, 3, 2, 1, 1, 4, 4, 117, 108, 105, 100, 0, 3, 0, 0, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 6, 104, 97, 110, 100, 108, 101, 0, 3, 0, 2, 1, 113, 42, 8, 114, 56, 45, 117, 110, 111, 114, 109, 0, 0, 8, 114, 56, 45, 115, 110, 111, 114, 109, 0, 0, 7, 114, 56, 45, 117, 105, 110, 116, 0, 0, 7, 114, 56, 45, 115, 105, 110, 116, 0, 0, 8, 114, 49, 54, 45, 117, 105, 110, 116, 0, 0, 8, 114, 49, 54, 45, 115, 105, 110, 116, 0, 0, 9, 114, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 9, 114, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 9, 114, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 56, 45, 117, 110, 111, 114, 109, 0, 0, 9, 114, 103, 56, 45, 115, 110, 111, 114, 109, 0, 0, 8, 114, 103, 56, 45, 117, 105, 110, 116, 0, 0, 8, 114, 103, 56, 45, 115, 105, 110, 116, 0, 0, 8, 114, 51, 50, 45, 117, 105, 110, 116, 0, 0, 8, 114, 51, 50, 45, 115, 105, 110, 116, 0, 0, 9, 114, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 49, 54, 45, 117, 105, 110, 116, 0, 0, 9, 114, 103, 49, 54, 45, 115, 105, 110, 116, 0, 0, 10, 114, 103, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 10, 114, 103, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 10, 114, 103, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 56, 45, 117, 110, 111, 114, 109, 0, 0, 16, 114, 103, 98, 97, 56, 45, 117, 110, 111, 114, 109, 45, 115, 114, 103, 98, 0, 0, 11, 114, 103, 98, 97, 56, 45, 115, 110, 111, 114, 109, 0, 0, 10, 114, 103, 98, 97, 56, 45, 117, 105, 110, 116, 0, 0, 10, 114, 103, 98, 97, 56, 45, 115, 105, 110, 116, 0, 0, 11, 98, 103, 114, 97, 56, 45, 117, 110, 111, 114, 109, 0, 0, 16, 98, 103, 114, 97, 56, 45, 117, 110, 111, 114, 109, 45, 115, 114, 103, 98, 0, 0, 13, 114, 103, 98, 57, 101, 53, 45, 117, 102, 108, 111, 97, 116, 0, 0, 13, 114, 103, 98, 49, 48, 97, 50, 45, 117, 110, 111, 114, 109, 0, 0, 13, 114, 103, 49, 49, 98, 49, 48, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 51, 50, 45, 117, 105, 110, 116, 0, 0, 9, 114, 103, 51, 50, 45, 115, 105, 110, 116, 0, 0, 10, 114, 103, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 49, 54, 45, 117, 105, 110, 116, 0, 0, 11, 114, 103, 98, 97, 49, 54, 45, 115, 105, 110, 116, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 51, 50, 45, 117, 105, 110, 116, 0, 0, 11, 114, 103, 98, 97, 51, 50, 45, 115, 105, 110, 116, 0, 0, 12, 114, 103, 98, 97, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 4, 6, 102, 111, 114, 109, 97, 116, 0, 3, 0, 4, 1, 112, 125, 1, 114, 4, 5, 119, 105, 100, 116, 104, 121, 6, 104, 101, 105, 103, 104, 116, 121, 6, 102, 111, 114, 109, 97, 116, 5, 4, 100, 97, 116, 97, 6, 4, 12, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 50, 100, 0, 3, 0, 7, 1, 64, 1, 4, 100, 101, 115, 99, 8, 0, 3, 4, 8, 99, 114, 101, 97, 116, 101, 50, 100, 0, 1, 9, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 3, 1, 0, 4, 7, 100, 101, 115, 116, 114, 111, 121, 0, 1, 10, 4, 14, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 34, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 47, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 5, 2, 11, 39, 1, 14, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 19, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 3, 16, 0, 7, 128, 5, 1, 65, 5, 1, 66, 22, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 111, 2, 119, 119, 4, 4, 117, 108, 105, 100, 0, 3, 0, 12, 1, 114, 2, 6, 111, 114, 105, 103, 105, 110, 3, 3, 100, 105, 114, 3, 4, 3, 114, 97, 121, 0, 3, 0, 14, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 16, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 18, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 20, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 4, 117, 108, 105, 100, 1, 66, 14, 2, 3, 2, 1, 1, 4, 4, 117, 108, 105, 100, 0, 3, 0, 0, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 6, 104, 97, 110, 100, 108, 101, 0, 3, 0, 2, 1, 113, 2, 7, 110, 101, 97, 114, 101, 115, 116, 0, 0, 6, 108, 105, 110, 101, 97, 114, 0, 0, 4, 11, 102, 105, 108, 116, 101, 114, 45, 109, 111, 100, 101, 0, 3, 0, 4, 1, 113, 3, 13, 99, 108, 97, 109, 112, 45, 116, 111, 45, 101, 100, 103, 101, 0, 0, 6, 114, 101, 112, 101, 97, 116, 0, 0, 13, 109, 105, 114, 114, 111, 114, 45, 114, 101, 112, 101, 97, 116, 0, 0, 4, 12, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 0, 3, 0, 6, 1, 114, 6, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 117, 7, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 118, 7, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 119, 7, 10, 109, 97, 103, 45, 102, 105, 108, 116, 101, 114, 5, 10, 109, 105, 110, 45, 102, 105, 108, 116, 101, 114, 5, 13, 109, 105, 112, 109, 97, 112, 45, 102, 105, 108, 116, 101, 114, 5, 4, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 0, 3, 0, 8, 1, 64, 1, 4, 100, 101, 115, 99, 9, 0, 3, 4, 6, 99, 114, 101, 97, 116, 101, 0, 1, 10, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 3, 1, 0, 4, 7, 100, 101, 115, 116, 114, 111, 121, 0, 1, 11, 4, 14, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 34, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 47, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 5, 2, 11, 39, 1, 14, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 19, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 3, 18, 0, 7, 135, 3, 1, 65, 5, 1, 66, 22, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 111, 2, 119, 119, 4, 4, 117, 108, 105, 100, 0, 3, 0, 12, 1, 114, 2, 6, 111, 114, 105, 103, 105, 110, 3, 3, 100, 105, 114, 3, 4, 3, 114, 97, 121, 0, 3, 0, 14, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 16, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 18, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 20, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 66, 4, 2, 3, 2, 1, 1, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 1, 64, 0, 0, 1, 4, 9, 103, 101, 116, 45, 108, 111, 99, 97, 108, 0, 1, 2, 4, 13, 99, 108, 105, 101, 110, 116, 45, 112, 108, 97, 121, 101, 114, 32, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 112, 108, 97, 121, 101, 114, 47, 99, 108, 105, 101, 110, 116, 45, 112, 108, 97, 121, 101, 114, 5, 2, 11, 37, 1, 13, 99, 108, 105, 101, 110, 116, 45, 112, 108, 97, 121, 101, 114, 18, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 112, 108, 97, 121, 101, 114, 3, 20, 0, 7, 239, 3, 1, 65, 5, 1, 66, 22, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 111, 2, 119, 119, 4, 4, 117, 108, 105, 100, 0, 3, 0, 12, 1, 114, 2, 6, 111, 114, 105, 103, 105, 110, 3, 3, 100, 105, 114, 3, 4, 3, 114, 97, 121, 0, 3, 0, 14, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 16, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 18, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 20, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 66, 7, 2, 3, 2, 1, 1, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 1, 113, 4, 17, 115, 101, 114, 118, 101, 114, 45, 117, 110, 114, 101, 108, 105, 97, 98, 108, 101, 0, 0, 15, 115, 101, 114, 118, 101, 114, 45, 114, 101, 108, 105, 97, 98, 108, 101, 0, 0, 15, 108, 111, 99, 97, 108, 45, 98, 114, 111, 97, 100, 99, 97, 115, 116, 0, 0, 5, 108, 111, 99, 97, 108, 1, 1, 0, 4, 6, 116, 97, 114, 103, 101, 116, 0, 3, 0, 2, 1, 112, 125, 1, 64, 3, 9, 116, 97, 114, 103, 101, 116, 45, 105, 100, 3, 4, 110, 97, 109, 101, 115, 4, 100, 97, 116, 97, 4, 1, 0, 4, 4, 115, 101, 110, 100, 0, 1, 5, 4, 14, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 115, 97, 103, 101, 34, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 115, 97, 103, 101, 47, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 115, 97, 103, 101, 5, 2, 11, 39, 1, 14, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 115, 97, 103, 101, 19, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 115, 97, 103, 101, 3, 22, 0, 7, 185, 4, 1, 65, 7, 1, 66, 22, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 111, 2, 119, 119, 4, 4, 117, 108, 105, 100, 0, 3, 0, 12, 1, 114, 2, 6, 111, 114, 105, 103, 105, 110, 3, 3, 100, 105, 114, 3, 4, 3, 114, 97, 121, 0, 3, 0, 14, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 16, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 18, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 20, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 4, 118, 101, 99, 50, 2, 3, 0, 0, 4, 118, 101, 99, 51, 2, 3, 0, 0, 4, 117, 108, 105, 100, 1, 66, 18, 2, 3, 2, 1, 1, 4, 4, 118, 101, 99, 50, 0, 3, 0, 0, 2, 3, 2, 1, 2, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 2, 3, 2, 1, 3, 4, 4, 117, 108, 105, 100, 0, 3, 0, 4, 1, 114, 4, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 6, 110, 111, 114, 109, 97, 108, 3, 7, 116, 97, 110, 103, 101, 110, 116, 3, 9, 116, 101, 120, 99, 111, 111, 114, 100, 48, 1, 4, 6, 118, 101, 114, 116, 101, 120, 0, 3, 0, 6, 1, 114, 1, 4, 117, 108, 105, 100, 5, 4, 6, 104, 97, 110, 100, 108, 101, 0, 3, 0, 8, 1, 112, 7, 1, 112, 121, 1, 114, 2, 8, 118, 101, 114, 116, 105, 99, 101, 115, 10, 7, 105, 110, 100, 105, 99, 101, 115, 11, 4, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 0, 3, 0, 12, 1, 64, 1, 4, 100, 101, 115, 99, 13, 0, 9, 4, 6, 99, 114, 101, 97, 116, 101, 0, 1, 14, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 9, 1, 0, 4, 7, 100, 101, 115, 116, 114, 111, 121, 0, 1, 15, 4, 11, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 104, 28, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 104, 47, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 104, 5, 4, 11, 33, 1, 11, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 104, 16, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 104, 3, 24, 0, 7, 202, 12, 1, 65, 11, 1, 66, 22, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 111, 2, 119, 119, 4, 4, 117, 108, 105, 100, 0, 3, 0, 12, 1, 114, 2, 6, 111, 114, 105, 103, 105, 110, 3, 3, 100, 105, 114, 3, 4, 3, 114, 97, 121, 0, 3, 0, 14, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 16, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 18, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 20, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 4, 117, 108, 105, 100, 1, 66, 9, 2, 3, 2, 1, 1, 4, 4, 117, 108, 105, 100, 0, 3, 0, 0, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 6, 104, 97, 110, 100, 108, 101, 0, 3, 0, 2, 1, 113, 42, 8, 114, 56, 45, 117, 110, 111, 114, 109, 0, 0, 8, 114, 56, 45, 115, 110, 111, 114, 109, 0, 0, 7, 114, 56, 45, 117, 105, 110, 116, 0, 0, 7, 114, 56, 45, 115, 105, 110, 116, 0, 0, 8, 114, 49, 54, 45, 117, 105, 110, 116, 0, 0, 8, 114, 49, 54, 45, 115, 105, 110, 116, 0, 0, 9, 114, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 9, 114, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 9, 114, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 56, 45, 117, 110, 111, 114, 109, 0, 0, 9, 114, 103, 56, 45, 115, 110, 111, 114, 109, 0, 0, 8, 114, 103, 56, 45, 117, 105, 110, 116, 0, 0, 8, 114, 103, 56, 45, 115, 105, 110, 116, 0, 0, 8, 114, 51, 50, 45, 117, 105, 110, 116, 0, 0, 8, 114, 51, 50, 45, 115, 105, 110, 116, 0, 0, 9, 114, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 49, 54, 45, 117, 105, 110, 116, 0, 0, 9, 114, 103, 49, 54, 45, 115, 105, 110, 116, 0, 0, 10, 114, 103, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 10, 114, 103, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 10, 114, 103, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 56, 45, 117, 110, 111, 114, 109, 0, 0, 16, 114, 103, 98, 97, 56, 45, 117, 110, 111, 114, 109, 45, 115, 114, 103, 98, 0, 0, 11, 114, 103, 98, 97, 56, 45, 115, 110, 111, 114, 109, 0, 0, 10, 114, 103, 98, 97, 56, 45, 117, 105, 110, 116, 0, 0, 10, 114, 103, 98, 97, 56, 45, 115, 105, 110, 116, 0, 0, 11, 98, 103, 114, 97, 56, 45, 117, 110, 111, 114, 109, 0, 0, 16, 98, 103, 114, 97, 56, 45, 117, 110, 111, 114, 109, 45, 115, 114, 103, 98, 0, 0, 13, 114, 103, 98, 57, 101, 53, 45, 117, 102, 108, 111, 97, 116, 0, 0, 13, 114, 103, 98, 49, 48, 97, 50, 45, 117, 110, 111, 114, 109, 0, 0, 13, 114, 103, 49, 49, 98, 49, 48, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 51, 50, 45, 117, 105, 110, 116, 0, 0, 9, 114, 103, 51, 50, 45, 115, 105, 110, 116, 0, 0, 10, 114, 103, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 49, 54, 45, 117, 105, 110, 116, 0, 0, 11, 114, 103, 98, 97, 49, 54, 45, 115, 105, 110, 116, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 51, 50, 45, 117, 105, 110, 116, 0, 0, 11, 114, 103, 98, 97, 51, 50, 45, 115, 105, 110, 116, 0, 0, 12, 114, 103, 98, 97, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 4, 6, 102, 111, 114, 109, 97, 116, 0, 3, 0, 4, 1, 112, 125, 1, 114, 4, 5, 119, 105, 100, 116, 104, 121, 6, 104, 101, 105, 103, 104, 116, 121, 6, 102, 111, 114, 109, 97, 116, 5, 4, 100, 97, 116, 97, 6, 4, 12, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 50, 100, 0, 3, 0, 7, 3, 14, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 34, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 47, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 5, 2, 1, 66, 10, 2, 3, 2, 1, 1, 4, 4, 117, 108, 105, 100, 0, 3, 0, 0, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 6, 104, 97, 110, 100, 108, 101, 0, 3, 0, 2, 1, 113, 2, 7, 110, 101, 97, 114, 101, 115, 116, 0, 0, 6, 108, 105, 110, 101, 97, 114, 0, 0, 4, 11, 102, 105, 108, 116, 101, 114, 45, 109, 111, 100, 101, 0, 3, 0, 4, 1, 113, 3, 13, 99, 108, 97, 109, 112, 45, 116, 111, 45, 101, 100, 103, 101, 0, 0, 6, 114, 101, 112, 101, 97, 116, 0, 0, 13, 109, 105, 114, 114, 111, 114, 45, 114, 101, 112, 101, 97, 116, 0, 0, 4, 12, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 0, 3, 0, 6, 1, 114, 6, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 117, 7, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 118, 7, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 119, 7, 10, 109, 97, 103, 45, 102, 105, 108, 116, 101, 114, 5, 10, 109, 105, 110, 45, 102, 105, 108, 116, 101, 114, 5, 13, 109, 105, 112, 109, 97, 112, 45, 102, 105, 108, 116, 101, 114, 5, 4, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 0, 3, 0, 8, 3, 14, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 34, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 47, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 5, 3, 2, 3, 0, 1, 6, 104, 97, 110, 100, 108, 101, 2, 3, 0, 2, 6, 104, 97, 110, 100, 108, 101, 1, 66, 14, 2, 3, 2, 1, 1, 4, 4, 117, 108, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 4, 4, 14, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 2, 2, 3, 2, 1, 5, 4, 14, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 4, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 6, 104, 97, 110, 100, 108, 101, 0, 3, 0, 6, 1, 114, 5, 14, 98, 97, 115, 101, 45, 99, 111, 108, 111, 114, 45, 109, 97, 112, 3, 10, 110, 111, 114, 109, 97, 108, 45, 109, 97, 112, 3, 22, 109, 101, 116, 97, 108, 108, 105, 99, 45, 114, 111, 117, 103, 104, 110, 101, 115, 115, 45, 109, 97, 112, 3, 7, 115, 97, 109, 112, 108, 101, 114, 5, 11, 116, 114, 97, 110, 115, 112, 97, 114, 101, 110, 116, 127, 4, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 0, 3, 0, 8, 1, 64, 1, 4, 100, 101, 115, 99, 9, 0, 7, 4, 6, 99, 114, 101, 97, 116, 101, 0, 1, 10, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 7, 1, 0, 4, 7, 100, 101, 115, 116, 114, 111, 121, 0, 1, 11, 4, 15, 99, 108, 105, 101, 110, 116, 45, 109, 97, 116, 101, 114, 105, 97, 108, 36, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 109, 97, 116, 101, 114, 105, 97, 108, 47, 99, 108, 105, 101, 110, 116, 45, 109, 97, 116, 101, 114, 105, 97, 108, 5, 6, 11, 41, 1, 15, 99, 108, 105, 101, 110, 116, 45, 109, 97, 116, 101, 114, 105, 97, 108, 20, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 109, 97, 116, 101, 114, 105, 97, 108, 3, 26, 0, 7, 248, 31, 1, 65, 26, 1, 66, 22, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 111, 2, 119, 119, 4, 4, 117, 108, 105, 100, 0, 3, 0, 12, 1, 114, 2, 6, 111, 114, 105, 103, 105, 110, 3, 3, 100, 105, 114, 3, 4, 3, 114, 97, 121, 0, 3, 0, 14, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 16, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 18, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 20, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 4, 118, 101, 99, 50, 2, 3, 0, 0, 4, 118, 101, 99, 51, 2, 3, 0, 0, 4, 117, 108, 105, 100, 1, 66, 14, 2, 3, 2, 1, 1, 4, 4, 118, 101, 99, 50, 0, 3, 0, 0, 2, 3, 2, 1, 2, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 2, 3, 2, 1, 3, 4, 4, 117, 108, 105, 100, 0, 3, 0, 4, 1, 114, 4, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 6, 110, 111, 114, 109, 97, 108, 3, 7, 116, 97, 110, 103, 101, 110, 116, 3, 9, 116, 101, 120, 99, 111, 111, 114, 100, 48, 1, 4, 6, 118, 101, 114, 116, 101, 120, 0, 3, 0, 6, 1, 114, 1, 4, 117, 108, 105, 100, 5, 4, 6, 104, 97, 110, 100, 108, 101, 0, 3, 0, 8, 1, 112, 7, 1, 112, 121, 1, 114, 2, 8, 118, 101, 114, 116, 105, 99, 101, 115, 10, 7, 105, 110, 100, 105, 99, 101, 115, 11, 4, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 0, 3, 0, 12, 3, 11, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 104, 28, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 104, 47, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 104, 5, 4, 1, 66, 9, 2, 3, 2, 1, 3, 4, 4, 117, 108, 105, 100, 0, 3, 0, 0, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 6, 104, 97, 110, 100, 108, 101, 0, 3, 0, 2, 1, 113, 42, 8, 114, 56, 45, 117, 110, 111, 114, 109, 0, 0, 8, 114, 56, 45, 115, 110, 111, 114, 109, 0, 0, 7, 114, 56, 45, 117, 105, 110, 116, 0, 0, 7, 114, 56, 45, 115, 105, 110, 116, 0, 0, 8, 114, 49, 54, 45, 117, 105, 110, 116, 0, 0, 8, 114, 49, 54, 45, 115, 105, 110, 116, 0, 0, 9, 114, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 9, 114, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 9, 114, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 56, 45, 117, 110, 111, 114, 109, 0, 0, 9, 114, 103, 56, 45, 115, 110, 111, 114, 109, 0, 0, 8, 114, 103, 56, 45, 117, 105, 110, 116, 0, 0, 8, 114, 103, 56, 45, 115, 105, 110, 116, 0, 0, 8, 114, 51, 50, 45, 117, 105, 110, 116, 0, 0, 8, 114, 51, 50, 45, 115, 105, 110, 116, 0, 0, 9, 114, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 49, 54, 45, 117, 105, 110, 116, 0, 0, 9, 114, 103, 49, 54, 45, 115, 105, 110, 116, 0, 0, 10, 114, 103, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 10, 114, 103, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 10, 114, 103, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 56, 45, 117, 110, 111, 114, 109, 0, 0, 16, 114, 103, 98, 97, 56, 45, 117, 110, 111, 114, 109, 45, 115, 114, 103, 98, 0, 0, 11, 114, 103, 98, 97, 56, 45, 115, 110, 111, 114, 109, 0, 0, 10, 114, 103, 98, 97, 56, 45, 117, 105, 110, 116, 0, 0, 10, 114, 103, 98, 97, 56, 45, 115, 105, 110, 116, 0, 0, 11, 98, 103, 114, 97, 56, 45, 117, 110, 111, 114, 109, 0, 0, 16, 98, 103, 114, 97, 56, 45, 117, 110, 111, 114, 109, 45, 115, 114, 103, 98, 0, 0, 13, 114, 103, 98, 57, 101, 53, 45, 117, 102, 108, 111, 97, 116, 0, 0, 13, 114, 103, 98, 49, 48, 97, 50, 45, 117, 110, 111, 114, 109, 0, 0, 13, 114, 103, 49, 49, 98, 49, 48, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 51, 50, 45, 117, 105, 110, 116, 0, 0, 9, 114, 103, 51, 50, 45, 115, 105, 110, 116, 0, 0, 10, 114, 103, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 49, 54, 45, 117, 105, 110, 116, 0, 0, 11, 114, 103, 98, 97, 49, 54, 45, 115, 105, 110, 116, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 51, 50, 45, 117, 105, 110, 116, 0, 0, 11, 114, 103, 98, 97, 51, 50, 45, 115, 105, 110, 116, 0, 0, 12, 114, 103, 98, 97, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 4, 6, 102, 111, 114, 109, 97, 116, 0, 3, 0, 4, 1, 112, 125, 1, 114, 4, 5, 119, 105, 100, 116, 104, 121, 6, 104, 101, 105, 103, 104, 116, 121, 6, 102, 111, 114, 109, 97, 116, 5, 4, 100, 97, 116, 97, 6, 4, 12, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 50, 100, 0, 3, 0, 7, 3, 14, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 34, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 47, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 5, 5, 1, 66, 10, 2, 3, 2, 1, 3, 4, 4, 117, 108, 105, 100, 0, 3, 0, 0, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 6, 104, 97, 110, 100, 108, 101, 0, 3, 0, 2, 1, 113, 2, 7, 110, 101, 97, 114, 101, 115, 116, 0, 0, 6, 108, 105, 110, 101, 97, 114, 0, 0, 4, 11, 102, 105, 108, 116, 101, 114, 45, 109, 111, 100, 101, 0, 3, 0, 4, 1, 113, 3, 13, 99, 108, 97, 109, 112, 45, 116, 111, 45, 101, 100, 103, 101, 0, 0, 6, 114, 101, 112, 101, 97, 116, 0, 0, 13, 109, 105, 114, 114, 111, 114, 45, 114, 101, 112, 101, 97, 116, 0, 0, 4, 12, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 0, 3, 0, 6, 1, 114, 6, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 117, 7, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 118, 7, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 119, 7, 10, 109, 97, 103, 45, 102, 105, 108, 116, 101, 114, 5, 10, 109, 105, 110, 45, 102, 105, 108, 116, 101, 114, 5, 13, 109, 105, 112, 109, 97, 112, 45, 102, 105, 108, 116, 101, 114, 5, 4, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 0, 3, 0, 8, 3, 14, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 34, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 47, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 5, 6, 2, 3, 0, 2, 6, 104, 97, 110, 100, 108, 101, 2, 3, 0, 3, 6, 104, 97, 110, 100, 108, 101, 1, 66, 10, 2, 3, 2, 1, 3, 4, 4, 117, 108, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 7, 4, 14, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 2, 2, 3, 2, 1, 8, 4, 14, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 4, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 6, 104, 97, 110, 100, 108, 101, 0, 3, 0, 6, 1, 114, 5, 14, 98, 97, 115, 101, 45, 99, 111, 108, 111, 114, 45, 109, 97, 112, 3, 10, 110, 111, 114, 109, 97, 108, 45, 109, 97, 112, 3, 22, 109, 101, 116, 97, 108, 108, 105, 99, 45, 114, 111, 117, 103, 104, 110, 101, 115, 115, 45, 109, 97, 112, 3, 7, 115, 97, 109, 112, 108, 101, 114, 5, 11, 116, 114, 97, 110, 115, 112, 97, 114, 101, 110, 116, 127, 4, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 0, 3, 0, 8, 3, 15, 99, 108, 105, 101, 110, 116, 45, 109, 97, 116, 101, 114, 105, 97, 108, 36, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 109, 97, 116, 101, 114, 105, 97, 108, 47, 99, 108, 105, 101, 110, 116, 45, 109, 97, 116, 101, 114, 105, 97, 108, 5, 9, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 2, 3, 0, 0, 4, 109, 97, 116, 52, 2, 3, 0, 0, 4, 113, 117, 97, 116, 2, 3, 0, 0, 4, 118, 101, 99, 52, 2, 3, 0, 0, 5, 117, 118, 101, 99, 50, 2, 3, 0, 0, 5, 117, 118, 101, 99, 51, 2, 3, 0, 0, 5, 117, 118, 101, 99, 52, 2, 3, 0, 1, 6, 104, 97, 110, 100, 108, 101, 2, 3, 0, 4, 6, 104, 97, 110, 100, 108, 101, 1, 66, 110, 2, 3, 2, 1, 10, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 11, 4, 4, 109, 97, 116, 52, 0, 3, 0, 2, 2, 3, 2, 1, 12, 4, 4, 113, 117, 97, 116, 0, 3, 0, 4, 2, 3, 2, 1, 1, 4, 4, 118, 101, 99, 50, 0, 3, 0, 6, 2, 3, 2, 1, 2, 4, 4, 118, 101, 99, 51, 0, 3, 0, 8, 2, 3, 2, 1, 13, 4, 4, 118, 101, 99, 52, 0, 3, 0, 10, 2, 3, 2, 1, 14, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 12, 2, 3, 2, 1, 15, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 14, 2, 3, 2, 1, 16, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 16, 2, 3, 2, 1, 17, 4, 22, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 18, 2, 3, 2, 1, 7, 4, 25, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 20, 2, 3, 2, 1, 8, 4, 25, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 22, 2, 3, 2, 1, 18, 4, 26, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 24, 1, 109, 3, 5, 102, 114, 97, 109, 101, 5, 115, 112, 97, 119, 110, 7, 100, 101, 115, 112, 97, 119, 110, 4, 11, 113, 117, 101, 114, 121, 45, 101, 118, 101, 110, 116, 0, 3, 0, 26, 1, 112, 121, 1, 114, 4, 10, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 28, 7, 105, 110, 99, 108, 117, 100, 101, 28, 7, 101, 120, 99, 108, 117, 100, 101, 28, 7, 99, 104, 97, 110, 103, 101, 100, 28, 4, 11, 113, 117, 101, 114, 121, 45, 98, 117, 105, 108, 100, 0, 3, 0, 29, 1, 111, 0, 1, 112, 31, 1, 112, 127, 1, 112, 1, 1, 112, 118, 1, 112, 117, 1, 112, 3, 1, 112, 122, 1, 112, 5, 1, 112, 115, 1, 112, 125, 1, 112, 119, 1, 112, 7, 1, 112, 9, 1, 112, 11, 1, 112, 13, 1, 112, 15, 1, 112, 17, 1, 112, 19, 1, 112, 21, 1, 112, 23, 1, 112, 25, 1, 113, 22, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 32, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 33, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 34, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 35, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 36, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 37, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 38, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 39, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 40, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 41, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 28, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 42, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 43, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 44, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 45, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 46, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 47, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 48, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 49, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 50, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 51, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 52, 0, 4, 9, 118, 101, 99, 45, 118, 97, 108, 117, 101, 0, 3, 0, 53, 1, 107, 31, 1, 107, 127, 1, 107, 1, 1, 107, 118, 1, 107, 117, 1, 107, 3, 1, 107, 122, 1, 107, 5, 1, 107, 115, 1, 107, 125, 1, 107, 121, 1, 107, 119, 1, 107, 7, 1, 107, 9, 1, 107, 11, 1, 107, 13, 1, 107, 15, 1, 107, 17, 1, 107, 19, 1, 107, 21, 1, 107, 23, 1, 107, 25, 1, 113, 22, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 55, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 56, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 57, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 58, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 59, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 60, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 61, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 62, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 63, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 192, 0, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 193, 0, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 194, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 195, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 196, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 197, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 198, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 199, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 200, 0, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 201, 0, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 202, 0, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 203, 0, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 204, 0, 0, 4, 12, 111, 112, 116, 105, 111, 110, 45, 118, 97, 108, 117, 101, 0, 3, 0, 77, 1, 113, 24, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 31, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 127, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 1, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 118, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 117, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 3, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 122, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 5, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 115, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 125, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 121, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 119, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 7, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 9, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 11, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 13, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 15, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 17, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 19, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 21, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 23, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 25, 0, 8, 116, 121, 112, 101, 45, 118, 101, 99, 1, 54, 0, 11, 116, 121, 112, 101, 45, 111, 112, 116, 105, 111, 110, 1, 206, 0, 0, 4, 5, 118, 97, 108, 117, 101, 0, 3, 0, 79, 1, 111, 2, 121, 208, 0, 1, 112, 209, 0, 4, 6, 101, 110, 116, 105, 116, 121, 0, 3, 0, 82, 1, 64, 1, 2, 105, 100, 115, 0, 193, 0, 4, 9, 103, 101, 116, 45, 105, 110, 100, 101, 120, 0, 1, 84, 1, 107, 208, 0, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 0, 213, 0, 4, 13, 103, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 86, 1, 64, 3, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 5, 118, 97, 108, 117, 101, 208, 0, 1, 0, 4, 13, 97, 100, 100, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 87, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 4, 100, 97, 116, 97, 211, 0, 1, 0, 4, 14, 97, 100, 100, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 0, 1, 88, 4, 13, 115, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 87, 4, 14, 115, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 0, 1, 88, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 0, 127, 4, 13, 104, 97, 115, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 89, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 110, 100, 105, 99, 101, 115, 28, 0, 127, 4, 14, 104, 97, 115, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 0, 1, 90, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 1, 0, 4, 16, 114, 101, 109, 111, 118, 101, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 91, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 110, 100, 105, 99, 101, 115, 28, 1, 0, 4, 17, 114, 101, 109, 111, 118, 101, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 0, 1, 92, 1, 64, 2, 1, 113, 30, 1, 116, 27, 0, 119, 4, 5, 113, 117, 101, 114, 121, 0, 1, 93, 1, 112, 208, 0, 1, 111, 2, 1, 222, 0, 1, 112, 223, 0, 1, 64, 1, 1, 113, 119, 0, 224, 0, 4, 10, 113, 117, 101, 114, 121, 45, 101, 118, 97, 108, 0, 1, 97, 4, 9, 99, 111, 109, 112, 111, 110, 101, 110, 116, 24, 112, 107, 103, 58, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 5, 19, 11, 29, 1, 9, 99, 111, 109, 112, 111, 110, 101, 110, 116, 14, 112, 107, 103, 58, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 3, 28, 0, 7, 176, 29, 1, 65, 29, 1, 66, 22, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 111, 2, 119, 119, 4, 4, 117, 108, 105, 100, 0, 3, 0, 12, 1, 114, 2, 6, 111, 114, 105, 103, 105, 110, 3, 3, 100, 105, 114, 3, 4, 3, 114, 97, 121, 0, 3, 0, 14, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 16, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 18, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 20, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 4, 118, 101, 99, 50, 2, 3, 0, 0, 4, 118, 101, 99, 51, 2, 3, 0, 0, 4, 117, 108, 105, 100, 1, 66, 14, 2, 3, 2, 1, 1, 4, 4, 118, 101, 99, 50, 0, 3, 0, 0, 2, 3, 2, 1, 2, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 2, 3, 2, 1, 3, 4, 4, 117, 108, 105, 100, 0, 3, 0, 4, 1, 114, 4, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 6, 110, 111, 114, 109, 97, 108, 3, 7, 116, 97, 110, 103, 101, 110, 116, 3, 9, 116, 101, 120, 99, 111, 111, 114, 100, 48, 1, 4, 6, 118, 101, 114, 116, 101, 120, 0, 3, 0, 6, 1, 114, 1, 4, 117, 108, 105, 100, 5, 4, 6, 104, 97, 110, 100, 108, 101, 0, 3, 0, 8, 1, 112, 7, 1, 112, 121, 1, 114, 2, 8, 118, 101, 114, 116, 105, 99, 101, 115, 10, 7, 105, 110, 100, 105, 99, 101, 115, 11, 4, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 0, 3, 0, 12, 3, 11, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 104, 28, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 104, 47, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 104, 5, 4, 1, 66, 9, 2, 3, 2, 1, 3, 4, 4, 117, 108, 105, 100, 0, 3, 0, 0, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 6, 104, 97, 110, 100, 108, 101, 0, 3, 0, 2, 1, 113, 42, 8, 114, 56, 45, 117, 110, 111, 114, 109, 0, 0, 8, 114, 56, 45, 115, 110, 111, 114, 109, 0, 0, 7, 114, 56, 45, 117, 105, 110, 116, 0, 0, 7, 114, 56, 45, 115, 105, 110, 116, 0, 0, 8, 114, 49, 54, 45, 117, 105, 110, 116, 0, 0, 8, 114, 49, 54, 45, 115, 105, 110, 116, 0, 0, 9, 114, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 9, 114, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 9, 114, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 56, 45, 117, 110, 111, 114, 109, 0, 0, 9, 114, 103, 56, 45, 115, 110, 111, 114, 109, 0, 0, 8, 114, 103, 56, 45, 117, 105, 110, 116, 0, 0, 8, 114, 103, 56, 45, 115, 105, 110, 116, 0, 0, 8, 114, 51, 50, 45, 117, 105, 110, 116, 0, 0, 8, 114, 51, 50, 45, 115, 105, 110, 116, 0, 0, 9, 114, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 49, 54, 45, 117, 105, 110, 116, 0, 0, 9, 114, 103, 49, 54, 45, 115, 105, 110, 116, 0, 0, 10, 114, 103, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 10, 114, 103, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 10, 114, 103, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 56, 45, 117, 110, 111, 114, 109, 0, 0, 16, 114, 103, 98, 97, 56, 45, 117, 110, 111, 114, 109, 45, 115, 114, 103, 98, 0, 0, 11, 114, 103, 98, 97, 56, 45, 115, 110, 111, 114, 109, 0, 0, 10, 114, 103, 98, 97, 56, 45, 117, 105, 110, 116, 0, 0, 10, 114, 103, 98, 97, 56, 45, 115, 105, 110, 116, 0, 0, 11, 98, 103, 114, 97, 56, 45, 117, 110, 111, 114, 109, 0, 0, 16, 98, 103, 114, 97, 56, 45, 117, 110, 111, 114, 109, 45, 115, 114, 103, 98, 0, 0, 13, 114, 103, 98, 57, 101, 53, 45, 117, 102, 108, 111, 97, 116, 0, 0, 13, 114, 103, 98, 49, 48, 97, 50, 45, 117, 110, 111, 114, 109, 0, 0, 13, 114, 103, 49, 49, 98, 49, 48, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 51, 50, 45, 117, 105, 110, 116, 0, 0, 9, 114, 103, 51, 50, 45, 115, 105, 110, 116, 0, 0, 10, 114, 103, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 49, 54, 45, 117, 105, 110, 116, 0, 0, 11, 114, 103, 98, 97, 49, 54, 45, 115, 105, 110, 116, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 51, 50, 45, 117, 105, 110, 116, 0, 0, 11, 114, 103, 98, 97, 51, 50, 45, 115, 105, 110, 116, 0, 0, 12, 114, 103, 98, 97, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 4, 6, 102, 111, 114, 109, 97, 116, 0, 3, 0, 4, 1, 112, 125, 1, 114, 4, 5, 119, 105, 100, 116, 104, 121, 6, 104, 101, 105, 103, 104, 116, 121, 6, 102, 111, 114, 109, 97, 116, 5, 4, 100, 97, 116, 97, 6, 4, 12, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 50, 100, 0, 3, 0, 7, 3, 14, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 34, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 47, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 5, 5, 1, 66, 10, 2, 3, 2, 1, 3, 4, 4, 117, 108, 105, 100, 0, 3, 0, 0, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 6, 104, 97, 110, 100, 108, 101, 0, 3, 0, 2, 1, 113, 2, 7, 110, 101, 97, 114, 101, 115, 116, 0, 0, 6, 108, 105, 110, 101, 97, 114, 0, 0, 4, 11, 102, 105, 108, 116, 101, 114, 45, 109, 111, 100, 101, 0, 3, 0, 4, 1, 113, 3, 13, 99, 108, 97, 109, 112, 45, 116, 111, 45, 101, 100, 103, 101, 0, 0, 6, 114, 101, 112, 101, 97, 116, 0, 0, 13, 109, 105, 114, 114, 111, 114, 45, 114, 101, 112, 101, 97, 116, 0, 0, 4, 12, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 0, 3, 0, 6, 1, 114, 6, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 117, 7, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 118, 7, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 119, 7, 10, 109, 97, 103, 45, 102, 105, 108, 116, 101, 114, 5, 10, 109, 105, 110, 45, 102, 105, 108, 116, 101, 114, 5, 13, 109, 105, 112, 109, 97, 112, 45, 102, 105, 108, 116, 101, 114, 5, 4, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 0, 3, 0, 8, 3, 14, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 34, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 47, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 5, 6, 2, 3, 0, 2, 6, 104, 97, 110, 100, 108, 101, 2, 3, 0, 3, 6, 104, 97, 110, 100, 108, 101, 1, 66, 10, 2, 3, 2, 1, 3, 4, 4, 117, 108, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 7, 4, 14, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 2, 2, 3, 2, 1, 8, 4, 14, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 4, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 6, 104, 97, 110, 100, 108, 101, 0, 3, 0, 6, 1, 114, 5, 14, 98, 97, 115, 101, 45, 99, 111, 108, 111, 114, 45, 109, 97, 112, 3, 10, 110, 111, 114, 109, 97, 108, 45, 109, 97, 112, 3, 22, 109, 101, 116, 97, 108, 108, 105, 99, 45, 114, 111, 117, 103, 104, 110, 101, 115, 115, 45, 109, 97, 112, 3, 7, 115, 97, 109, 112, 108, 101, 114, 5, 11, 116, 114, 97, 110, 115, 112, 97, 114, 101, 110, 116, 127, 4, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 0, 3, 0, 8, 3, 15, 99, 108, 105, 101, 110, 116, 45, 109, 97, 116, 101, 114, 105, 97, 108, 36, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 109, 97, 116, 101, 114, 105, 97, 108, 47, 99, 108, 105, 101, 110, 116, 45, 109, 97, 116, 101, 114, 105, 97, 108, 5, 9, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 2, 3, 0, 0, 4, 109, 97, 116, 52, 2, 3, 0, 0, 4, 113, 117, 97, 116, 2, 3, 0, 0, 4, 118, 101, 99, 52, 2, 3, 0, 0, 5, 117, 118, 101, 99, 50, 2, 3, 0, 0, 5, 117, 118, 101, 99, 51, 2, 3, 0, 0, 5, 117, 118, 101, 99, 52, 2, 3, 0, 1, 6, 104, 97, 110, 100, 108, 101, 2, 3, 0, 4, 6, 104, 97, 110, 100, 108, 101, 1, 66, 84, 2, 3, 2, 1, 10, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 11, 4, 4, 109, 97, 116, 52, 0, 3, 0, 2, 2, 3, 2, 1, 12, 4, 4, 113, 117, 97, 116, 0, 3, 0, 4, 2, 3, 2, 1, 1, 4, 4, 118, 101, 99, 50, 0, 3, 0, 6, 2, 3, 2, 1, 2, 4, 4, 118, 101, 99, 51, 0, 3, 0, 8, 2, 3, 2, 1, 13, 4, 4, 118, 101, 99, 52, 0, 3, 0, 10, 2, 3, 2, 1, 14, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 12, 2, 3, 2, 1, 15, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 14, 2, 3, 2, 1, 16, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 16, 2, 3, 2, 1, 17, 4, 22, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 18, 2, 3, 2, 1, 7, 4, 25, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 20, 2, 3, 2, 1, 8, 4, 25, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 22, 2, 3, 2, 1, 18, 4, 26, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 24, 1, 109, 3, 5, 102, 114, 97, 109, 101, 5, 115, 112, 97, 119, 110, 7, 100, 101, 115, 112, 97, 119, 110, 4, 11, 113, 117, 101, 114, 121, 45, 101, 118, 101, 110, 116, 0, 3, 0, 26, 1, 112, 121, 1, 114, 4, 10, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 28, 7, 105, 110, 99, 108, 117, 100, 101, 28, 7, 101, 120, 99, 108, 117, 100, 101, 28, 7, 99, 104, 97, 110, 103, 101, 100, 28, 4, 11, 113, 117, 101, 114, 121, 45, 98, 117, 105, 108, 100, 0, 3, 0, 29, 1, 111, 0, 1, 112, 31, 1, 112, 127, 1, 112, 1, 1, 112, 118, 1, 112, 117, 1, 112, 3, 1, 112, 122, 1, 112, 5, 1, 112, 115, 1, 112, 125, 1, 112, 119, 1, 112, 7, 1, 112, 9, 1, 112, 11, 1, 112, 13, 1, 112, 15, 1, 112, 17, 1, 112, 19, 1, 112, 21, 1, 112, 23, 1, 112, 25, 1, 113, 22, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 32, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 33, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 34, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 35, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 36, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 37, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 38, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 39, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 40, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 41, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 28, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 42, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 43, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 44, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 45, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 46, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 47, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 48, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 49, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 50, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 51, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 52, 0, 4, 9, 118, 101, 99, 45, 118, 97, 108, 117, 101, 0, 3, 0, 53, 1, 107, 31, 1, 107, 127, 1, 107, 1, 1, 107, 118, 1, 107, 117, 1, 107, 3, 1, 107, 122, 1, 107, 5, 1, 107, 115, 1, 107, 125, 1, 107, 121, 1, 107, 119, 1, 107, 7, 1, 107, 9, 1, 107, 11, 1, 107, 13, 1, 107, 15, 1, 107, 17, 1, 107, 19, 1, 107, 21, 1, 107, 23, 1, 107, 25, 1, 113, 22, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 55, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 56, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 57, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 58, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 59, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 60, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 61, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 62, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 63, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 192, 0, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 193, 0, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 194, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 195, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 196, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 197, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 198, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 199, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 200, 0, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 201, 0, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 202, 0, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 203, 0, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 204, 0, 0, 4, 12, 111, 112, 116, 105, 111, 110, 45, 118, 97, 108, 117, 101, 0, 3, 0, 77, 1, 113, 24, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 31, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 127, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 1, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 118, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 117, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 3, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 122, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 5, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 115, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 125, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 121, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 119, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 7, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 9, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 11, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 13, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 15, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 17, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 19, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 21, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 23, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 25, 0, 8, 116, 121, 112, 101, 45, 118, 101, 99, 1, 54, 0, 11, 116, 121, 112, 101, 45, 111, 112, 116, 105, 111, 110, 1, 206, 0, 0, 4, 5, 118, 97, 108, 117, 101, 0, 3, 0, 79, 1, 111, 2, 121, 208, 0, 1, 112, 209, 0, 4, 6, 101, 110, 116, 105, 116, 121, 0, 3, 0, 82, 3, 9, 99, 111, 109, 112, 111, 110, 101, 110, 116, 24, 112, 107, 103, 58, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 5, 19, 2, 3, 0, 5, 6, 101, 110, 116, 105, 116, 121, 1, 66, 4, 2, 3, 2, 1, 20, 4, 6, 101, 110, 116, 105, 116, 121, 0, 3, 0, 0, 1, 64, 1, 4, 110, 97, 109, 101, 115, 1, 0, 4, 9, 115, 117, 98, 115, 99, 114, 105, 98, 101, 0, 1, 2, 4, 5, 101, 118, 101, 110, 116, 18, 112, 107, 103, 58, 47, 109, 101, 115, 115, 97, 103, 101, 47, 101, 118, 101, 110, 116, 5, 21, 11, 25, 1, 7, 109, 101, 115, 115, 97, 103, 101, 12, 112, 107, 103, 58, 47, 109, 101, 115, 115, 97, 103, 101, 3, 30, 0, 7, 243, 37, 1, 65, 29, 1, 66, 22, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 111, 2, 119, 119, 4, 4, 117, 108, 105, 100, 0, 3, 0, 12, 1, 114, 2, 6, 111, 114, 105, 103, 105, 110, 3, 3, 100, 105, 114, 3, 4, 3, 114, 97, 121, 0, 3, 0, 14, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 16, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 18, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 20, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 4, 118, 101, 99, 50, 2, 3, 0, 0, 4, 118, 101, 99, 51, 2, 3, 0, 0, 4, 117, 108, 105, 100, 1, 66, 14, 2, 3, 2, 1, 1, 4, 4, 118, 101, 99, 50, 0, 3, 0, 0, 2, 3, 2, 1, 2, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 2, 3, 2, 1, 3, 4, 4, 117, 108, 105, 100, 0, 3, 0, 4, 1, 114, 4, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 6, 110, 111, 114, 109, 97, 108, 3, 7, 116, 97, 110, 103, 101, 110, 116, 3, 9, 116, 101, 120, 99, 111, 111, 114, 100, 48, 1, 4, 6, 118, 101, 114, 116, 101, 120, 0, 3, 0, 6, 1, 114, 1, 4, 117, 108, 105, 100, 5, 4, 6, 104, 97, 110, 100, 108, 101, 0, 3, 0, 8, 1, 112, 7, 1, 112, 121, 1, 114, 2, 8, 118, 101, 114, 116, 105, 99, 101, 115, 10, 7, 105, 110, 100, 105, 99, 101, 115, 11, 4, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 0, 3, 0, 12, 3, 11, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 104, 28, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 104, 47, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 104, 5, 4, 1, 66, 9, 2, 3, 2, 1, 3, 4, 4, 117, 108, 105, 100, 0, 3, 0, 0, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 6, 104, 97, 110, 100, 108, 101, 0, 3, 0, 2, 1, 113, 42, 8, 114, 56, 45, 117, 110, 111, 114, 109, 0, 0, 8, 114, 56, 45, 115, 110, 111, 114, 109, 0, 0, 7, 114, 56, 45, 117, 105, 110, 116, 0, 0, 7, 114, 56, 45, 115, 105, 110, 116, 0, 0, 8, 114, 49, 54, 45, 117, 105, 110, 116, 0, 0, 8, 114, 49, 54, 45, 115, 105, 110, 116, 0, 0, 9, 114, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 9, 114, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 9, 114, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 56, 45, 117, 110, 111, 114, 109, 0, 0, 9, 114, 103, 56, 45, 115, 110, 111, 114, 109, 0, 0, 8, 114, 103, 56, 45, 117, 105, 110, 116, 0, 0, 8, 114, 103, 56, 45, 115, 105, 110, 116, 0, 0, 8, 114, 51, 50, 45, 117, 105, 110, 116, 0, 0, 8, 114, 51, 50, 45, 115, 105, 110, 116, 0, 0, 9, 114, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 49, 54, 45, 117, 105, 110, 116, 0, 0, 9, 114, 103, 49, 54, 45, 115, 105, 110, 116, 0, 0, 10, 114, 103, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 10, 114, 103, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 10, 114, 103, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 56, 45, 117, 110, 111, 114, 109, 0, 0, 16, 114, 103, 98, 97, 56, 45, 117, 110, 111, 114, 109, 45, 115, 114, 103, 98, 0, 0, 11, 114, 103, 98, 97, 56, 45, 115, 110, 111, 114, 109, 0, 0, 10, 114, 103, 98, 97, 56, 45, 117, 105, 110, 116, 0, 0, 10, 114, 103, 98, 97, 56, 45, 115, 105, 110, 116, 0, 0, 11, 98, 103, 114, 97, 56, 45, 117, 110, 111, 114, 109, 0, 0, 16, 98, 103, 114, 97, 56, 45, 117, 110, 111, 114, 109, 45, 115, 114, 103, 98, 0, 0, 13, 114, 103, 98, 57, 101, 53, 45, 117, 102, 108, 111, 97, 116, 0, 0, 13, 114, 103, 98, 49, 48, 97, 50, 45, 117, 110, 111, 114, 109, 0, 0, 13, 114, 103, 49, 49, 98, 49, 48, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 51, 50, 45, 117, 105, 110, 116, 0, 0, 9, 114, 103, 51, 50, 45, 115, 105, 110, 116, 0, 0, 10, 114, 103, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 49, 54, 45, 117, 105, 110, 116, 0, 0, 11, 114, 103, 98, 97, 49, 54, 45, 115, 105, 110, 116, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 51, 50, 45, 117, 105, 110, 116, 0, 0, 11, 114, 103, 98, 97, 51, 50, 45, 115, 105, 110, 116, 0, 0, 12, 114, 103, 98, 97, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 4, 6, 102, 111, 114, 109, 97, 116, 0, 3, 0, 4, 1, 112, 125, 1, 114, 4, 5, 119, 105, 100, 116, 104, 121, 6, 104, 101, 105, 103, 104, 116, 121, 6, 102, 111, 114, 109, 97, 116, 5, 4, 100, 97, 116, 97, 6, 4, 12, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 50, 100, 0, 3, 0, 7, 3, 14, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 34, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 47, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 5, 5, 1, 66, 10, 2, 3, 2, 1, 3, 4, 4, 117, 108, 105, 100, 0, 3, 0, 0, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 6, 104, 97, 110, 100, 108, 101, 0, 3, 0, 2, 1, 113, 2, 7, 110, 101, 97, 114, 101, 115, 116, 0, 0, 6, 108, 105, 110, 101, 97, 114, 0, 0, 4, 11, 102, 105, 108, 116, 101, 114, 45, 109, 111, 100, 101, 0, 3, 0, 4, 1, 113, 3, 13, 99, 108, 97, 109, 112, 45, 116, 111, 45, 101, 100, 103, 101, 0, 0, 6, 114, 101, 112, 101, 97, 116, 0, 0, 13, 109, 105, 114, 114, 111, 114, 45, 114, 101, 112, 101, 97, 116, 0, 0, 4, 12, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 0, 3, 0, 6, 1, 114, 6, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 117, 7, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 118, 7, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 119, 7, 10, 109, 97, 103, 45, 102, 105, 108, 116, 101, 114, 5, 10, 109, 105, 110, 45, 102, 105, 108, 116, 101, 114, 5, 13, 109, 105, 112, 109, 97, 112, 45, 102, 105, 108, 116, 101, 114, 5, 4, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 0, 3, 0, 8, 3, 14, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 34, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 47, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 5, 6, 2, 3, 0, 2, 6, 104, 97, 110, 100, 108, 101, 2, 3, 0, 3, 6, 104, 97, 110, 100, 108, 101, 1, 66, 10, 2, 3, 2, 1, 3, 4, 4, 117, 108, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 7, 4, 14, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 2, 2, 3, 2, 1, 8, 4, 14, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 4, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 6, 104, 97, 110, 100, 108, 101, 0, 3, 0, 6, 1, 114, 5, 14, 98, 97, 115, 101, 45, 99, 111, 108, 111, 114, 45, 109, 97, 112, 3, 10, 110, 111, 114, 109, 97, 108, 45, 109, 97, 112, 3, 22, 109, 101, 116, 97, 108, 108, 105, 99, 45, 114, 111, 117, 103, 104, 110, 101, 115, 115, 45, 109, 97, 112, 3, 7, 115, 97, 109, 112, 108, 101, 114, 5, 11, 116, 114, 97, 110, 115, 112, 97, 114, 101, 110, 116, 127, 4, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 0, 3, 0, 8, 3, 15, 99, 108, 105, 101, 110, 116, 45, 109, 97, 116, 101, 114, 105, 97, 108, 36, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 109, 97, 116, 101, 114, 105, 97, 108, 47, 99, 108, 105, 101, 110, 116, 45, 109, 97, 116, 101, 114, 105, 97, 108, 5, 9, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 2, 3, 0, 0, 4, 109, 97, 116, 52, 2, 3, 0, 0, 4, 113, 117, 97, 116, 2, 3, 0, 0, 4, 118, 101, 99, 52, 2, 3, 0, 0, 5, 117, 118, 101, 99, 50, 2, 3, 0, 0, 5, 117, 118, 101, 99, 51, 2, 3, 0, 0, 5, 117, 118, 101, 99, 52, 2, 3, 0, 1, 6, 104, 97, 110, 100, 108, 101, 2, 3, 0, 4, 6, 104, 97, 110, 100, 108, 101, 1, 66, 84, 2, 3, 2, 1, 10, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 11, 4, 4, 109, 97, 116, 52, 0, 3, 0, 2, 2, 3, 2, 1, 12, 4, 4, 113, 117, 97, 116, 0, 3, 0, 4, 2, 3, 2, 1, 1, 4, 4, 118, 101, 99, 50, 0, 3, 0, 6, 2, 3, 2, 1, 2, 4, 4, 118, 101, 99, 51, 0, 3, 0, 8, 2, 3, 2, 1, 13, 4, 4, 118, 101, 99, 52, 0, 3, 0, 10, 2, 3, 2, 1, 14, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 12, 2, 3, 2, 1, 15, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 14, 2, 3, 2, 1, 16, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 16, 2, 3, 2, 1, 17, 4, 22, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 18, 2, 3, 2, 1, 7, 4, 25, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 20, 2, 3, 2, 1, 8, 4, 25, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 22, 2, 3, 2, 1, 18, 4, 26, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 24, 1, 109, 3, 5, 102, 114, 97, 109, 101, 5, 115, 112, 97, 119, 110, 7, 100, 101, 115, 112, 97, 119, 110, 4, 11, 113, 117, 101, 114, 121, 45, 101, 118, 101, 110, 116, 0, 3, 0, 26, 1, 112, 121, 1, 114, 4, 10, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 28, 7, 105, 110, 99, 108, 117, 100, 101, 28, 7, 101, 120, 99, 108, 117, 100, 101, 28, 7, 99, 104, 97, 110, 103, 101, 100, 28, 4, 11, 113, 117, 101, 114, 121, 45, 98, 117, 105, 108, 100, 0, 3, 0, 29, 1, 111, 0, 1, 112, 31, 1, 112, 127, 1, 112, 1, 1, 112, 118, 1, 112, 117, 1, 112, 3, 1, 112, 122, 1, 112, 5, 1, 112, 115, 1, 112, 125, 1, 112, 119, 1, 112, 7, 1, 112, 9, 1, 112, 11, 1, 112, 13, 1, 112, 15, 1, 112, 17, 1, 112, 19, 1, 112, 21, 1, 112, 23, 1, 112, 25, 1, 113, 22, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 32, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 33, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 34, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 35, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 36, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 37, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 38, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 39, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 40, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 41, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 28, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 42, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 43, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 44, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 45, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 46, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 47, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 48, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 49, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 50, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 51, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 52, 0, 4, 9, 118, 101, 99, 45, 118, 97, 108, 117, 101, 0, 3, 0, 53, 1, 107, 31, 1, 107, 127, 1, 107, 1, 1, 107, 118, 1, 107, 117, 1, 107, 3, 1, 107, 122, 1, 107, 5, 1, 107, 115, 1, 107, 125, 1, 107, 121, 1, 107, 119, 1, 107, 7, 1, 107, 9, 1, 107, 11, 1, 107, 13, 1, 107, 15, 1, 107, 17, 1, 107, 19, 1, 107, 21, 1, 107, 23, 1, 107, 25, 1, 113, 22, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 55, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 56, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 57, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 58, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 59, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 60, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 61, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 62, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 63, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 192, 0, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 193, 0, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 194, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 195, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 196, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 197, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 198, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 199, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 200, 0, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 201, 0, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 202, 0, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 203, 0, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 204, 0, 0, 4, 12, 111, 112, 116, 105, 111, 110, 45, 118, 97, 108, 117, 101, 0, 3, 0, 77, 1, 113, 24, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 31, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 127, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 1, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 118, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 117, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 3, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 122, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 5, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 115, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 125, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 121, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 119, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 7, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 9, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 11, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 13, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 15, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 17, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 19, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 21, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 23, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 25, 0, 8, 116, 121, 112, 101, 45, 118, 101, 99, 1, 54, 0, 11, 116, 121, 112, 101, 45, 111, 112, 116, 105, 111, 110, 1, 206, 0, 0, 4, 5, 118, 97, 108, 117, 101, 0, 3, 0, 79, 1, 111, 2, 121, 208, 0, 1, 112, 209, 0, 4, 6, 101, 110, 116, 105, 116, 121, 0, 3, 0, 82, 3, 9, 99, 111, 109, 112, 111, 110, 101, 110, 116, 24, 112, 107, 103, 58, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 5, 19, 2, 3, 0, 5, 6, 101, 110, 116, 105, 116, 121, 1, 66, 59, 2, 3, 2, 1, 10, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 2, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 2, 3, 2, 1, 12, 4, 4, 113, 117, 97, 116, 0, 3, 0, 4, 2, 3, 2, 1, 11, 4, 4, 109, 97, 116, 52, 0, 3, 0, 6, 2, 3, 2, 1, 20, 4, 11, 101, 110, 116, 105, 116, 121, 45, 100, 97, 116, 97, 0, 3, 0, 8, 1, 114, 2, 6, 119, 101, 105, 103, 104, 116, 118, 4, 109, 97, 115, 107, 121, 4, 21, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 115, 116, 97, 99, 107, 45, 98, 108, 101, 110, 100, 0, 3, 0, 10, 1, 114, 2, 12, 97, 99, 116, 105, 111, 110, 45, 105, 110, 100, 101, 120, 121, 15, 116, 105, 109, 101, 45, 112, 101, 114, 99, 101, 110, 116, 97, 103, 101, 118, 4, 27, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 115, 97, 109, 112, 108, 101, 45, 112, 101, 114, 99, 101, 110, 116, 97, 103, 101, 0, 3, 0, 12, 1, 114, 2, 12, 97, 99, 116, 105, 111, 110, 45, 105, 110, 100, 101, 120, 121, 13, 116, 105, 109, 101, 45, 97, 98, 115, 111, 108, 117, 116, 101, 118, 4, 25, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 115, 97, 109, 112, 108, 101, 45, 97, 98, 115, 111, 108, 117, 116, 101, 0, 3, 0, 14, 1, 113, 5, 6, 115, 97, 109, 112, 108, 101, 1, 121, 0, 17, 115, 97, 109, 112, 108, 101, 45, 112, 101, 114, 99, 101, 110, 116, 97, 103, 101, 1, 13, 0, 15, 115, 97, 109, 112, 108, 101, 45, 97, 98, 115, 111, 108, 117, 116, 101, 1, 15, 0, 11, 105, 110, 116, 101, 114, 112, 111, 108, 97, 116, 101, 1, 118, 0, 5, 98, 108, 101, 110, 100, 1, 11, 0, 4, 22, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 97, 99, 116, 105, 111, 110, 45, 115, 116, 97, 99, 107, 0, 3, 0, 16, 1, 114, 3, 8, 99, 108, 105, 112, 45, 117, 114, 108, 115, 7, 108, 111, 111, 112, 105, 110, 103, 127, 6, 119, 101, 105, 103, 104, 116, 118, 4, 16, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 97, 99, 116, 105, 111, 110, 0, 3, 0, 18, 1, 112, 19, 1, 114, 2, 7, 97, 99, 116, 105, 111, 110, 115, 20, 15, 97, 112, 112, 108, 121, 45, 98, 97, 115, 101, 45, 112, 111, 115, 101, 127, 4, 20, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 99, 111, 110, 116, 114, 111, 108, 108, 101, 114, 0, 3, 0, 21, 1, 112, 17, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 115, 116, 97, 99, 107, 23, 1, 0, 4, 26, 115, 101, 116, 45, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 97, 99, 116, 105, 111, 110, 45, 115, 116, 97, 99, 107, 0, 1, 24, 1, 112, 115, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 4, 109, 97, 115, 107, 25, 1, 0, 4, 25, 115, 101, 116, 45, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 98, 105, 110, 100, 101, 114, 45, 109, 97, 115, 107, 0, 1, 26, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 0, 25, 4, 25, 103, 101, 116, 45, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 98, 105, 110, 100, 101, 114, 45, 109, 97, 115, 107, 0, 1, 27, 1, 112, 118, 1, 64, 3, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 4, 109, 97, 115, 107, 28, 1, 0, 4, 28, 115, 101, 116, 45, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 98, 105, 110, 100, 101, 114, 45, 119, 101, 105, 103, 104, 116, 115, 0, 1, 29, 1, 112, 1, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 0, 30, 4, 34, 103, 101, 116, 45, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 98, 105, 110, 100, 101, 114, 45, 109, 97, 115, 107, 45, 101, 110, 116, 105, 116, 105, 101, 115, 0, 1, 31, 1, 64, 4, 6, 101, 110, 116, 105, 116, 121, 1, 7, 119, 101, 105, 103, 104, 116, 115, 28, 4, 116, 105, 109, 101, 28, 13, 97, 98, 115, 111, 108, 117, 116, 101, 45, 116, 105, 109, 101, 127, 1, 0, 4, 19, 115, 101, 116, 45, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 98, 108, 101, 110, 100, 0, 1, 32, 1, 112, 7, 1, 64, 2, 8, 101, 110, 116, 105, 116, 105, 101, 115, 30, 6, 111, 114, 105, 103, 105, 110, 1, 0, 33, 4, 26, 103, 101, 116, 45, 116, 114, 97, 110, 115, 102, 111, 114, 109, 115, 45, 114, 101, 108, 97, 116, 105, 118, 101, 45, 116, 111, 0, 1, 34, 1, 64, 1, 4, 100, 97, 116, 97, 9, 0, 1, 4, 5, 115, 112, 97, 119, 110, 0, 1, 35, 1, 107, 9, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 0, 36, 4, 7, 100, 101, 115, 112, 97, 119, 110, 0, 1, 37, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 20, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 99, 111, 110, 116, 114, 111, 108, 108, 101, 114, 22, 1, 0, 4, 24, 115, 101, 116, 45, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 99, 111, 110, 116, 114, 111, 108, 108, 101, 114, 0, 1, 38, 1, 64, 2, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 6, 114, 97, 100, 105, 117, 115, 118, 0, 30, 4, 7, 105, 110, 45, 97, 114, 101, 97, 0, 1, 39, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 0, 127, 4, 6, 101, 120, 105, 115, 116, 115, 0, 1, 40, 1, 64, 1, 5, 105, 110, 100, 101, 120, 121, 0, 30, 4, 7, 103, 101, 116, 45, 97, 108, 108, 0, 1, 41, 1, 64, 0, 0, 1, 4, 9, 114, 101, 115, 111, 117, 114, 99, 101, 115, 0, 1, 42, 4, 22, 115, 121, 110, 99, 104, 114, 111, 110, 105, 122, 101, 100, 45, 114, 101, 115, 111, 117, 114, 99, 101, 115, 0, 1, 42, 4, 19, 112, 101, 114, 115, 105, 115, 116, 101, 100, 45, 114, 101, 115, 111, 117, 114, 99, 101, 115, 0, 1, 42, 4, 6, 101, 110, 116, 105, 116, 121, 18, 112, 107, 103, 58, 47, 101, 110, 116, 105, 116, 121, 47, 101, 110, 116, 105, 116, 121, 5, 21, 11, 23, 1, 6, 101, 110, 116, 105, 116, 121, 11, 112, 107, 103, 58, 47, 101, 110, 116, 105, 116, 121, 3, 32, 0, 7, 207, 16, 1, 65, 6, 1, 66, 22, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 111, 2, 119, 119, 4, 4, 117, 108, 105, 100, 0, 3, 0, 12, 1, 114, 2, 6, 111, 114, 105, 103, 105, 110, 3, 3, 100, 105, 114, 3, 4, 3, 114, 97, 121, 0, 3, 0, 14, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 16, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 18, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 20, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 4, 118, 101, 99, 50, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 66, 23, 2, 3, 2, 1, 1, 4, 4, 118, 101, 99, 50, 0, 3, 0, 0, 2, 3, 2, 1, 2, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 2, 1, 109, 163, 1, 4, 107, 101, 121, 49, 4, 107, 101, 121, 50, 4, 107, 101, 121, 51, 4, 107, 101, 121, 52, 4, 107, 101, 121, 53, 4, 107, 101, 121, 54, 4, 107, 101, 121, 55, 4, 107, 101, 121, 56, 4, 107, 101, 121, 57, 4, 107, 101, 121, 48, 1, 97, 1, 98, 1, 99, 1, 100, 1, 101, 1, 102, 1, 103, 1, 104, 1, 105, 1, 106, 1, 107, 1, 108, 1, 109, 1, 110, 1, 111, 1, 112, 1, 113, 1, 114, 1, 115, 1, 116, 1, 117, 1, 118, 1, 119, 1, 120, 1, 121, 1, 122, 6, 101, 115, 99, 97, 112, 101, 2, 102, 49, 2, 102, 50, 2, 102, 51, 2, 102, 52, 2, 102, 53, 2, 102, 54, 2, 102, 55, 2, 102, 56, 2, 102, 57, 3, 102, 49, 48, 3, 102, 49, 49, 3, 102, 49, 50, 3, 102, 49, 51, 3, 102, 49, 52, 3, 102, 49, 53, 3, 102, 49, 54, 3, 102, 49, 55, 3, 102, 49, 56, 3, 102, 49, 57, 3, 102, 50, 48, 3, 102, 50, 49, 3, 102, 50, 50, 3, 102, 50, 51, 3, 102, 50, 52, 8, 115, 110, 97, 112, 115, 104, 111, 116, 6, 115, 99, 114, 111, 108, 108, 5, 112, 97, 117, 115, 101, 6, 105, 110, 115, 101, 114, 116, 4, 104, 111, 109, 101, 6, 100, 101, 108, 101, 116, 101, 3, 101, 110, 100, 9, 112, 97, 103, 101, 45, 100, 111, 119, 110, 7, 112, 97, 103, 101, 45, 117, 112, 4, 108, 101, 102, 116, 2, 117, 112, 5, 114, 105, 103, 104, 116, 4, 100, 111, 119, 110, 4, 98, 97, 99, 107, 6, 114, 101, 116, 117, 114, 110, 5, 115, 112, 97, 99, 101, 7, 99, 111, 109, 112, 111, 115, 101, 5, 99, 97, 114, 101, 116, 7, 110, 117, 109, 108, 111, 99, 107, 7, 110, 117, 109, 112, 97, 100, 48, 7, 110, 117, 109, 112, 97, 100, 49, 7, 110, 117, 109, 112, 97, 100, 50, 7, 110, 117, 109, 112, 97, 100, 51, 7, 110, 117, 109, 112, 97, 100, 52, 7, 110, 117, 109, 112, 97, 100, 53, 7, 110, 117, 109, 112, 97, 100, 54, 7, 110, 117, 109, 112, 97, 100, 55, 7, 110, 117, 109, 112, 97, 100, 56, 7, 110, 117, 109, 112, 97, 100, 57, 10, 110, 117, 109, 112, 97, 100, 45, 97, 100, 100, 13, 110, 117, 109, 112, 97, 100, 45, 100, 105, 118, 105, 100, 101, 14, 110, 117, 109, 112, 97, 100, 45, 100, 101, 99, 105, 109, 97, 108, 12, 110, 117, 109, 112, 97, 100, 45, 99, 111, 109, 109, 97, 12, 110, 117, 109, 112, 97, 100, 45, 101, 110, 116, 101, 114, 13, 110, 117, 109, 112, 97, 100, 45, 101, 113, 117, 97, 108, 115, 15, 110, 117, 109, 112, 97, 100, 45, 109, 117, 108, 116, 105, 112, 108, 121, 15, 110, 117, 109, 112, 97, 100, 45, 115, 117, 98, 116, 114, 97, 99, 116, 7, 97, 98, 110, 116, 45, 99, 49, 7, 97, 98, 110, 116, 45, 99, 50, 10, 97, 112, 111, 115, 116, 114, 111, 112, 104, 101, 4, 97, 112, 112, 115, 8, 97, 115, 116, 101, 114, 105, 115, 107, 2, 97, 116, 2, 97, 120, 9, 98, 97, 99, 107, 115, 108, 97, 115, 104, 10, 99, 97, 108, 99, 117, 108, 97, 116, 111, 114, 7, 99, 97, 112, 105, 116, 97, 108, 5, 99, 111, 108, 111, 110, 5, 99, 111, 109, 109, 97, 7, 99, 111, 110, 118, 101, 114, 116, 6, 101, 113, 117, 97, 108, 115, 5, 103, 114, 97, 118, 101, 4, 107, 97, 110, 97, 5, 107, 97, 110, 106, 105, 5, 108, 45, 97, 108, 116, 9, 108, 45, 98, 114, 97, 99, 107, 101, 116, 9, 108, 45, 99, 111, 110, 116, 114, 111, 108, 7, 108, 45, 115, 104, 105, 102, 116, 5, 108, 45, 119, 105, 110, 4, 109, 97, 105, 108, 12, 109, 101, 100, 105, 97, 45, 115, 101, 108, 101, 99, 116, 10, 109, 101, 100, 105, 97, 45, 115, 116, 111, 112, 5, 109, 105, 110, 117, 115, 4, 109, 117, 116, 101, 11, 109, 121, 45, 99, 111, 109, 112, 117, 116, 101, 114, 16, 110, 97, 118, 105, 103, 97, 116, 101, 45, 102, 111, 114, 119, 97, 114, 100, 17, 110, 97, 118, 105, 103, 97, 116, 101, 45, 98, 97, 99, 107, 119, 97, 114, 100, 10, 110, 101, 120, 116, 45, 116, 114, 97, 99, 107, 10, 110, 111, 45, 99, 111, 110, 118, 101, 114, 116, 6, 111, 101, 109, 49, 48, 50, 6, 112, 101, 114, 105, 111, 100, 10, 112, 108, 97, 121, 45, 112, 97, 117, 115, 101, 4, 112, 108, 117, 115, 5, 112, 111, 119, 101, 114, 10, 112, 114, 101, 118, 45, 116, 114, 97, 99, 107, 5, 114, 45, 97, 108, 116, 9, 114, 45, 98, 114, 97, 99, 107, 101, 116, 9, 114, 45, 99, 111, 110, 116, 114, 111, 108, 7, 114, 45, 115, 104, 105, 102, 116, 5, 114, 45, 119, 105, 110, 9, 115, 101, 109, 105, 99, 111, 108, 111, 110, 5, 115, 108, 97, 115, 104, 5, 115, 108, 101, 101, 112, 4, 115, 116, 111, 112, 5, 115, 121, 115, 114, 113, 3, 116, 97, 98, 9, 117, 110, 100, 101, 114, 108, 105, 110, 101, 9, 117, 110, 108, 97, 98, 101, 108, 101, 100, 11, 118, 111, 108, 117, 109, 101, 45, 100, 111, 119, 110, 9, 118, 111, 108, 117, 109, 101, 45, 117, 112, 4, 119, 97, 107, 101, 8, 119, 101, 98, 45, 98, 97, 99, 107, 13, 119, 101, 98, 45, 102, 97, 118, 111, 114, 105, 116, 101, 115, 11, 119, 101, 98, 45, 102, 111, 114, 119, 97, 114, 100, 8, 119, 101, 98, 45, 104, 111, 109, 101, 11, 119, 101, 98, 45, 114, 101, 102, 114, 101, 115, 104, 10, 119, 101, 98, 45, 115, 101, 97, 114, 99, 104, 8, 119, 101, 98, 45, 115, 116, 111, 112, 3, 121, 101, 110, 4, 99, 111, 112, 121, 5, 112, 97, 115, 116, 101, 3, 99, 117, 116, 4, 16, 118, 105, 114, 116, 117, 97, 108, 45, 107, 101, 121, 45, 99, 111, 100, 101, 0, 3, 0, 4, 1, 113, 4, 4, 108, 101, 102, 116, 0, 0, 5, 114, 105, 103, 104, 116, 0, 0, 6, 109, 105, 100, 100, 108, 101, 0, 0, 5, 111, 116, 104, 101, 114, 1, 123, 0, 4, 12, 109, 111, 117, 115, 101, 45, 98, 117, 116, 116, 111, 110, 0, 3, 0, 6, 1, 112, 5, 1, 112, 7, 1, 114, 5, 4, 107, 101, 121, 115, 8, 14, 109, 111, 117, 115, 101, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 11, 109, 111, 117, 115, 101, 45, 100, 101, 108, 116, 97, 1, 11, 109, 111, 117, 115, 101, 45, 119, 104, 101, 101, 108, 118, 13, 109, 111, 117, 115, 101, 45, 98, 117, 116, 116, 111, 110, 115, 9, 4, 5, 105, 110, 112, 117, 116, 0, 3, 0, 10, 1, 113, 35, 12, 100, 101, 102, 97, 117, 108, 116, 45, 105, 99, 111, 110, 0, 0, 9, 99, 114, 111, 115, 115, 104, 97, 105, 114, 0, 0, 4, 104, 97, 110, 100, 0, 0, 5, 97, 114, 114, 111, 119, 0, 0, 4, 109, 111, 118, 101, 0, 0, 4, 116, 101, 120, 116, 0, 0, 4, 119, 97, 105, 116, 0, 0, 4, 104, 101, 108, 112, 0, 0, 8, 112, 114, 111, 103, 114, 101, 115, 115, 0, 0, 11, 110, 111, 116, 45, 97, 108, 108, 111, 119, 101, 100, 0, 0, 12, 99, 111, 110, 116, 101, 120, 116, 45, 109, 101, 110, 117, 0, 0, 4, 99, 101, 108, 108, 0, 0, 13, 118, 101, 114, 116, 105, 99, 97, 108, 45, 116, 101, 120, 116, 0, 0, 5, 97, 108, 105, 97, 115, 0, 0, 4, 99, 111, 112, 121, 0, 0, 7, 110, 111, 45, 100, 114, 111, 112, 0, 0, 4, 103, 114, 97, 98, 0, 0, 8, 103, 114, 97, 98, 98, 105, 110, 103, 0, 0, 10, 97, 108, 108, 45, 115, 99, 114, 111, 108, 108, 0, 0, 7, 122, 111, 111, 109, 45, 105, 110, 0, 0, 8, 122, 111, 111, 109, 45, 111, 117, 116, 0, 0, 8, 101, 45, 114, 101, 115, 105, 122, 101, 0, 0, 8, 110, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 110, 101, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 110, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 8, 115, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 115, 101, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 115, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 8, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 101, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 110, 115, 45, 114, 101, 115, 105, 122, 101, 0, 0, 11, 110, 101, 115, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 11, 110, 119, 115, 101, 45, 114, 101, 115, 105, 122, 101, 0, 0, 10, 99, 111, 108, 45, 114, 101, 115, 105, 122, 101, 0, 0, 10, 114, 111, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 4, 11, 99, 117, 114, 115, 111, 114, 45, 105, 99, 111, 110, 0, 3, 0, 12, 1, 64, 0, 0, 11, 4, 3, 103, 101, 116, 0, 1, 14, 4, 12, 103, 101, 116, 45, 112, 114, 101, 118, 105, 111, 117, 115, 0, 1, 14, 1, 64, 1, 4, 105, 99, 111, 110, 13, 1, 0, 4, 10, 115, 101, 116, 45, 99, 117, 114, 115, 111, 114, 0, 1, 15, 1, 64, 1, 7, 118, 105, 115, 105, 98, 108, 101, 127, 1, 0, 4, 18, 115, 101, 116, 45, 99, 117, 114, 115, 111, 114, 45, 118, 105, 115, 105, 98, 108, 101, 0, 1, 16, 1, 64, 1, 6, 108, 111, 99, 107, 101, 100, 127, 1, 0, 4, 15, 115, 101, 116, 45, 99, 117, 114, 115, 111, 114, 45, 108, 111, 99, 107, 0, 1, 17, 4, 12, 99, 108, 105, 101, 110, 116, 45, 105, 110, 112, 117, 116, 30, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 105, 110, 112, 117, 116, 47, 99, 108, 105, 101, 110, 116, 45, 105, 110, 112, 117, 116, 5, 3, 11, 35, 1, 12, 99, 108, 105, 101, 110, 116, 45, 105, 110, 112, 117, 116, 17, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 105, 110, 112, 117, 116, 3, 34, 0, 7, 248, 4, 1, 65, 8, 1, 66, 22, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 111, 2, 119, 119, 4, 4, 117, 108, 105, 100, 0, 3, 0, 12, 1, 114, 2, 6, 111, 114, 105, 103, 105, 110, 3, 3, 100, 105, 114, 3, 4, 3, 114, 97, 121, 0, 3, 0, 14, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 16, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 18, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 20, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 4, 118, 101, 99, 51, 2, 3, 0, 0, 4, 118, 101, 99, 50, 2, 3, 0, 0, 3, 114, 97, 121, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 66, 16, 2, 3, 2, 1, 1, 4, 4, 118, 101, 99, 51, 0, 3, 0, 0, 2, 3, 2, 1, 2, 4, 4, 118, 101, 99, 50, 0, 3, 0, 2, 2, 3, 2, 1, 3, 4, 3, 114, 97, 121, 0, 3, 0, 4, 2, 3, 2, 1, 4, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 6, 1, 64, 2, 6, 99, 97, 109, 101, 114, 97, 7, 14, 99, 108, 105, 112, 45, 115, 112, 97, 99, 101, 45, 112, 111, 115, 3, 0, 5, 4, 14, 99, 108, 105, 112, 45, 115, 112, 97, 99, 101, 45, 114, 97, 121, 0, 1, 8, 1, 64, 1, 10, 115, 99, 114, 101, 101, 110, 45, 112, 111, 115, 3, 0, 3, 4, 20, 115, 99, 114, 101, 101, 110, 45, 116, 111, 45, 99, 108, 105, 112, 45, 115, 112, 97, 99, 101, 0, 1, 9, 1, 64, 2, 6, 99, 97, 109, 101, 114, 97, 7, 10, 115, 99, 114, 101, 101, 110, 45, 112, 111, 115, 3, 0, 5, 4, 25, 115, 99, 114, 101, 101, 110, 45, 116, 111, 45, 119, 111, 114, 108, 100, 45, 100, 105, 114, 101, 99, 116, 105, 111, 110, 0, 1, 10, 1, 64, 2, 6, 99, 97, 109, 101, 114, 97, 7, 10, 115, 99, 114, 101, 101, 110, 45, 112, 111, 115, 1, 0, 3, 4, 15, 119, 111, 114, 108, 100, 45, 116, 111, 45, 115, 99, 114, 101, 101, 110, 0, 1, 11, 4, 13, 99, 108, 105, 101, 110, 116, 45, 99, 97, 109, 101, 114, 97, 32, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 99, 97, 109, 101, 114, 97, 47, 99, 108, 105, 101, 110, 116, 45, 99, 97, 109, 101, 114, 97, 5, 5, 11, 37, 1, 13, 99, 108, 105, 101, 110, 116, 45, 99, 97, 109, 101, 114, 97, 18, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 99, 97, 109, 101, 114, 97, 3, 36, 0, 7, 193, 1, 1, 65, 2, 1, 66, 10, 1, 64, 1, 3, 117, 114, 108, 115, 1, 0, 4, 4, 108, 111, 97, 100, 0, 1, 0, 1, 64, 4, 4, 110, 97, 109, 101, 115, 7, 108, 111, 111, 112, 105, 110, 103, 127, 6, 118, 111, 108, 117, 109, 101, 118, 3, 117, 105, 100, 121, 1, 0, 4, 4, 112, 108, 97, 121, 0, 1, 1, 1, 64, 1, 4, 110, 97, 109, 101, 115, 1, 0, 4, 4, 115, 116, 111, 112, 0, 1, 2, 1, 64, 1, 3, 117, 105, 100, 121, 1, 0, 4, 10, 115, 116, 111, 112, 45, 98, 121, 45, 105, 100, 0, 1, 3, 1, 64, 2, 4, 110, 97, 109, 101, 115, 6, 118, 111, 108, 117, 109, 101, 118, 1, 0, 4, 10, 115, 101, 116, 45, 118, 111, 108, 117, 109, 101, 0, 1, 4, 4, 12, 99, 108, 105, 101, 110, 116, 45, 97, 117, 100, 105, 111, 30, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 97, 117, 100, 105, 111, 47, 99, 108, 105, 101, 110, 116, 45, 97, 117, 100, 105, 111, 5, 0, 11, 35, 1, 12, 99, 108, 105, 101, 110, 116, 45, 97, 117, 100, 105, 111, 17, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 97, 117, 100, 105, 111, 3, 38, 0, 7, 185, 2, 1, 65, 2, 1, 66, 15, 1, 113, 1, 11, 105, 110, 118, 97, 108, 105, 100, 45, 117, 114, 108, 1, 115, 0, 4, 9, 117, 114, 108, 45, 101, 114, 114, 111, 114, 0, 3, 0, 0, 1, 113, 3, 5, 114, 101, 97, 100, 121, 0, 0, 10, 110, 111, 116, 45, 108, 111, 97, 100, 101, 100, 0, 0, 14, 102, 97, 105, 108, 101, 100, 45, 108, 111, 97, 100, 105, 110, 103, 1, 115, 0, 4, 18, 97, 115, 115, 101, 116, 45, 99, 97, 99, 104, 101, 45, 115, 116, 97, 116, 117, 115, 0, 3, 0, 2, 1, 112, 115, 1, 114, 3, 7, 98, 105, 110, 100, 101, 114, 115, 4, 8, 100, 117, 114, 97, 116, 105, 111, 110, 118, 6, 115, 116, 97, 116, 117, 115, 3, 4, 24, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 97, 115, 115, 101, 116, 45, 109, 101, 116, 97, 100, 97, 116, 97, 0, 3, 0, 5, 1, 64, 1, 8, 99, 108, 105, 112, 45, 117, 114, 108, 115, 0, 3, 4, 26, 103, 101, 116, 45, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 97, 115, 115, 101, 116, 45, 115, 116, 97, 116, 117, 115, 0, 1, 7, 1, 112, 6, 1, 64, 1, 5, 99, 108, 105, 112, 115, 4, 0, 8, 4, 28, 103, 101, 116, 45, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 97, 115, 115, 101, 116, 45, 109, 101, 116, 97, 100, 97, 116, 97, 0, 1, 9, 1, 106, 1, 115, 1, 1, 1, 64, 1, 4, 112, 97, 116, 104, 115, 0, 10, 4, 3, 117, 114, 108, 0, 1, 11, 4, 5, 97, 115, 115, 101, 116, 16, 112, 107, 103, 58, 47, 97, 115, 115, 101, 116, 47, 97, 115, 115, 101, 116, 5, 0, 11, 21, 1, 5, 97, 115, 115, 101, 116, 10, 112, 107, 103, 58, 47, 97, 115, 115, 101, 116, 3, 40, 0, 7, 220, 79, 1, 65, 2, 1, 65, 56, 1, 66, 22, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 111, 2, 119, 119, 4, 4, 117, 108, 105, 100, 0, 3, 0, 12, 1, 114, 2, 6, 111, 114, 105, 103, 105, 110, 3, 3, 100, 105, 114, 3, 4, 3, 114, 97, 121, 0, 3, 0, 14, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 16, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 18, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 20, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 1, 66, 15, 1, 113, 1, 11, 105, 110, 118, 97, 108, 105, 100, 45, 117, 114, 108, 1, 115, 0, 4, 9, 117, 114, 108, 45, 101, 114, 114, 111, 114, 0, 3, 0, 0, 1, 113, 3, 5, 114, 101, 97, 100, 121, 0, 0, 10, 110, 111, 116, 45, 108, 111, 97, 100, 101, 100, 0, 0, 14, 102, 97, 105, 108, 101, 100, 45, 108, 111, 97, 100, 105, 110, 103, 1, 115, 0, 4, 18, 97, 115, 115, 101, 116, 45, 99, 97, 99, 104, 101, 45, 115, 116, 97, 116, 117, 115, 0, 3, 0, 2, 1, 112, 115, 1, 114, 3, 7, 98, 105, 110, 100, 101, 114, 115, 4, 8, 100, 117, 114, 97, 116, 105, 111, 110, 118, 6, 115, 116, 97, 116, 117, 115, 3, 4, 24, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 97, 115, 115, 101, 116, 45, 109, 101, 116, 97, 100, 97, 116, 97, 0, 3, 0, 5, 1, 64, 1, 8, 99, 108, 105, 112, 45, 117, 114, 108, 115, 0, 3, 4, 26, 103, 101, 116, 45, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 97, 115, 115, 101, 116, 45, 115, 116, 97, 116, 117, 115, 0, 1, 7, 1, 112, 6, 1, 64, 1, 5, 99, 108, 105, 112, 115, 4, 0, 8, 4, 28, 103, 101, 116, 45, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 97, 115, 115, 101, 116, 45, 109, 101, 116, 97, 100, 97, 116, 97, 0, 1, 9, 1, 106, 1, 115, 1, 1, 1, 64, 1, 4, 112, 97, 116, 104, 115, 0, 10, 4, 3, 117, 114, 108, 0, 1, 11, 3, 5, 97, 115, 115, 101, 116, 16, 112, 107, 103, 58, 47, 97, 115, 115, 101, 116, 47, 97, 115, 115, 101, 116, 5, 1, 2, 3, 0, 0, 4, 118, 101, 99, 50, 2, 3, 0, 0, 4, 118, 101, 99, 51, 2, 3, 0, 0, 4, 117, 108, 105, 100, 1, 66, 18, 2, 3, 2, 1, 2, 4, 4, 118, 101, 99, 50, 0, 3, 0, 0, 2, 3, 2, 1, 3, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 2, 3, 2, 1, 4, 4, 4, 117, 108, 105, 100, 0, 3, 0, 4, 1, 114, 4, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 6, 110, 111, 114, 109, 97, 108, 3, 7, 116, 97, 110, 103, 101, 110, 116, 3, 9, 116, 101, 120, 99, 111, 111, 114, 100, 48, 1, 4, 6, 118, 101, 114, 116, 101, 120, 0, 3, 0, 6, 1, 114, 1, 4, 117, 108, 105, 100, 5, 4, 6, 104, 97, 110, 100, 108, 101, 0, 3, 0, 8, 1, 112, 7, 1, 112, 121, 1, 114, 2, 8, 118, 101, 114, 116, 105, 99, 101, 115, 10, 7, 105, 110, 100, 105, 99, 101, 115, 11, 4, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 0, 3, 0, 12, 1, 64, 1, 4, 100, 101, 115, 99, 13, 0, 9, 4, 6, 99, 114, 101, 97, 116, 101, 0, 1, 14, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 9, 1, 0, 4, 7, 100, 101, 115, 116, 114, 111, 121, 0, 1, 15, 3, 11, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 104, 28, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 104, 47, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 104, 5, 5, 1, 66, 13, 2, 3, 2, 1, 4, 4, 4, 117, 108, 105, 100, 0, 3, 0, 0, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 6, 104, 97, 110, 100, 108, 101, 0, 3, 0, 2, 1, 113, 42, 8, 114, 56, 45, 117, 110, 111, 114, 109, 0, 0, 8, 114, 56, 45, 115, 110, 111, 114, 109, 0, 0, 7, 114, 56, 45, 117, 105, 110, 116, 0, 0, 7, 114, 56, 45, 115, 105, 110, 116, 0, 0, 8, 114, 49, 54, 45, 117, 105, 110, 116, 0, 0, 8, 114, 49, 54, 45, 115, 105, 110, 116, 0, 0, 9, 114, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 9, 114, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 9, 114, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 56, 45, 117, 110, 111, 114, 109, 0, 0, 9, 114, 103, 56, 45, 115, 110, 111, 114, 109, 0, 0, 8, 114, 103, 56, 45, 117, 105, 110, 116, 0, 0, 8, 114, 103, 56, 45, 115, 105, 110, 116, 0, 0, 8, 114, 51, 50, 45, 117, 105, 110, 116, 0, 0, 8, 114, 51, 50, 45, 115, 105, 110, 116, 0, 0, 9, 114, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 49, 54, 45, 117, 105, 110, 116, 0, 0, 9, 114, 103, 49, 54, 45, 115, 105, 110, 116, 0, 0, 10, 114, 103, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 10, 114, 103, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 10, 114, 103, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 56, 45, 117, 110, 111, 114, 109, 0, 0, 16, 114, 103, 98, 97, 56, 45, 117, 110, 111, 114, 109, 45, 115, 114, 103, 98, 0, 0, 11, 114, 103, 98, 97, 56, 45, 115, 110, 111, 114, 109, 0, 0, 10, 114, 103, 98, 97, 56, 45, 117, 105, 110, 116, 0, 0, 10, 114, 103, 98, 97, 56, 45, 115, 105, 110, 116, 0, 0, 11, 98, 103, 114, 97, 56, 45, 117, 110, 111, 114, 109, 0, 0, 16, 98, 103, 114, 97, 56, 45, 117, 110, 111, 114, 109, 45, 115, 114, 103, 98, 0, 0, 13, 114, 103, 98, 57, 101, 53, 45, 117, 102, 108, 111, 97, 116, 0, 0, 13, 114, 103, 98, 49, 48, 97, 50, 45, 117, 110, 111, 114, 109, 0, 0, 13, 114, 103, 49, 49, 98, 49, 48, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 51, 50, 45, 117, 105, 110, 116, 0, 0, 9, 114, 103, 51, 50, 45, 115, 105, 110, 116, 0, 0, 10, 114, 103, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 49, 54, 45, 117, 105, 110, 116, 0, 0, 11, 114, 103, 98, 97, 49, 54, 45, 115, 105, 110, 116, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 51, 50, 45, 117, 105, 110, 116, 0, 0, 11, 114, 103, 98, 97, 51, 50, 45, 115, 105, 110, 116, 0, 0, 12, 114, 103, 98, 97, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 4, 6, 102, 111, 114, 109, 97, 116, 0, 3, 0, 4, 1, 112, 125, 1, 114, 4, 5, 119, 105, 100, 116, 104, 121, 6, 104, 101, 105, 103, 104, 116, 121, 6, 102, 111, 114, 109, 97, 116, 5, 4, 100, 97, 116, 97, 6, 4, 12, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 50, 100, 0, 3, 0, 7, 1, 64, 1, 4, 100, 101, 115, 99, 8, 0, 3, 4, 8, 99, 114, 101, 97, 116, 101, 50, 100, 0, 1, 9, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 3, 1, 0, 4, 7, 100, 101, 115, 116, 114, 111, 121, 0, 1, 10, 3, 14, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 34, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 47, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 5, 6, 1, 66, 14, 2, 3, 2, 1, 4, 4, 4, 117, 108, 105, 100, 0, 3, 0, 0, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 6, 104, 97, 110, 100, 108, 101, 0, 3, 0, 2, 1, 113, 2, 7, 110, 101, 97, 114, 101, 115, 116, 0, 0, 6, 108, 105, 110, 101, 97, 114, 0, 0, 4, 11, 102, 105, 108, 116, 101, 114, 45, 109, 111, 100, 101, 0, 3, 0, 4, 1, 113, 3, 13, 99, 108, 97, 109, 112, 45, 116, 111, 45, 101, 100, 103, 101, 0, 0, 6, 114, 101, 112, 101, 97, 116, 0, 0, 13, 109, 105, 114, 114, 111, 114, 45, 114, 101, 112, 101, 97, 116, 0, 0, 4, 12, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 0, 3, 0, 6, 1, 114, 6, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 117, 7, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 118, 7, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 119, 7, 10, 109, 97, 103, 45, 102, 105, 108, 116, 101, 114, 5, 10, 109, 105, 110, 45, 102, 105, 108, 116, 101, 114, 5, 13, 109, 105, 112, 109, 97, 112, 45, 102, 105, 108, 116, 101, 114, 5, 4, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 0, 3, 0, 8, 1, 64, 1, 4, 100, 101, 115, 99, 9, 0, 3, 4, 6, 99, 114, 101, 97, 116, 101, 0, 1, 10, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 3, 1, 0, 4, 7, 100, 101, 115, 116, 114, 111, 121, 0, 1, 11, 3, 14, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 34, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 47, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 5, 7, 2, 3, 0, 3, 6, 104, 97, 110, 100, 108, 101, 2, 3, 0, 4, 6, 104, 97, 110, 100, 108, 101, 1, 66, 14, 2, 3, 2, 1, 4, 4, 4, 117, 108, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 8, 4, 14, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 2, 2, 3, 2, 1, 9, 4, 14, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 4, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 6, 104, 97, 110, 100, 108, 101, 0, 3, 0, 6, 1, 114, 5, 14, 98, 97, 115, 101, 45, 99, 111, 108, 111, 114, 45, 109, 97, 112, 3, 10, 110, 111, 114, 109, 97, 108, 45, 109, 97, 112, 3, 22, 109, 101, 116, 97, 108, 108, 105, 99, 45, 114, 111, 117, 103, 104, 110, 101, 115, 115, 45, 109, 97, 112, 3, 7, 115, 97, 109, 112, 108, 101, 114, 5, 11, 116, 114, 97, 110, 115, 112, 97, 114, 101, 110, 116, 127, 4, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 0, 3, 0, 8, 1, 64, 1, 4, 100, 101, 115, 99, 9, 0, 7, 4, 6, 99, 114, 101, 97, 116, 101, 0, 1, 10, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 7, 1, 0, 4, 7, 100, 101, 115, 116, 114, 111, 121, 0, 1, 11, 3, 15, 99, 108, 105, 101, 110, 116, 45, 109, 97, 116, 101, 114, 105, 97, 108, 36, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 109, 97, 116, 101, 114, 105, 97, 108, 47, 99, 108, 105, 101, 110, 116, 45, 109, 97, 116, 101, 114, 105, 97, 108, 5, 10, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 2, 3, 0, 0, 4, 109, 97, 116, 52, 2, 3, 0, 0, 4, 113, 117, 97, 116, 2, 3, 0, 0, 4, 118, 101, 99, 52, 2, 3, 0, 0, 5, 117, 118, 101, 99, 50, 2, 3, 0, 0, 5, 117, 118, 101, 99, 51, 2, 3, 0, 0, 5, 117, 118, 101, 99, 52, 2, 3, 0, 2, 6, 104, 97, 110, 100, 108, 101, 2, 3, 0, 5, 6, 104, 97, 110, 100, 108, 101, 1, 66, 110, 2, 3, 2, 1, 11, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 12, 4, 4, 109, 97, 116, 52, 0, 3, 0, 2, 2, 3, 2, 1, 13, 4, 4, 113, 117, 97, 116, 0, 3, 0, 4, 2, 3, 2, 1, 2, 4, 4, 118, 101, 99, 50, 0, 3, 0, 6, 2, 3, 2, 1, 3, 4, 4, 118, 101, 99, 51, 0, 3, 0, 8, 2, 3, 2, 1, 14, 4, 4, 118, 101, 99, 52, 0, 3, 0, 10, 2, 3, 2, 1, 15, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 12, 2, 3, 2, 1, 16, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 14, 2, 3, 2, 1, 17, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 16, 2, 3, 2, 1, 18, 4, 22, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 18, 2, 3, 2, 1, 8, 4, 25, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 20, 2, 3, 2, 1, 9, 4, 25, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 22, 2, 3, 2, 1, 19, 4, 26, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 0, 3, 0, 24, 1, 109, 3, 5, 102, 114, 97, 109, 101, 5, 115, 112, 97, 119, 110, 7, 100, 101, 115, 112, 97, 119, 110, 4, 11, 113, 117, 101, 114, 121, 45, 101, 118, 101, 110, 116, 0, 3, 0, 26, 1, 112, 121, 1, 114, 4, 10, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 28, 7, 105, 110, 99, 108, 117, 100, 101, 28, 7, 101, 120, 99, 108, 117, 100, 101, 28, 7, 99, 104, 97, 110, 103, 101, 100, 28, 4, 11, 113, 117, 101, 114, 121, 45, 98, 117, 105, 108, 100, 0, 3, 0, 29, 1, 111, 0, 1, 112, 31, 1, 112, 127, 1, 112, 1, 1, 112, 118, 1, 112, 117, 1, 112, 3, 1, 112, 122, 1, 112, 5, 1, 112, 115, 1, 112, 125, 1, 112, 119, 1, 112, 7, 1, 112, 9, 1, 112, 11, 1, 112, 13, 1, 112, 15, 1, 112, 17, 1, 112, 19, 1, 112, 21, 1, 112, 23, 1, 112, 25, 1, 113, 22, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 32, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 33, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 34, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 35, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 36, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 37, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 38, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 39, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 40, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 41, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 28, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 42, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 43, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 44, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 45, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 46, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 47, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 48, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 49, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 50, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 51, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 52, 0, 4, 9, 118, 101, 99, 45, 118, 97, 108, 117, 101, 0, 3, 0, 53, 1, 107, 31, 1, 107, 127, 1, 107, 1, 1, 107, 118, 1, 107, 117, 1, 107, 3, 1, 107, 122, 1, 107, 5, 1, 107, 115, 1, 107, 125, 1, 107, 121, 1, 107, 119, 1, 107, 7, 1, 107, 9, 1, 107, 11, 1, 107, 13, 1, 107, 15, 1, 107, 17, 1, 107, 19, 1, 107, 21, 1, 107, 23, 1, 107, 25, 1, 113, 22, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 55, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 56, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 57, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 58, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 59, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 60, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 61, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 62, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 63, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 192, 0, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 193, 0, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 194, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 195, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 196, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 197, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 198, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 199, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 200, 0, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 201, 0, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 202, 0, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 203, 0, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 204, 0, 0, 4, 12, 111, 112, 116, 105, 111, 110, 45, 118, 97, 108, 117, 101, 0, 3, 0, 77, 1, 113, 24, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 31, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 127, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 1, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 118, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 117, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 3, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 122, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 5, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 115, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 125, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 121, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 119, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 7, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 9, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 11, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 13, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 15, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 17, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 19, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 21, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 23, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 25, 0, 8, 116, 121, 112, 101, 45, 118, 101, 99, 1, 54, 0, 11, 116, 121, 112, 101, 45, 111, 112, 116, 105, 111, 110, 1, 206, 0, 0, 4, 5, 118, 97, 108, 117, 101, 0, 3, 0, 79, 1, 111, 2, 121, 208, 0, 1, 112, 209, 0, 4, 6, 101, 110, 116, 105, 116, 121, 0, 3, 0, 82, 1, 64, 1, 2, 105, 100, 115, 0, 193, 0, 4, 9, 103, 101, 116, 45, 105, 110, 100, 101, 120, 0, 1, 84, 1, 107, 208, 0, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 0, 213, 0, 4, 13, 103, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 86, 1, 64, 3, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 5, 118, 97, 108, 117, 101, 208, 0, 1, 0, 4, 13, 97, 100, 100, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 87, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 4, 100, 97, 116, 97, 211, 0, 1, 0, 4, 14, 97, 100, 100, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 0, 1, 88, 4, 13, 115, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 87, 4, 14, 115, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 0, 1, 88, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 0, 127, 4, 13, 104, 97, 115, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 89, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 110, 100, 105, 99, 101, 115, 28, 0, 127, 4, 14, 104, 97, 115, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 0, 1, 90, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 1, 0, 4, 16, 114, 101, 109, 111, 118, 101, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 91, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 110, 100, 105, 99, 101, 115, 28, 1, 0, 4, 17, 114, 101, 109, 111, 118, 101, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 0, 1, 92, 1, 64, 2, 1, 113, 30, 1, 116, 27, 0, 119, 4, 5, 113, 117, 101, 114, 121, 0, 1, 93, 1, 112, 208, 0, 1, 111, 2, 1, 222, 0, 1, 112, 223, 0, 1, 64, 1, 1, 113, 119, 0, 224, 0, 4, 10, 113, 117, 101, 114, 121, 45, 101, 118, 97, 108, 0, 1, 97, 3, 9, 99, 111, 109, 112, 111, 110, 101, 110, 116, 24, 112, 107, 103, 58, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 5, 20, 2, 3, 0, 6, 6, 101, 110, 116, 105, 116, 121, 1, 66, 59, 2, 3, 2, 1, 11, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 3, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 2, 3, 2, 1, 13, 4, 4, 113, 117, 97, 116, 0, 3, 0, 4, 2, 3, 2, 1, 12, 4, 4, 109, 97, 116, 52, 0, 3, 0, 6, 2, 3, 2, 1, 21, 4, 11, 101, 110, 116, 105, 116, 121, 45, 100, 97, 116, 97, 0, 3, 0, 8, 1, 114, 2, 6, 119, 101, 105, 103, 104, 116, 118, 4, 109, 97, 115, 107, 121, 4, 21, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 115, 116, 97, 99, 107, 45, 98, 108, 101, 110, 100, 0, 3, 0, 10, 1, 114, 2, 12, 97, 99, 116, 105, 111, 110, 45, 105, 110, 100, 101, 120, 121, 15, 116, 105, 109, 101, 45, 112, 101, 114, 99, 101, 110, 116, 97, 103, 101, 118, 4, 27, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 115, 97, 109, 112, 108, 101, 45, 112, 101, 114, 99, 101, 110, 116, 97, 103, 101, 0, 3, 0, 12, 1, 114, 2, 12, 97, 99, 116, 105, 111, 110, 45, 105, 110, 100, 101, 120, 121, 13, 116, 105, 109, 101, 45, 97, 98, 115, 111, 108, 117, 116, 101, 118, 4, 25, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 115, 97, 109, 112, 108, 101, 45, 97, 98, 115, 111, 108, 117, 116, 101, 0, 3, 0, 14, 1, 113, 5, 6, 115, 97, 109, 112, 108, 101, 1, 121, 0, 17, 115, 97, 109, 112, 108, 101, 45, 112, 101, 114, 99, 101, 110, 116, 97, 103, 101, 1, 13, 0, 15, 115, 97, 109, 112, 108, 101, 45, 97, 98, 115, 111, 108, 117, 116, 101, 1, 15, 0, 11, 105, 110, 116, 101, 114, 112, 111, 108, 97, 116, 101, 1, 118, 0, 5, 98, 108, 101, 110, 100, 1, 11, 0, 4, 22, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 97, 99, 116, 105, 111, 110, 45, 115, 116, 97, 99, 107, 0, 3, 0, 16, 1, 114, 3, 8, 99, 108, 105, 112, 45, 117, 114, 108, 115, 7, 108, 111, 111, 112, 105, 110, 103, 127, 6, 119, 101, 105, 103, 104, 116, 118, 4, 16, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 97, 99, 116, 105, 111, 110, 0, 3, 0, 18, 1, 112, 19, 1, 114, 2, 7, 97, 99, 116, 105, 111, 110, 115, 20, 15, 97, 112, 112, 108, 121, 45, 98, 97, 115, 101, 45, 112, 111, 115, 101, 127, 4, 20, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 99, 111, 110, 116, 114, 111, 108, 108, 101, 114, 0, 3, 0, 21, 1, 112, 17, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 115, 116, 97, 99, 107, 23, 1, 0, 4, 26, 115, 101, 116, 45, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 97, 99, 116, 105, 111, 110, 45, 115, 116, 97, 99, 107, 0, 1, 24, 1, 112, 115, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 4, 109, 97, 115, 107, 25, 1, 0, 4, 25, 115, 101, 116, 45, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 98, 105, 110, 100, 101, 114, 45, 109, 97, 115, 107, 0, 1, 26, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 0, 25, 4, 25, 103, 101, 116, 45, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 98, 105, 110, 100, 101, 114, 45, 109, 97, 115, 107, 0, 1, 27, 1, 112, 118, 1, 64, 3, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 4, 109, 97, 115, 107, 28, 1, 0, 4, 28, 115, 101, 116, 45, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 98, 105, 110, 100, 101, 114, 45, 119, 101, 105, 103, 104, 116, 115, 0, 1, 29, 1, 112, 1, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 0, 30, 4, 34, 103, 101, 116, 45, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 98, 105, 110, 100, 101, 114, 45, 109, 97, 115, 107, 45, 101, 110, 116, 105, 116, 105, 101, 115, 0, 1, 31, 1, 64, 4, 6, 101, 110, 116, 105, 116, 121, 1, 7, 119, 101, 105, 103, 104, 116, 115, 28, 4, 116, 105, 109, 101, 28, 13, 97, 98, 115, 111, 108, 117, 116, 101, 45, 116, 105, 109, 101, 127, 1, 0, 4, 19, 115, 101, 116, 45, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 98, 108, 101, 110, 100, 0, 1, 32, 1, 112, 7, 1, 64, 2, 8, 101, 110, 116, 105, 116, 105, 101, 115, 30, 6, 111, 114, 105, 103, 105, 110, 1, 0, 33, 4, 26, 103, 101, 116, 45, 116, 114, 97, 110, 115, 102, 111, 114, 109, 115, 45, 114, 101, 108, 97, 116, 105, 118, 101, 45, 116, 111, 0, 1, 34, 1, 64, 1, 4, 100, 97, 116, 97, 9, 0, 1, 4, 5, 115, 112, 97, 119, 110, 0, 1, 35, 1, 107, 9, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 0, 36, 4, 7, 100, 101, 115, 112, 97, 119, 110, 0, 1, 37, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 20, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 99, 111, 110, 116, 114, 111, 108, 108, 101, 114, 22, 1, 0, 4, 24, 115, 101, 116, 45, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 99, 111, 110, 116, 114, 111, 108, 108, 101, 114, 0, 1, 38, 1, 64, 2, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 6, 114, 97, 100, 105, 117, 115, 118, 0, 30, 4, 7, 105, 110, 45, 97, 114, 101, 97, 0, 1, 39, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 0, 127, 4, 6, 101, 120, 105, 115, 116, 115, 0, 1, 40, 1, 64, 1, 5, 105, 110, 100, 101, 120, 121, 0, 30, 4, 7, 103, 101, 116, 45, 97, 108, 108, 0, 1, 41, 1, 64, 0, 0, 1, 4, 9, 114, 101, 115, 111, 117, 114, 99, 101, 115, 0, 1, 42, 4, 22, 115, 121, 110, 99, 104, 114, 111, 110, 105, 122, 101, 100, 45, 114, 101, 115, 111, 117, 114, 99, 101, 115, 0, 1, 42, 4, 19, 112, 101, 114, 115, 105, 115, 116, 101, 100, 45, 114, 101, 115, 111, 117, 114, 99, 101, 115, 0, 1, 42, 3, 6, 101, 110, 116, 105, 116, 121, 18, 112, 107, 103, 58, 47, 101, 110, 116, 105, 116, 121, 47, 101, 110, 116, 105, 116, 121, 5, 22, 1, 66, 4, 2, 3, 2, 1, 21, 4, 6, 101, 110, 116, 105, 116, 121, 0, 3, 0, 0, 1, 64, 1, 4, 110, 97, 109, 101, 115, 1, 0, 4, 9, 115, 117, 98, 115, 99, 114, 105, 98, 101, 0, 1, 2, 3, 7, 109, 101, 115, 115, 97, 103, 101, 18, 112, 107, 103, 58, 47, 109, 101, 115, 115, 97, 103, 101, 47, 101, 118, 101, 110, 116, 5, 23, 1, 66, 5, 2, 3, 2, 1, 11, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 1, 107, 1, 1, 64, 1, 7, 117, 115, 101, 114, 45, 105, 100, 115, 0, 2, 4, 14, 103, 101, 116, 45, 98, 121, 45, 117, 115, 101, 114, 45, 105, 100, 0, 1, 3, 3, 6, 112, 108, 97, 121, 101, 114, 18, 112, 107, 103, 58, 47, 112, 108, 97, 121, 101, 114, 47, 112, 108, 97, 121, 101, 114, 5, 24, 1, 66, 11, 2, 3, 2, 1, 11, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 3, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 2, 3, 2, 1, 13, 4, 4, 113, 117, 97, 116, 0, 3, 0, 4, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 1, 0, 4, 12, 115, 101, 116, 45, 108, 105, 115, 116, 101, 110, 101, 114, 0, 1, 6, 4, 11, 115, 101, 116, 45, 101, 109, 105, 116, 116, 101, 114, 0, 1, 6, 1, 64, 2, 5, 115, 111, 117, 110, 100, 115, 7, 101, 109, 105, 116, 116, 101, 114, 1, 1, 0, 4, 20, 112, 108, 97, 121, 45, 115, 111, 117, 110, 100, 45, 111, 110, 45, 101, 110, 116, 105, 116, 121, 0, 1, 7, 3, 11, 119, 111, 114, 108, 100, 45, 97, 117, 100, 105, 111, 28, 112, 107, 103, 58, 47, 119, 111, 114, 108, 100, 45, 97, 117, 100, 105, 111, 47, 119, 111, 114, 108, 100, 45, 97, 117, 100, 105, 111, 5, 25, 1, 66, 10, 1, 64, 1, 3, 117, 114, 108, 115, 1, 0, 4, 4, 108, 111, 97, 100, 0, 1, 0, 1, 64, 4, 4, 110, 97, 109, 101, 115, 7, 108, 111, 111, 112, 105, 110, 103, 127, 6, 118, 111, 108, 117, 109, 101, 118, 3, 117, 105, 100, 121, 1, 0, 4, 4, 112, 108, 97, 121, 0, 1, 1, 1, 64, 1, 4, 110, 97, 109, 101, 115, 1, 0, 4, 4, 115, 116, 111, 112, 0, 1, 2, 1, 64, 1, 3, 117, 105, 100, 121, 1, 0, 4, 10, 115, 116, 111, 112, 45, 98, 121, 45, 105, 100, 0, 1, 3, 1, 64, 2, 4, 110, 97, 109, 101, 115, 6, 118, 111, 108, 117, 109, 101, 118, 1, 0, 4, 10, 115, 101, 116, 45, 118, 111, 108, 117, 109, 101, 0, 1, 4, 3, 12, 99, 108, 105, 101, 110, 116, 45, 97, 117, 100, 105, 111, 30, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 97, 117, 100, 105, 111, 47, 99, 108, 105, 101, 110, 116, 45, 97, 117, 100, 105, 111, 5, 26, 1, 66, 7, 2, 3, 2, 1, 11, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 1, 113, 4, 17, 115, 101, 114, 118, 101, 114, 45, 117, 110, 114, 101, 108, 105, 97, 98, 108, 101, 0, 0, 15, 115, 101, 114, 118, 101, 114, 45, 114, 101, 108, 105, 97, 98, 108, 101, 0, 0, 15, 108, 111, 99, 97, 108, 45, 98, 114, 111, 97, 100, 99, 97, 115, 116, 0, 0, 5, 108, 111, 99, 97, 108, 1, 1, 0, 4, 6, 116, 97, 114, 103, 101, 116, 0, 3, 0, 2, 1, 112, 125, 1, 64, 3, 9, 116, 97, 114, 103, 101, 116, 45, 105, 100, 3, 4, 110, 97, 109, 101, 115, 4, 100, 97, 116, 97, 4, 1, 0, 4, 4, 115, 101, 110, 100, 0, 1, 5, 3, 14, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 115, 97, 103, 101, 34, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 115, 97, 103, 101, 47, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 115, 97, 103, 101, 5, 27, 1, 66, 4, 2, 3, 2, 1, 11, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 1, 64, 0, 0, 1, 4, 9, 103, 101, 116, 45, 108, 111, 99, 97, 108, 0, 1, 2, 3, 13, 99, 108, 105, 101, 110, 116, 45, 112, 108, 97, 121, 101, 114, 32, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 112, 108, 97, 121, 101, 114, 47, 99, 108, 105, 101, 110, 116, 45, 112, 108, 97, 121, 101, 114, 5, 28, 1, 66, 23, 2, 3, 2, 1, 2, 4, 4, 118, 101, 99, 50, 0, 3, 0, 0, 2, 3, 2, 1, 11, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 2, 1, 109, 163, 1, 4, 107, 101, 121, 49, 4, 107, 101, 121, 50, 4, 107, 101, 121, 51, 4, 107, 101, 121, 52, 4, 107, 101, 121, 53, 4, 107, 101, 121, 54, 4, 107, 101, 121, 55, 4, 107, 101, 121, 56, 4, 107, 101, 121, 57, 4, 107, 101, 121, 48, 1, 97, 1, 98, 1, 99, 1, 100, 1, 101, 1, 102, 1, 103, 1, 104, 1, 105, 1, 106, 1, 107, 1, 108, 1, 109, 1, 110, 1, 111, 1, 112, 1, 113, 1, 114, 1, 115, 1, 116, 1, 117, 1, 118, 1, 119, 1, 120, 1, 121, 1, 122, 6, 101, 115, 99, 97, 112, 101, 2, 102, 49, 2, 102, 50, 2, 102, 51, 2, 102, 52, 2, 102, 53, 2, 102, 54, 2, 102, 55, 2, 102, 56, 2, 102, 57, 3, 102, 49, 48, 3, 102, 49, 49, 3, 102, 49, 50, 3, 102, 49, 51, 3, 102, 49, 52, 3, 102, 49, 53, 3, 102, 49, 54, 3, 102, 49, 55, 3, 102, 49, 56, 3, 102, 49, 57, 3, 102, 50, 48, 3, 102, 50, 49, 3, 102, 50, 50, 3, 102, 50, 51, 3, 102, 50, 52, 8, 115, 110, 97, 112, 115, 104, 111, 116, 6, 115, 99, 114, 111, 108, 108, 5, 112, 97, 117, 115, 101, 6, 105, 110, 115, 101, 114, 116, 4, 104, 111, 109, 101, 6, 100, 101, 108, 101, 116, 101, 3, 101, 110, 100, 9, 112, 97, 103, 101, 45, 100, 111, 119, 110, 7, 112, 97, 103, 101, 45, 117, 112, 4, 108, 101, 102, 116, 2, 117, 112, 5, 114, 105, 103, 104, 116, 4, 100, 111, 119, 110, 4, 98, 97, 99, 107, 6, 114, 101, 116, 117, 114, 110, 5, 115, 112, 97, 99, 101, 7, 99, 111, 109, 112, 111, 115, 101, 5, 99, 97, 114, 101, 116, 7, 110, 117, 109, 108, 111, 99, 107, 7, 110, 117, 109, 112, 97, 100, 48, 7, 110, 117, 109, 112, 97, 100, 49, 7, 110, 117, 109, 112, 97, 100, 50, 7, 110, 117, 109, 112, 97, 100, 51, 7, 110, 117, 109, 112, 97, 100, 52, 7, 110, 117, 109, 112, 97, 100, 53, 7, 110, 117, 109, 112, 97, 100, 54, 7, 110, 117, 109, 112, 97, 100, 55, 7, 110, 117, 109, 112, 97, 100, 56, 7, 110, 117, 109, 112, 97, 100, 57, 10, 110, 117, 109, 112, 97, 100, 45, 97, 100, 100, 13, 110, 117, 109, 112, 97, 100, 45, 100, 105, 118, 105, 100, 101, 14, 110, 117, 109, 112, 97, 100, 45, 100, 101, 99, 105, 109, 97, 108, 12, 110, 117, 109, 112, 97, 100, 45, 99, 111, 109, 109, 97, 12, 110, 117, 109, 112, 97, 100, 45, 101, 110, 116, 101, 114, 13, 110, 117, 109, 112, 97, 100, 45, 101, 113, 117, 97, 108, 115, 15, 110, 117, 109, 112, 97, 100, 45, 109, 117, 108, 116, 105, 112, 108, 121, 15, 110, 117, 109, 112, 97, 100, 45, 115, 117, 98, 116, 114, 97, 99, 116, 7, 97, 98, 110, 116, 45, 99, 49, 7, 97, 98, 110, 116, 45, 99, 50, 10, 97, 112, 111, 115, 116, 114, 111, 112, 104, 101, 4, 97, 112, 112, 115, 8, 97, 115, 116, 101, 114, 105, 115, 107, 2, 97, 116, 2, 97, 120, 9, 98, 97, 99, 107, 115, 108, 97, 115, 104, 10, 99, 97, 108, 99, 117, 108, 97, 116, 111, 114, 7, 99, 97, 112, 105, 116, 97, 108, 5, 99, 111, 108, 111, 110, 5, 99, 111, 109, 109, 97, 7, 99, 111, 110, 118, 101, 114, 116, 6, 101, 113, 117, 97, 108, 115, 5, 103, 114, 97, 118, 101, 4, 107, 97, 110, 97, 5, 107, 97, 110, 106, 105, 5, 108, 45, 97, 108, 116, 9, 108, 45, 98, 114, 97, 99, 107, 101, 116, 9, 108, 45, 99, 111, 110, 116, 114, 111, 108, 7, 108, 45, 115, 104, 105, 102, 116, 5, 108, 45, 119, 105, 110, 4, 109, 97, 105, 108, 12, 109, 101, 100, 105, 97, 45, 115, 101, 108, 101, 99, 116, 10, 109, 101, 100, 105, 97, 45, 115, 116, 111, 112, 5, 109, 105, 110, 117, 115, 4, 109, 117, 116, 101, 11, 109, 121, 45, 99, 111, 109, 112, 117, 116, 101, 114, 16, 110, 97, 118, 105, 103, 97, 116, 101, 45, 102, 111, 114, 119, 97, 114, 100, 17, 110, 97, 118, 105, 103, 97, 116, 101, 45, 98, 97, 99, 107, 119, 97, 114, 100, 10, 110, 101, 120, 116, 45, 116, 114, 97, 99, 107, 10, 110, 111, 45, 99, 111, 110, 118, 101, 114, 116, 6, 111, 101, 109, 49, 48, 50, 6, 112, 101, 114, 105, 111, 100, 10, 112, 108, 97, 121, 45, 112, 97, 117, 115, 101, 4, 112, 108, 117, 115, 5, 112, 111, 119, 101, 114, 10, 112, 114, 101, 118, 45, 116, 114, 97, 99, 107, 5, 114, 45, 97, 108, 116, 9, 114, 45, 98, 114, 97, 99, 107, 101, 116, 9, 114, 45, 99, 111, 110, 116, 114, 111, 108, 7, 114, 45, 115, 104, 105, 102, 116, 5, 114, 45, 119, 105, 110, 9, 115, 101, 109, 105, 99, 111, 108, 111, 110, 5, 115, 108, 97, 115, 104, 5, 115, 108, 101, 101, 112, 4, 115, 116, 111, 112, 5, 115, 121, 115, 114, 113, 3, 116, 97, 98, 9, 117, 110, 100, 101, 114, 108, 105, 110, 101, 9, 117, 110, 108, 97, 98, 101, 108, 101, 100, 11, 118, 111, 108, 117, 109, 101, 45, 100, 111, 119, 110, 9, 118, 111, 108, 117, 109, 101, 45, 117, 112, 4, 119, 97, 107, 101, 8, 119, 101, 98, 45, 98, 97, 99, 107, 13, 119, 101, 98, 45, 102, 97, 118, 111, 114, 105, 116, 101, 115, 11, 119, 101, 98, 45, 102, 111, 114, 119, 97, 114, 100, 8, 119, 101, 98, 45, 104, 111, 109, 101, 11, 119, 101, 98, 45, 114, 101, 102, 114, 101, 115, 104, 10, 119, 101, 98, 45, 115, 101, 97, 114, 99, 104, 8, 119, 101, 98, 45, 115, 116, 111, 112, 3, 121, 101, 110, 4, 99, 111, 112, 121, 5, 112, 97, 115, 116, 101, 3, 99, 117, 116, 4, 16, 118, 105, 114, 116, 117, 97, 108, 45, 107, 101, 121, 45, 99, 111, 100, 101, 0, 3, 0, 4, 1, 113, 4, 4, 108, 101, 102, 116, 0, 0, 5, 114, 105, 103, 104, 116, 0, 0, 6, 109, 105, 100, 100, 108, 101, 0, 0, 5, 111, 116, 104, 101, 114, 1, 123, 0, 4, 12, 109, 111, 117, 115, 101, 45, 98, 117, 116, 116, 111, 110, 0, 3, 0, 6, 1, 112, 5, 1, 112, 7, 1, 114, 5, 4, 107, 101, 121, 115, 8, 14, 109, 111, 117, 115, 101, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 11, 109, 111, 117, 115, 101, 45, 100, 101, 108, 116, 97, 1, 11, 109, 111, 117, 115, 101, 45, 119, 104, 101, 101, 108, 118, 13, 109, 111, 117, 115, 101, 45, 98, 117, 116, 116, 111, 110, 115, 9, 4, 5, 105, 110, 112, 117, 116, 0, 3, 0, 10, 1, 113, 35, 12, 100, 101, 102, 97, 117, 108, 116, 45, 105, 99, 111, 110, 0, 0, 9, 99, 114, 111, 115, 115, 104, 97, 105, 114, 0, 0, 4, 104, 97, 110, 100, 0, 0, 5, 97, 114, 114, 111, 119, 0, 0, 4, 109, 111, 118, 101, 0, 0, 4, 116, 101, 120, 116, 0, 0, 4, 119, 97, 105, 116, 0, 0, 4, 104, 101, 108, 112, 0, 0, 8, 112, 114, 111, 103, 114, 101, 115, 115, 0, 0, 11, 110, 111, 116, 45, 97, 108, 108, 111, 119, 101, 100, 0, 0, 12, 99, 111, 110, 116, 101, 120, 116, 45, 109, 101, 110, 117, 0, 0, 4, 99, 101, 108, 108, 0, 0, 13, 118, 101, 114, 116, 105, 99, 97, 108, 45, 116, 101, 120, 116, 0, 0, 5, 97, 108, 105, 97, 115, 0, 0, 4, 99, 111, 112, 121, 0, 0, 7, 110, 111, 45, 100, 114, 111, 112, 0, 0, 4, 103, 114, 97, 98, 0, 0, 8, 103, 114, 97, 98, 98, 105, 110, 103, 0, 0, 10, 97, 108, 108, 45, 115, 99, 114, 111, 108, 108, 0, 0, 7, 122, 111, 111, 109, 45, 105, 110, 0, 0, 8, 122, 111, 111, 109, 45, 111, 117, 116, 0, 0, 8, 101, 45, 114, 101, 115, 105, 122, 101, 0, 0, 8, 110, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 110, 101, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 110, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 8, 115, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 115, 101, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 115, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 8, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 101, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 110, 115, 45, 114, 101, 115, 105, 122, 101, 0, 0, 11, 110, 101, 115, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 11, 110, 119, 115, 101, 45, 114, 101, 115, 105, 122, 101, 0, 0, 10, 99, 111, 108, 45, 114, 101, 115, 105, 122, 101, 0, 0, 10, 114, 111, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 4, 11, 99, 117, 114, 115, 111, 114, 45, 105, 99, 111, 110, 0, 3, 0, 12, 1, 64, 0, 0, 11, 4, 3, 103, 101, 116, 0, 1, 14, 4, 12, 103, 101, 116, 45, 112, 114, 101, 118, 105, 111, 117, 115, 0, 1, 14, 1, 64, 1, 4, 105, 99, 111, 110, 13, 1, 0, 4, 10, 115, 101, 116, 45, 99, 117, 114, 115, 111, 114, 0, 1, 15, 1, 64, 1, 7, 118, 105, 115, 105, 98, 108, 101, 127, 1, 0, 4, 18, 115, 101, 116, 45, 99, 117, 114, 115, 111, 114, 45, 118, 105, 115, 105, 98, 108, 101, 0, 1, 16, 1, 64, 1, 6, 108, 111, 99, 107, 101, 100, 127, 1, 0, 4, 15, 115, 101, 116, 45, 99, 117, 114, 115, 111, 114, 45, 108, 111, 99, 107, 0, 1, 17, 3, 12, 99, 108, 105, 101, 110, 116, 45, 105, 110, 112, 117, 116, 30, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 105, 110, 112, 117, 116, 47, 99, 108, 105, 101, 110, 116, 45, 105, 110, 112, 117, 116, 5, 29, 2, 3, 0, 0, 3, 114, 97, 121, 1, 66, 16, 2, 3, 2, 1, 3, 4, 4, 118, 101, 99, 51, 0, 3, 0, 0, 2, 3, 2, 1, 2, 4, 4, 118, 101, 99, 50, 0, 3, 0, 2, 2, 3, 2, 1, 30, 4, 3, 114, 97, 121, 0, 3, 0, 4, 2, 3, 2, 1, 11, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 6, 1, 64, 2, 6, 99, 97, 109, 101, 114, 97, 7, 14, 99, 108, 105, 112, 45, 115, 112, 97, 99, 101, 45, 112, 111, 115, 3, 0, 5, 4, 14, 99, 108, 105, 112, 45, 115, 112, 97, 99, 101, 45, 114, 97, 121, 0, 1, 8, 1, 64, 1, 10, 115, 99, 114, 101, 101, 110, 45, 112, 111, 115, 3, 0, 3, 4, 20, 115, 99, 114, 101, 101, 110, 45, 116, 111, 45, 99, 108, 105, 112, 45, 115, 112, 97, 99, 101, 0, 1, 9, 1, 64, 2, 6, 99, 97, 109, 101, 114, 97, 7, 10, 115, 99, 114, 101, 101, 110, 45, 112, 111, 115, 3, 0, 5, 4, 25, 115, 99, 114, 101, 101, 110, 45, 116, 111, 45, 119, 111, 114, 108, 100, 45, 100, 105, 114, 101, 99, 116, 105, 111, 110, 0, 1, 10, 1, 64, 2, 6, 99, 97, 109, 101, 114, 97, 7, 10, 115, 99, 114, 101, 101, 110, 45, 112, 111, 115, 1, 0, 3, 4, 15, 119, 111, 114, 108, 100, 45, 116, 111, 45, 115, 99, 114, 101, 101, 110, 0, 1, 11, 3, 13, 99, 108, 105, 101, 110, 116, 45, 99, 97, 109, 101, 114, 97, 32, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 99, 97, 109, 101, 114, 97, 47, 99, 108, 105, 101, 110, 116, 45, 99, 97, 109, 101, 114, 97, 5, 31, 1, 66, 2, 1, 64, 1, 10, 102, 117, 108, 108, 115, 99, 114, 101, 101, 110, 127, 1, 0, 4, 14, 115, 101, 116, 45, 102, 117, 108, 108, 115, 99, 114, 101, 101, 110, 0, 1, 0, 3, 13, 99, 108, 105, 101, 110, 116, 45, 119, 105, 110, 100, 111, 119, 32, 112, 107, 103, 58, 47, 99, 108, 105, 101, 110, 116, 45, 119, 105, 110, 100, 111, 119, 47, 99, 108, 105, 101, 110, 116, 45, 119, 105, 110, 100, 111, 119, 5, 32, 1, 66, 43, 2, 3, 2, 1, 11, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 3, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 2, 3, 2, 1, 12, 4, 4, 109, 97, 116, 52, 0, 3, 0, 4, 1, 114, 3, 4, 115, 105, 100, 101, 127, 2, 117, 112, 127, 4, 100, 111, 119, 110, 127, 4, 19, 99, 104, 97, 114, 97, 99, 116, 101, 114, 45, 99, 111, 108, 108, 105, 115, 105, 111, 110, 0, 3, 0, 6, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 102, 111, 114, 99, 101, 3, 1, 0, 4, 9, 97, 100, 100, 45, 102, 111, 114, 99, 101, 0, 1, 8, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 109, 112, 117, 108, 115, 101, 3, 1, 0, 4, 11, 97, 100, 100, 45, 105, 109, 112, 117, 108, 115, 101, 0, 1, 9, 1, 107, 118, 1, 64, 4, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 7, 105, 109, 112, 117, 108, 115, 101, 118, 6, 114, 97, 100, 105, 117, 115, 118, 14, 102, 97, 108, 108, 111, 102, 102, 45, 114, 97, 100, 105, 117, 115, 10, 1, 0, 4, 18, 97, 100, 100, 45, 114, 97, 100, 105, 97, 108, 45, 105, 109, 112, 117, 108, 115, 101, 0, 1, 11, 1, 64, 3, 6, 101, 110, 116, 105, 116, 121, 1, 5, 102, 111, 114, 99, 101, 3, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 1, 0, 4, 21, 97, 100, 100, 45, 102, 111, 114, 99, 101, 45, 97, 116, 45, 112, 111, 115, 105, 116, 105, 111, 110, 0, 1, 12, 1, 64, 3, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 109, 112, 117, 108, 115, 101, 3, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 1, 0, 4, 23, 97, 100, 100, 45, 105, 109, 112, 117, 108, 115, 101, 45, 97, 116, 45, 112, 111, 115, 105, 116, 105, 111, 110, 0, 1, 13, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 0, 3, 4, 24, 103, 101, 116, 45, 118, 101, 108, 111, 99, 105, 116, 121, 45, 97, 116, 45, 112, 111, 115, 105, 116, 105, 111, 110, 0, 1, 14, 1, 64, 1, 7, 103, 114, 97, 118, 105, 116, 121, 3, 1, 0, 4, 11, 115, 101, 116, 45, 103, 114, 97, 118, 105, 116, 121, 0, 1, 15, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 1, 0, 4, 8, 117, 110, 102, 114, 101, 101, 122, 101, 0, 1, 16, 4, 6, 102, 114, 101, 101, 122, 101, 0, 1, 16, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 8, 118, 101, 108, 111, 99, 105, 116, 121, 118, 1, 0, 4, 11, 115, 116, 97, 114, 116, 45, 109, 111, 116, 111, 114, 0, 1, 17, 4, 10, 115, 116, 111, 112, 45, 109, 111, 116, 111, 114, 0, 1, 16, 1, 64, 4, 6, 97, 99, 116, 111, 114, 48, 1, 10, 116, 114, 97, 110, 115, 102, 111, 114, 109, 48, 5, 6, 97, 99, 116, 111, 114, 49, 1, 10, 116, 114, 97, 110, 115, 102, 111, 114, 109, 49, 5, 1, 0, 4, 21, 99, 114, 101, 97, 116, 101, 45, 114, 101, 118, 111, 108, 117, 116, 101, 45, 106, 111, 105, 110, 116, 0, 1, 18, 1, 111, 2, 1, 118, 1, 107, 19, 1, 64, 2, 6, 111, 114, 105, 103, 105, 110, 3, 9, 100, 105, 114, 101, 99, 116, 105, 111, 110, 3, 0, 20, 4, 13, 114, 97, 121, 99, 97, 115, 116, 45, 102, 105, 114, 115, 116, 0, 1, 21, 1, 112, 19, 1, 64, 2, 6, 111, 114, 105, 103, 105, 110, 3, 9, 100, 105, 114, 101, 99, 116, 105, 111, 110, 3, 0, 22, 4, 7, 114, 97, 121, 99, 97, 115, 116, 0, 1, 23, 1, 64, 4, 6, 101, 110, 116, 105, 116, 121, 1, 12, 100, 105, 115, 112, 108, 97, 99, 101, 109, 101, 110, 116, 3, 8, 109, 105, 110, 45, 100, 105, 115, 116, 118, 12, 101, 108, 97, 112, 115, 101, 100, 45, 116, 105, 109, 101, 118, 0, 7, 4, 14, 109, 111, 118, 101, 45, 99, 104, 97, 114, 97, 99, 116, 101, 114, 0, 1, 24, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 1, 0, 4, 22, 115, 101, 116, 45, 99, 104, 97, 114, 97, 99, 116, 101, 114, 45, 112, 111, 115, 105, 116, 105, 111, 110, 0, 1, 25, 4, 27, 115, 101, 116, 45, 99, 104, 97, 114, 97, 99, 116, 101, 114, 45, 102, 111, 111, 116, 45, 112, 111, 115, 105, 116, 105, 111, 110, 0, 1, 25, 3, 14, 115, 101, 114, 118, 101, 114, 45, 112, 104, 121, 115, 105, 99, 115, 34, 112, 107, 103, 58, 47, 115, 101, 114, 118, 101, 114, 45, 112, 104, 121, 115, 105, 99, 115, 47, 115, 101, 114, 118, 101, 114, 45, 112, 104, 121, 115, 105, 99, 115, 5, 33, 1, 66, 7, 2, 3, 2, 1, 11, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 1, 113, 6, 27, 99, 108, 105, 101, 110, 116, 45, 98, 114, 111, 97, 100, 99, 97, 115, 116, 45, 117, 110, 114, 101, 108, 105, 97, 98, 108, 101, 0, 0, 25, 99, 108, 105, 101, 110, 116, 45, 98, 114, 111, 97, 100, 99, 97, 115, 116, 45, 114, 101, 108, 105, 97, 98, 108, 101, 0, 0, 26, 99, 108, 105, 101, 110, 116, 45, 116, 97, 114, 103, 101, 116, 101, 100, 45, 117, 110, 114, 101, 108, 105, 97, 98, 108, 101, 1, 115, 0, 24, 99, 108, 105, 101, 110, 116, 45, 116, 97, 114, 103, 101, 116, 101, 100, 45, 114, 101, 108, 105, 97, 98, 108, 101, 1, 115, 0, 15, 108, 111, 99, 97, 108, 45, 98, 114, 111, 97, 100, 99, 97, 115, 116, 0, 0, 5, 108, 111, 99, 97, 108, 1, 1, 0, 4, 6, 116, 97, 114, 103, 101, 116, 0, 3, 0, 2, 1, 112, 125, 1, 64, 3, 9, 116, 97, 114, 103, 101, 116, 45, 105, 100, 3, 4, 110, 97, 109, 101, 115, 4, 100, 97, 116, 97, 4, 1, 0, 4, 4, 115, 101, 110, 100, 0, 1, 5, 3, 14, 115, 101, 114, 118, 101, 114, 45, 109, 101, 115, 115, 97, 103, 101, 34, 112, 107, 103, 58, 47, 115, 101, 114, 118, 101, 114, 45, 109, 101, 115, 115, 97, 103, 101, 47, 115, 101, 114, 118, 101, 114, 45, 109, 101, 115, 115, 97, 103, 101, 5, 34, 1, 66, 9, 2, 3, 2, 1, 11, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 1, 113, 4, 7, 114, 117, 110, 116, 105, 109, 101, 0, 0, 5, 108, 111, 99, 97, 108, 1, 1, 0, 6, 115, 101, 114, 118, 101, 114, 0, 0, 6, 99, 108, 105, 101, 110, 116, 1, 115, 0, 4, 6, 115, 111, 117, 114, 99, 101, 0, 3, 0, 2, 1, 64, 0, 1, 0, 4, 4, 105, 110, 105, 116, 0, 1, 4, 1, 112, 125, 1, 64, 4, 4, 116, 105, 109, 101, 118, 14, 109, 101, 115, 115, 97, 103, 101, 45, 115, 111, 117, 114, 99, 101, 3, 12, 109, 101, 115, 115, 97, 103, 101, 45, 110, 97, 109, 101, 115, 12, 109, 101, 115, 115, 97, 103, 101, 45, 100, 97, 116, 97, 5, 1, 0, 4, 4, 101, 120, 101, 99, 0, 1, 6, 4, 5, 103, 117, 101, 115, 116, 16, 112, 107, 103, 58, 47, 103, 117, 101, 115, 116, 47, 103, 117, 101, 115, 116, 5, 35, 4, 8, 98, 105, 110, 100, 105, 110, 103, 115, 18, 112, 107, 103, 58, 47, 109, 97, 105, 110, 47, 98, 105, 110, 100, 105, 110, 103, 115, 4, 0, 0, 68, 9, 112, 114, 111, 100, 117, 99, 101, 114, 115, 1, 12, 112, 114, 111, 99, 101, 115, 115, 101, 100, 45, 98, 121, 2, 13, 119, 105, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 5, 48, 46, 56, 46, 50, 16, 119, 105, 116, 45, 98, 105, 110, 100, 103, 101, 110, 45, 114, 117, 115, 116, 5, 48, 46, 54, 46, 48, 11, 19, 1, 4, 109, 97, 105, 110, 9, 112, 107, 103, 58, 47, 109, 97, 105, 110, 3, 42, 0];
                                    
                                    #[inline(never)]
                                    #[doc(hidden)]
                                    #[cfg(target_arch = "wasm32")]
                                    pub fn __link_section() {}
                                    